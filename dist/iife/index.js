var facetsdocs = (function (exports) {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line no-undef
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func
	  Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;

	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty = {}.hasOwnProperty;

	var has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var document$1 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject(document$1) && isObject(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$1
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	var nativeDefineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store;

	var functionToString = Function.toString;

	// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap$1 = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));

	var isPure = false;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.6.5',
	  mode:  'global',
	  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys = shared('keys');

	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var hiddenKeys = {};

	var WeakMap$2 = global_1.WeakMap;
	var set, get, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap) {
	  var store$1 = new WeakMap$2();
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;
	  set = function (it, metadata) {
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return wmget.call(store$1, it) || {};
	  };
	  has$1 = function (it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set = function (it, metadata) {
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function (it) {
	    return has(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var redefine = createCommonjsModule(function (module) {
	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');

	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  if (typeof value == 'function') {
	    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
	    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
	  }
	  if (O === global_1) {
	    if (simple) O[key] = value;
	    else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }
	  if (simple) O[key] = value;
	  else createNonEnumerableProperty(O, key, value);
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	});
	});

	var path = global_1;

	var aFunction = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
	    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min = Math.min;

	// `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod(false)
	};

	var indexOf = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
		f: f$3
	};

	var f$4 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$4
	};

	// all object keys, includes non-enumerable and symbols
	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    // extend global
	    redefine(target, key, sourceProperty, options);
	  }
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol
	  // eslint-disable-next-line no-undef
	  && !Symbol.sham
	  // eslint-disable-next-line no-undef
	  && typeof Symbol.iterator == 'symbol';

	// `IsArray` abstract operation
	// https://tc39.github.io/ecma262/#sec-isarray
	var isArray = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	// `ToObject` abstract operation
	// https://tc39.github.io/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO] = true;

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return nativeGetOwnPropertyNames(it);
	  } catch (error) {
	    return windowNames.slice();
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]'
	    ? getWindowNames(it)
	    : nativeGetOwnPropertyNames(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$5
	};

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
	    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore[name];
	};

	var f$6 = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f$6
	};

	var defineProperty = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path.Symbol || (path.Symbol = {});
	  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  });
	};

	var defineProperty$1 = objectDefineProperty.f;



	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
	    defineProperty$1(it, TO_STRING_TAG, { configurable: true, value: TAG });
	  }
	};

	var aFunction$1 = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction$1(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var SPECIES = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    else if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
	var createMethod$1 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } else if (IS_EVERY) return false;  // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$1(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod$1(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod$1(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod$1(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod$1(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod$1(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$1(6)
	};

	var $forEach = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(SYMBOL);
	var ObjectPrototype = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var $stringify = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty$1 = objectDefineProperty.f;
	var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore$1 = shared('wks');
	var QObject = global_1.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate(nativeDefineProperty$1({}, 'a', {
	    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
	  nativeDefineProperty$1(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
	    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty$1;

	var wrap = function (tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
	  setInternalState(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};

	var isSymbol = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return Object(it) instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPrimitive(P, true);
	  anObject(Attributes);
	  if (has(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
	    } return setSymbolDescriptor(O, key, Attributes);
	  } return nativeDefineProperty$1(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach(keys, function (key) {
	    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
	};

	var $propertyIsEnumerable = function propertyIsEnumerable(V) {
	  var P = toPrimitive(V, true);
	  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
	  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPrimitive(P, true);
	  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
	  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
	  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
	      result.push(AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.github.io/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var tag = uid(description);
	    var setter = function (value) {
	      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
	    return wrap(tag, description);
	  };

	  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
	    return getInternalState(this).tag;
	  });

	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap(uid(description), description);
	  });

	  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
	  objectDefineProperty.f = $defineProperty;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap(wellKnownSymbol(name), name);
	  };

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState(this).description;
	      }
	    });
	    {
	      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
	    }
	  }
	}

	_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
	  Symbol: $Symbol
	});

	$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {
	  defineWellKnownSymbol(name);
	});

	_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
	  // `Symbol.for` method
	  // https://tc39.github.io/ecma262/#sec-symbol.for
	  'for': function (key) {
	    var string = String(key);
	    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
	    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  },
	  useSetter: function () { USE_SETTER = true; },
	  useSimple: function () { USE_SETTER = false; }
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
	  // `Object.create` method
	  // https://tc39.github.io/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	});

	// `JSON.stringify` method behavior with symbols
	// https://tc39.github.io/ecma262/#sec-json.stringify
	if ($stringify) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol();
	    // MS Edge converts symbol values to JSON as {}
	    return $stringify([symbol]) != '[null]'
	      // WebKit converts symbol values to JSON as null
	      || $stringify({ a: symbol }) != '{}'
	      // V8 throws on boxed symbols
	      || $stringify(Object(symbol)) != '{}';
	  });

	  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var args = [it];
	      var index = 1;
	      var $replacer;
	      while (arguments.length > index) args.push(arguments[index++]);
	      $replacer = replacer;
	      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	      if (!isArray(replacer)) replacer = function (key, value) {
	        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	        if (!isSymbol(value)) return value;
	      };
	      args[1] = replacer;
	      return $stringify.apply(null, args);
	    }
	  });
	}

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
	if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
	  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
	}
	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);

	hiddenKeys[HIDDEN] = true;

	// `Symbol.asyncIterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
	defineWellKnownSymbol('asyncIterator');

	var defineProperty$2 = objectDefineProperty.f;


	var NativeSymbol = global_1.Symbol;

	if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
	  // Safari 12 bug
	  NativeSymbol().description !== undefined
	)) {
	  var EmptyStringDescriptionStore = {};
	  // wrap Symbol constructor for correct work with undefined description
	  var SymbolWrapper = function Symbol() {
	    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var result = this instanceof SymbolWrapper
	      ? new NativeSymbol(description)
	      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
	      : description === undefined ? NativeSymbol() : NativeSymbol(description);
	    if (description === '') EmptyStringDescriptionStore[result] = true;
	    return result;
	  };
	  copyConstructorProperties(SymbolWrapper, NativeSymbol);
	  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
	  symbolPrototype.constructor = SymbolWrapper;

	  var symbolToString = symbolPrototype.toString;
	  var native = String(NativeSymbol('test')) == 'Symbol(test)';
	  var regexp = /^Symbol\((.*)\)[^)]+$/;
	  defineProperty$2(symbolPrototype, 'description', {
	    configurable: true,
	    get: function description() {
	      var symbol = isObject(this) ? this.valueOf() : this;
	      var string = symbolToString.call(symbol);
	      if (has(EmptyStringDescriptionStore, symbol)) return '';
	      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
	      return desc === '' ? undefined : desc;
	    }
	  });

	  _export({ global: true, forced: true }, {
	    Symbol: SymbolWrapper
	  });
	}

	// `Symbol.hasInstance` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.hasinstance
	defineWellKnownSymbol('hasInstance');

	// `Symbol.isConcatSpreadable` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable
	defineWellKnownSymbol('isConcatSpreadable');

	// `Symbol.iterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.iterator
	defineWellKnownSymbol('iterator');

	// `Symbol.match` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.match
	defineWellKnownSymbol('match');

	// `Symbol.matchAll` well-known symbol
	defineWellKnownSymbol('matchAll');

	// `Symbol.replace` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.replace
	defineWellKnownSymbol('replace');

	// `Symbol.search` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.search
	defineWellKnownSymbol('search');

	// `Symbol.species` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.species
	defineWellKnownSymbol('species');

	// `Symbol.split` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.split
	defineWellKnownSymbol('split');

	// `Symbol.toPrimitive` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.toprimitive
	defineWellKnownSymbol('toPrimitive');

	// `Symbol.toStringTag` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
	defineWellKnownSymbol('toStringTag');

	// `Symbol.unscopables` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.unscopables
	defineWellKnownSymbol('unscopables');

	var nativeAssign = Object.assign;
	var defineProperty$3 = Object.defineProperty;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	var objectAssign = !nativeAssign || fails(function () {
	  // should have correct order of operations (Edge bug)
	  if (descriptors && nativeAssign({ b: 1 }, nativeAssign(defineProperty$3({}, 'a', {
	    enumerable: true,
	    get: function () {
	      defineProperty$3(this, 'b', {
	        value: 3,
	        enumerable: false
	      });
	    }
	  }), { b: 2 })).b !== 1) return true;
	  // should work with symbols and should have deterministic property order (V8 bug)
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
	  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
	  while (argumentsLength > index) {
	    var S = indexedObject(arguments[index++]);
	    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
	    }
	  } return T;
	} : nativeAssign;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
	  assign: objectAssign
	});

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  create: objectCreate
	});

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
	  defineProperty: objectDefineProperty.f
	});

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
	  defineProperties: objectDefineProperties
	});

	var propertyIsEnumerable = objectPropertyIsEnumerable.f;

	// `Object.{ entries, values }` methods implementation
	var createMethod$2 = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable.call(O, key)) {
	        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.github.io/ecma262/#sec-object.entries
	  entries: createMethod$2(true),
	  // `Object.values` method
	  // https://tc39.github.io/ecma262/#sec-object.values
	  values: createMethod$2(false)
	};

	var $entries = objectToArray.entries;

	// `Object.entries` method
	// https://tc39.github.io/ecma262/#sec-object.entries
	_export({ target: 'Object', stat: true }, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var freezing = !fails(function () {
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule(function (module) {
	var defineProperty = objectDefineProperty.f;



	var METADATA = uid('meta');
	var id = 0;

	var isExtensible = Object.isExtensible || function () {
	  return true;
	};

	var setMetadata = function (it) {
	  defineProperty(it, METADATA, { value: {
	    objectID: 'O' + ++id, // object ID
	    weakData: {}          // weak collections IDs
	  } });
	};

	var fastKey = function (it, create) {
	  // return a primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMetadata(it);
	  // return object ID
	  } return it[METADATA].objectID;
	};

	var getWeakData = function (it, create) {
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMetadata(it);
	  // return the store of weak collections IDs
	  } return it[METADATA].weakData;
	};

	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
	  return it;
	};

	var meta = module.exports = {
	  REQUIRED: false,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};

	hiddenKeys[METADATA] = true;
	});

	var onFreeze = internalMetadata.onFreeze;

	var nativeFreeze = Object.freeze;
	var FAILS_ON_PRIMITIVES = fails(function () { nativeFreeze(1); });

	// `Object.freeze` method
	// https://tc39.github.io/ecma262/#sec-object.freeze
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !freezing }, {
	  freeze: function freeze(it) {
	    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
	  }
	});

	var iterators = {};

	var ITERATOR = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR] === it);
	};

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var test = {};

	test[TO_STRING_TAG$1] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	var ITERATOR$1 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$1]
	    || it['@@iterator']
	    || iterators[classof(it)];
	};

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    var returnMethod = iterator['return'];
	    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
	    throw error;
	  }
	};

	var iterate_1 = createCommonjsModule(function (module) {
	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
	  var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
	  var iterator, iterFn, index, length, result, next, step;

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = AS_ENTRIES
	          ? boundFunction(anObject(step = iterable[index])[0], step[1])
	          : boundFunction(iterable[index]);
	        if (result && result instanceof Result) return result;
	      } return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }

	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
	    if (typeof result == 'object' && result && result instanceof Result) return result;
	  } return new Result(false);
	};

	iterate.stop = function (result) {
	  return new Result(true, result);
	};
	});

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
	  else object[propertyKey] = value;
	};

	// `Object.fromEntries` method
	// https://github.com/tc39/proposal-object-from-entries
	_export({ target: 'Object', stat: true }, {
	  fromEntries: function fromEntries(iterable) {
	    var obj = {};
	    iterate_1(iterable, function (k, v) {
	      createProperty(obj, k, v);
	    }, undefined, true);
	    return obj;
	  }
	});

	var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;


	var FAILS_ON_PRIMITIVES$1 = fails(function () { nativeGetOwnPropertyDescriptor$2(1); });
	var FORCED = !descriptors || FAILS_ON_PRIMITIVES$1;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	_export({ target: 'Object', stat: true, forced: FORCED, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
	    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
	  }
	});

	// `Object.getOwnPropertyDescriptors` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIndexedObject(object);
	    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var index = 0;
	    var key, descriptor;
	    while (keys.length > index) {
	      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
	      if (descriptor !== undefined) createProperty(result, key, descriptor);
	    }
	    return result;
	  }
	});

	var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;

	var FAILS_ON_PRIMITIVES$2 = fails(function () { return !Object.getOwnPropertyNames(1); });

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2 }, {
	  getOwnPropertyNames: nativeGetOwnPropertyNames$2
	});

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype$1 = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype$1 : null;
	};

	var FAILS_ON_PRIMITIVES$3 = fails(function () { objectGetPrototypeOf(1); });

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$3, sham: !correctPrototypeGetter }, {
	  getPrototypeOf: function getPrototypeOf(it) {
	    return objectGetPrototypeOf(toObject(it));
	  }
	});

	// `SameValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-samevalue
	var sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// `Object.is` method
	// https://tc39.github.io/ecma262/#sec-object.is
	_export({ target: 'Object', stat: true }, {
	  is: sameValue
	});

	var nativeIsExtensible = Object.isExtensible;
	var FAILS_ON_PRIMITIVES$4 = fails(function () { nativeIsExtensible(1); });

	// `Object.isExtensible` method
	// https://tc39.github.io/ecma262/#sec-object.isextensible
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$4 }, {
	  isExtensible: function isExtensible(it) {
	    return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
	  }
	});

	var nativeIsFrozen = Object.isFrozen;
	var FAILS_ON_PRIMITIVES$5 = fails(function () { nativeIsFrozen(1); });

	// `Object.isFrozen` method
	// https://tc39.github.io/ecma262/#sec-object.isfrozen
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$5 }, {
	  isFrozen: function isFrozen(it) {
	    return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
	  }
	});

	var nativeIsSealed = Object.isSealed;
	var FAILS_ON_PRIMITIVES$6 = fails(function () { nativeIsSealed(1); });

	// `Object.isSealed` method
	// https://tc39.github.io/ecma262/#sec-object.issealed
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$6 }, {
	  isSealed: function isSealed(it) {
	    return isObject(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
	  }
	});

	var FAILS_ON_PRIMITIVES$7 = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$7 }, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var onFreeze$1 = internalMetadata.onFreeze;



	var nativePreventExtensions = Object.preventExtensions;
	var FAILS_ON_PRIMITIVES$8 = fails(function () { nativePreventExtensions(1); });

	// `Object.preventExtensions` method
	// https://tc39.github.io/ecma262/#sec-object.preventextensions
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$8, sham: !freezing }, {
	  preventExtensions: function preventExtensions(it) {
	    return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze$1(it)) : it;
	  }
	});

	var onFreeze$2 = internalMetadata.onFreeze;



	var nativeSeal = Object.seal;
	var FAILS_ON_PRIMITIVES$9 = fails(function () { nativeSeal(1); });

	// `Object.seal` method
	// https://tc39.github.io/ecma262/#sec-object.seal
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$9, sham: !freezing }, {
	  seal: function seal(it) {
	    return nativeSeal && isObject(it) ? nativeSeal(onFreeze$2(it)) : it;
	  }
	});

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	_export({ target: 'Object', stat: true }, {
	  setPrototypeOf: objectSetPrototypeOf
	});

	var $values = objectToArray.values;

	// `Object.values` method
	// https://tc39.github.io/ecma262/#sec-object.values
	_export({ target: 'Object', stat: true }, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	// `Object.prototype.toString` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	var objectToString = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// `Object.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString, { unsafe: true });
	}

	// Forced replacement object prototype accessors methods
	var objectPrototypeAccessorsForced =  !fails(function () {
	  var key = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, key, function () { /* empty */ });
	  delete global_1[key];
	});

	// `Object.prototype.__defineGetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __defineGetter__: function __defineGetter__(P, getter) {
	      objectDefineProperty.f(toObject(this), P, { get: aFunction$1(getter), enumerable: true, configurable: true });
	    }
	  });
	}

	// `Object.prototype.__defineSetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__defineSetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __defineSetter__: function __defineSetter__(P, setter) {
	      objectDefineProperty.f(toObject(this), P, { set: aFunction$1(setter), enumerable: true, configurable: true });
	    }
	  });
	}

	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;

	// `Object.prototype.__lookupGetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupGetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __lookupGetter__: function __lookupGetter__(P) {
	      var O = toObject(this);
	      var key = toPrimitive(P, true);
	      var desc;
	      do {
	        if (desc = getOwnPropertyDescriptor$2(O, key)) return desc.get;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;

	// `Object.prototype.__lookupSetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupSetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __lookupSetter__: function __lookupSetter__(P) {
	      var O = toObject(this);
	      var key = toPrimitive(P, true);
	      var desc;
	      do {
	        if (desc = getOwnPropertyDescriptor$3(O, key)) return desc.set;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var slice = [].slice;
	var factories = {};

	var construct = function (C, argsLength, args) {
	  if (!(argsLength in factories)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
	  } return factories[argsLength](C, args);
	};

	// `Function.prototype.bind` method implementation
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind
	var functionBind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction$1(this);
	  var partArgs = slice.call(arguments, 1);
	  var boundFunction = function bound(/* args... */) {
	    var args = partArgs.concat(slice.call(arguments));
	    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
	  };
	  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
	  return boundFunction;
	};

	// `Function.prototype.bind` method
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind
	_export({ target: 'Function', proto: true }, {
	  bind: functionBind
	});

	var defineProperty$4 = objectDefineProperty.f;

	var FunctionPrototype = Function.prototype;
	var FunctionPrototypeToString = FunctionPrototype.toString;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// Function instances `.name` property
	// https://tc39.github.io/ecma262/#sec-function-instances-name
	if (descriptors && !(NAME in FunctionPrototype)) {
	  defineProperty$4(FunctionPrototype, NAME, {
	    configurable: true,
	    get: function () {
	      try {
	        return FunctionPrototypeToString.call(this).match(nameRE)[1];
	      } catch (error) {
	        return '';
	      }
	    }
	  });
	}

	var HAS_INSTANCE = wellKnownSymbol('hasInstance');
	var FunctionPrototype$1 = Function.prototype;

	// `Function.prototype[@@hasInstance]` method
	// https://tc39.github.io/ecma262/#sec-function.prototype-@@hasinstance
	if (!(HAS_INSTANCE in FunctionPrototype$1)) {
	  objectDefineProperty.f(FunctionPrototype$1, HAS_INSTANCE, { value: function (O) {
	    if (typeof this != 'function' || !isObject(O)) return false;
	    if (!isObject(this.prototype)) return O instanceof this;
	    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	    while (O = objectGetPrototypeOf(O)) if (this.prototype === O) return true;
	    return false;
	  } });
	}

	// `globalThis` object
	// https://github.com/tc39/proposal-global
	_export({ global: true }, {
	  globalThis: global_1
	});

	// `Array.from` method implementation
	// https://tc39.github.io/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var C = typeof this == 'function' ? this : Array;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value;
	  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    result = new C();
	    for (;!(step = next.call(iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = toLength(O.length);
	    result = new C(length);
	    for (;length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }
	  result.length = index;
	  return result;
	};

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$2] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
	  Array.from(iterable);
	});

	// `Array.from` method
	// https://tc39.github.io/ecma262/#sec-array.from
	_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
	  from: arrayFrom
	});

	// `Array.isArray` method
	// https://tc39.github.io/ecma262/#sec-array.isarray
	_export({ target: 'Array', stat: true }, {
	  isArray: isArray
	});

	var ISNT_GENERIC = fails(function () {
	  function F() { /* empty */ }
	  return !(Array.of.call(F) instanceof F);
	});

	// `Array.of` method
	// https://tc39.github.io/ecma262/#sec-array.of
	// WebKit Array.of isn't generic
	_export({ target: 'Array', stat: true, forced: ISNT_GENERIC }, {
	  of: function of(/* ...args */) {
	    var index = 0;
	    var argumentsLength = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(argumentsLength);
	    while (argumentsLength > index) createProperty(result, index, arguments[index++]);
	    result.length = argumentsLength;
	    return result;
	  }
	});

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process = global_1.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  version = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = match[1];
	  }
	}

	var engineV8Version = version && +version;

	var SPECIES$1 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$1] = function () {
	      return { foo: 1 };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});

	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function (O) {
	  if (!isObject(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray(O);
	};

	var FORCED$1 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({ target: 'Array', proto: true, forced: FORCED$1 }, {
	  concat: function concat(arg) { // eslint-disable-line no-unused-vars
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];
	      if (isConcatSpreadable(E)) {
	        len = toLength(E.length);
	        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
	      } else {
	        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	var min$2 = Math.min;

	// `Array.prototype.copyWithin` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
	var arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = min$2((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype$1 = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables = function (key) {
	  ArrayPrototype$1[UNSCOPABLES][key] = true;
	};

	// `Array.prototype.copyWithin` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
	_export({ target: 'Array', proto: true }, {
	  copyWithin: arrayCopyWithin
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('copyWithin');

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal
	    method.call(null, argument || function () { throw 1; }, 1);
	  });
	};

	var defineProperty$5 = Object.defineProperty;
	var cache = {};

	var thrower = function (it) { throw it; };

	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
	  if (!options) options = {};
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has(options, 0) ? options[0] : thrower;
	  var argument1 = has(options, 1) ? options[1] : undefined;

	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) return true;
	    var O = { length: -1 };

	    if (ACCESSORS) defineProperty$5(O, 1, { enumerable: true, get: thrower });
	    else O[1] = 1;

	    method.call(O, argument0, argument1);
	  });
	};

	var $every = arrayIteration.every;



	var STRICT_METHOD = arrayMethodIsStrict('every');
	var USES_TO_LENGTH = arrayMethodUsesToLength('every');

	// `Array.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.every
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Array.prototype.fill` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.fill
	var arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};

	// `Array.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.fill
	_export({ target: 'Array', proto: true }, {
	  fill: arrayFill
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('fill');

	var $filter = arrayIteration.filter;



	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
	// Edge 14- issue
	var USES_TO_LENGTH$1 = arrayMethodUsesToLength('filter');

	// `Array.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$1 }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $find = arrayIteration.find;



	var FIND = 'find';
	var SKIPS_HOLES = true;

	var USES_TO_LENGTH$2 = arrayMethodUsesToLength(FIND);

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

	// `Array.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$2 }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND);

	var $findIndex = arrayIteration.findIndex;



	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES$1 = true;

	var USES_TO_LENGTH$3 = arrayMethodUsesToLength(FIND_INDEX);

	// Shouldn't skip holes
	if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; });

	// `Array.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$3 }, {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND_INDEX);

	// `FlattenIntoArray` abstract operation
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? functionBindContext(mapper, thisArg, 3) : false;
	  var element;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      if (depth > 0 && isArray(element)) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	};

	var flattenIntoArray_1 = flattenIntoArray;

	// `Array.prototype.flat` method
	// https://github.com/tc39/proposal-flatMap
	_export({ target: 'Array', proto: true }, {
	  flat: function flat(/* depthArg = 1 */) {
	    var depthArg = arguments.length ? arguments[0] : undefined;
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});

	// `Array.prototype.flatMap` method
	// https://github.com/tc39/proposal-flatMap
	_export({ target: 'Array', proto: true }, {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A;
	    aFunction$1(callbackfn);
	    A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return A;
	  }
	});

	var $forEach$1 = arrayIteration.forEach;



	var STRICT_METHOD$1 = arrayMethodIsStrict('forEach');
	var USES_TO_LENGTH$4 = arrayMethodUsesToLength('forEach');

	// `Array.prototype.forEach` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	var arrayForEach = (!STRICT_METHOD$1 || !USES_TO_LENGTH$4) ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
	  forEach: arrayForEach
	});

	var $includes = arrayIncludes.includes;



	var USES_TO_LENGTH$5 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$5 }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('includes');

	var $indexOf = arrayIncludes.indexOf;



	var nativeIndexOf = [].indexOf;

	var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
	var STRICT_METHOD$2 = arrayMethodIsStrict('indexOf');
	var USES_TO_LENGTH$6 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$2 || !USES_TO_LENGTH$6 }, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? nativeIndexOf.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var nativeJoin = [].join;

	var ES3_STRINGS = indexedObject != Object;
	var STRICT_METHOD$3 = arrayMethodIsStrict('join', ',');

	// `Array.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.join
	_export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$3 }, {
	  join: function join(separator) {
	    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
	  }
	});

	var min$3 = Math.min;
	var nativeLastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$4 = arrayMethodIsStrict('lastIndexOf');
	// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
	var USES_TO_LENGTH$7 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
	var FORCED$2 = NEGATIVE_ZERO$1 || !STRICT_METHOD$4 || !USES_TO_LENGTH$7;

	// `Array.prototype.lastIndexOf` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	var arrayLastIndexOf = FORCED$2 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO$1) return nativeLastIndexOf.apply(this, arguments) || 0;
	  var O = toIndexedObject(this);
	  var length = toLength(O.length);
	  var index = length - 1;
	  if (arguments.length > 1) index = min$3(index, toInteger(arguments[1]));
	  if (index < 0) index = length + index;
	  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
	  return -1;
	} : nativeLastIndexOf;

	// `Array.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	_export({ target: 'Array', proto: true, forced: arrayLastIndexOf !== [].lastIndexOf }, {
	  lastIndexOf: arrayLastIndexOf
	});

	var $map = arrayIteration.map;



	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map');
	// FF49- issue
	var USES_TO_LENGTH$8 = arrayMethodUsesToLength('map');

	// `Array.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$8 }, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Array.prototype.{ reduce, reduceRight }` methods implementation
	var createMethod$3 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction$1(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }
	    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	  left: createMethod$3(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$3(true)
	};

	var $reduce = arrayReduce.left;



	var STRICT_METHOD$5 = arrayMethodIsStrict('reduce');
	var USES_TO_LENGTH$9 = arrayMethodUsesToLength('reduce', { 1: 0 });

	// `Array.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$5 || !USES_TO_LENGTH$9 }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $reduceRight = arrayReduce.right;



	var STRICT_METHOD$6 = arrayMethodIsStrict('reduceRight');
	// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
	var USES_TO_LENGTH$a = arrayMethodUsesToLength('reduce', { 1: 0 });

	// `Array.prototype.reduceRight` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$6 || !USES_TO_LENGTH$a }, {
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var nativeReverse = [].reverse;
	var test$1 = [1, 2];

	// `Array.prototype.reverse` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
	// fix for Safari 12.0 bug
	// https://bugs.webkit.org/show_bug.cgi?id=188794
	_export({ target: 'Array', proto: true, forced: String(test$1) === String(test$1.reverse()) }, {
	  reverse: function reverse() {
	    // eslint-disable-next-line no-self-assign
	    if (isArray(this)) this.length = this.length;
	    return nativeReverse.call(this);
	  }
	});

	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');
	var USES_TO_LENGTH$b = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

	var SPECIES$2 = wellKnownSymbol('species');
	var nativeSlice = [].slice;
	var max$1 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$b }, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = toLength(O.length);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject(Constructor)) {
	        Constructor = Constructor[SPECIES$2];
	        if (Constructor === null) Constructor = undefined;
	      }
	      if (Constructor === Array || Constructor === undefined) {
	        return nativeSlice.call(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
	    result.length = n;
	    return result;
	  }
	});

	var $some = arrayIteration.some;



	var STRICT_METHOD$7 = arrayMethodIsStrict('some');
	var USES_TO_LENGTH$c = arrayMethodUsesToLength('some');

	// `Array.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.some
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$7 || !USES_TO_LENGTH$c }, {
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var test$2 = [];
	var nativeSort = test$2.sort;

	// IE8-
	var FAILS_ON_UNDEFINED = fails(function () {
	  test$2.sort(undefined);
	});
	// V8 bug
	var FAILS_ON_NULL = fails(function () {
	  test$2.sort(null);
	});
	// Old WebKit
	var STRICT_METHOD$8 = arrayMethodIsStrict('sort');

	var FORCED$3 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$8;

	// `Array.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.sort
	_export({ target: 'Array', proto: true, forced: FORCED$3 }, {
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? nativeSort.call(toObject(this))
	      : nativeSort.call(toObject(this), aFunction$1(comparefn));
	  }
	});

	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');
	var USES_TO_LENGTH$d = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

	var max$2 = Math.max;
	var min$4 = Math.min;
	var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$d }, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$4(max$2(toInteger(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	var SPECIES$3 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$3]) {
	    defineProperty(Constructor, SPECIES$3, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	// `Array[@@species]` getter
	// https://tc39.github.io/ecma262/#sec-get-array-@@species
	setSpecies('Array');

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module


	addToUnscopables('flat');

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module


	addToUnscopables('flatMap');

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;

	var returnThis = function () { return this; };

	// `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}

	if (IteratorPrototype == undefined) IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	if ( !has(IteratorPrototype, ITERATOR$3)) {
	  createNonEnumerableProperty(IteratorPrototype, ITERATOR$3, returnThis);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$4 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$2 = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$4]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if ( IterablePrototype[ITERATOR$4] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
	  }

	  return methods;
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$1 = internalState.set;
	var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$1(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$1(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var fromCharCode = String.fromCharCode;
	var nativeFromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;

	// `String.fromCodePoint` method
	// https://tc39.github.io/ecma262/#sec-string.fromcodepoint
	_export({ target: 'String', stat: true, forced: INCORRECT_LENGTH }, {
	  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
	    var elements = [];
	    var length = arguments.length;
	    var i = 0;
	    var code;
	    while (length > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
	      elements.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00)
	      );
	    } return elements.join('');
	  }
	});

	// `String.raw` method
	// https://tc39.github.io/ecma262/#sec-string.raw
	_export({ target: 'String', stat: true }, {
	  raw: function raw(template) {
	    var rawTemplate = toIndexedObject(template.raw);
	    var literalSegments = toLength(rawTemplate.length);
	    var argumentsLength = arguments.length;
	    var elements = [];
	    var i = 0;
	    while (literalSegments > i) {
	      elements.push(String(rawTemplate[i++]));
	      if (i < argumentsLength) elements.push(String(arguments[i]));
	    } return elements.join('');
	  }
	});

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod$4 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING ? S.charAt(position) : first
	        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$4(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$4(true)
	};

	var codeAt = stringMultibyte.codeAt;

	// `String.prototype.codePointAt` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	_export({ target: 'String', proto: true }, {
	  codePointAt: function codePointAt(pos) {
	    return codeAt(this, pos);
	  }
	});

	var MATCH = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.github.io/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH$1 = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (e) {
	    try {
	      regexp[MATCH$1] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (f) { /* empty */ }
	  } return false;
	};

	var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;






	var nativeEndsWith = ''.endsWith;
	var min$5 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('endsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG =  !CORRECT_IS_REGEXP_LOGIC && !!function () {
	  var descriptor = getOwnPropertyDescriptor$4(String.prototype, 'endsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.endsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : min$5(toLength(endPosition), len);
	    var search = String(searchString);
	    return nativeEndsWith
	      ? nativeEndsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

	// `String.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this))
	      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
	// so we use an intermediate function.
	function RE(s, f) {
	  return RegExp(s, f);
	}

	var UNSUPPORTED_Y = fails(function () {
	  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
	  var re = RE('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') != null;
	});

	var BROKEN_CARET = fails(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = RE('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') != null;
	});

	var regexpStickyHelpers = {
		UNSUPPORTED_Y: UNSUPPORTED_Y,
		BROKEN_CARET: BROKEN_CARET
	};

	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;

	var patchedExec = nativeExec;

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	})();

	var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;
	    var sticky = UNSUPPORTED_Y$1 && re.sticky;
	    var flags = regexpFlags.call(re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;

	    if (sticky) {
	      flags = flags.replace('y', '');
	      if (flags.indexOf('g') === -1) {
	        flags += 'g';
	      }

	      strCopy = String(str).slice(re.lastIndex);
	      // Support anchored sticky behavior.
	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      }
	      // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.
	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

	    match = nativeExec.call(sticky ? reCopy : re, strCopy);

	    if (sticky) {
	      if (match) {
	        match.input = match.input.slice(charsAdded);
	        match[0] = match[0].slice(charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else re.lastIndex = 0;
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      nativeReplace.call(match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    return match;
	  };
	}

	var regexpExec = patchedExec;

	_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
	  exec: regexpExec
	});

	// TODO: Remove from `core-js@4` since it's moved to entry points







	var SPECIES$4 = wellKnownSymbol('species');

	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});

	// IE <= 11 replaces $0 with the whole match, as if it was $&
	// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
	var REPLACE_KEEPS_$0 = (function () {
	  return 'a'.replace(/./, '$0') === '$0';
	})();

	var REPLACE = wellKnownSymbol('replace');
	// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
	var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
	  if (/./[REPLACE]) {
	    return /./[REPLACE]('a', '$0') === '';
	  }
	  return false;
	})();

	// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	// Weex JS has frozen built-in prototypes, so use try / catch wrapper
	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
	});

	var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
	  var SYMBOL = wellKnownSymbol(KEY);

	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;

	    if (KEY === 'split') {
	      // We can't use real regex here since it causes deoptimization
	      // and serious performance degradation in V8
	      // https://github.com/zloirock/core-js/issues/306
	      re = {};
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES$4] = function () { return re; };
	      re.flags = '';
	      re[SYMBOL] = /./[SYMBOL];
	    }

	    re.exec = function () { execCalled = true; return null; };

	    re[SYMBOL]('');
	    return !execCalled;
	  });

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    (KEY === 'replace' && !(
	      REPLACE_SUPPORTS_NAMED_GROUPS &&
	      REPLACE_KEEPS_$0 &&
	      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    )) ||
	    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
	  ) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
	      if (regexp.exec === regexpExec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
	        }
	        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
	      }
	      return { done: false };
	    }, {
	      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
	      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    });
	    var stringMethod = methods[0];
	    var regexMethod = methods[1];

	    redefine(String.prototype, KEY, stringMethod);
	    redefine(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return regexMethod.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return regexMethod.call(string, this); }
	    );
	  }

	  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
	};

	var charAt = stringMultibyte.charAt;

	// `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	var advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? charAt(S, index).length : 1);
	};

	// `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }

	  if (classofRaw(R) !== 'RegExp') {
	    throw TypeError('RegExp#exec called on incompatible receiver');
	  }

	  return regexpExec.call(R, S);
	};

	// @@match logic
	fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = requireObjectCoercible(this);
	      var matcher = regexp == undefined ? undefined : regexp[MATCH];
	      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	    function (regexp) {
	      var res = maybeCallNative(nativeMatch, regexp, this);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);

	      if (!rx.global) return regexpExecAbstract(rx, S);

	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = regexpExecAbstract(rx, S)) !== null) {
	        var matchStr = String(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});

	var SPECIES$5 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$5]) == undefined ? defaultConstructor : aFunction$1(S);
	};

	var MATCH_ALL = wellKnownSymbol('matchAll');
	var REGEXP_STRING = 'RegExp String';
	var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
	var setInternalState$2 = internalState.set;
	var getInternalState$2 = internalState.getterFor(REGEXP_STRING_ITERATOR);
	var RegExpPrototype = RegExp.prototype;
	var regExpBuiltinExec = RegExpPrototype.exec;
	var nativeMatchAll = ''.matchAll;

	var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function () {
	  'a'.matchAll(/./);
	});

	var regExpExec = function (R, S) {
	  var exec = R.exec;
	  var result;
	  if (typeof exec == 'function') {
	    result = exec.call(R, S);
	    if (typeof result != 'object') throw TypeError('Incorrect exec result');
	    return result;
	  } return regExpBuiltinExec.call(R, S);
	};

	// eslint-disable-next-line max-len
	var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, global, fullUnicode) {
	  setInternalState$2(this, {
	    type: REGEXP_STRING_ITERATOR,
	    regexp: regexp,
	    string: string,
	    global: global,
	    unicode: fullUnicode,
	    done: false
	  });
	}, REGEXP_STRING, function next() {
	  var state = getInternalState$2(this);
	  if (state.done) return { value: undefined, done: true };
	  var R = state.regexp;
	  var S = state.string;
	  var match = regExpExec(R, S);
	  if (match === null) return { value: undefined, done: state.done = true };
	  if (state.global) {
	    if (String(match[0]) == '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
	    return { value: match, done: false };
	  }
	  state.done = true;
	  return { value: match, done: false };
	});

	var $matchAll = function (string) {
	  var R = anObject(this);
	  var S = String(string);
	  var C, flagsValue, flags, matcher, global, fullUnicode;
	  C = speciesConstructor(R, RegExp);
	  flagsValue = R.flags;
	  if (flagsValue === undefined && R instanceof RegExp && !('flags' in RegExpPrototype)) {
	    flagsValue = regexpFlags.call(R);
	  }
	  flags = flagsValue === undefined ? '' : String(flagsValue);
	  matcher = new C(C === RegExp ? R.source : R, flags);
	  global = !!~flags.indexOf('g');
	  fullUnicode = !!~flags.indexOf('u');
	  matcher.lastIndex = toLength(R.lastIndex);
	  return new $RegExpStringIterator(matcher, S, global, fullUnicode);
	};

	// `String.prototype.matchAll` method
	// https://github.com/tc39/proposal-string-matchall
	_export({ target: 'String', proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
	  matchAll: function matchAll(regexp) {
	    var O = requireObjectCoercible(this);
	    var flags, S, matcher, rx;
	    if (regexp != null) {
	      if (isRegexp(regexp)) {
	        flags = String(requireObjectCoercible('flags' in RegExpPrototype
	          ? regexp.flags
	          : regexpFlags.call(regexp)
	        ));
	        if (!~flags.indexOf('g')) throw TypeError('`.matchAll` does not allow non-global regexes');
	      }
	      if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
	      matcher = regexp[MATCH_ALL];
	      if (matcher === undefined && isPure && classofRaw(regexp) == 'RegExp') matcher = $matchAll;
	      if (matcher != null) return aFunction$1(matcher).call(regexp, O);
	    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
	    S = String(O);
	    rx = new RegExp(regexp, 'g');
	    return  rx[MATCH_ALL](S);
	  }
	});

	 MATCH_ALL in RegExpPrototype || createNonEnumerableProperty(RegExpPrototype, MATCH_ALL, $matchAll);

	// `String.prototype.repeat` method implementation
	// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
	var stringRepeat = ''.repeat || function repeat(count) {
	  var str = String(requireObjectCoercible(this));
	  var result = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
	  return result;
	};

	// https://github.com/tc39/proposal-string-pad-start-end




	var ceil$1 = Math.ceil;

	// `String.prototype.{ padStart, padEnd }` methods implementation
	var createMethod$5 = function (IS_END) {
	  return function ($this, maxLength, fillString) {
	    var S = String(requireObjectCoercible($this));
	    var stringLength = S.length;
	    var fillStr = fillString === undefined ? ' ' : String(fillString);
	    var intMaxLength = toLength(maxLength);
	    var fillLen, stringFiller;
	    if (intMaxLength <= stringLength || fillStr == '') return S;
	    fillLen = intMaxLength - stringLength;
	    stringFiller = stringRepeat.call(fillStr, ceil$1(fillLen / fillStr.length));
	    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	    return IS_END ? S + stringFiller : stringFiller + S;
	  };
	};

	var stringPad = {
	  // `String.prototype.padStart` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
	  start: createMethod$5(false),
	  // `String.prototype.padEnd` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.padend
	  end: createMethod$5(true)
	};

	// https://github.com/zloirock/core-js/issues/280


	// eslint-disable-next-line unicorn/no-unsafe-regex
	var stringPadWebkitBug = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(engineUserAgent);

	var $padEnd = stringPad.end;


	// `String.prototype.padEnd` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.padend
	_export({ target: 'String', proto: true, forced: stringPadWebkitBug }, {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $padStart = stringPad.start;


	// `String.prototype.padStart` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.padstart
	_export({ target: 'String', proto: true, forced: stringPadWebkitBug }, {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `String.prototype.repeat` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
	_export({ target: 'String', proto: true }, {
	  repeat: stringRepeat
	});

	var max$3 = Math.max;
	var min$6 = Math.min;
	var floor$1 = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// @@replace logic
	fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
	  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
	  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
	  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

	  return [
	    // `String.prototype.replace` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = requireObjectCoercible(this);
	      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
	      return replacer !== undefined
	        ? replacer.call(searchValue, O, replaceValue)
	        : nativeReplace.call(String(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	    function (regexp, replaceValue) {
	      if (
	        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
	        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
	      ) {
	        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
	        if (res.done) return res.value;
	      }

	      var rx = anObject(regexp);
	      var S = String(this);

	      var functionalReplace = typeof replaceValue === 'function';
	      if (!functionalReplace) replaceValue = String(replaceValue);

	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = regexpExecAbstract(rx, S);
	        if (result === null) break;

	        results.push(result);
	        if (!global) break;

	        var matchStr = String(result[0]);
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      }

	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];

	        var matched = String(result[0]);
	        var position = max$3(min$6(toInteger(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = [matched].concat(captures, position, S);
	          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	          var replacement = String(replaceValue.apply(undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + S.slice(nextSourcePosition);
	    }
	  ];

	  // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return nativeReplace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$': return '$';
	        case '&': return matched;
	        case '`': return str.slice(0, position);
	        case "'": return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default: // \d\d?
	          var n = +ch;
	          if (n === 0) return match;
	          if (n > m) {
	            var f = floor$1(n / 10);
	            if (f === 0) return match;
	            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	            return match;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});

	// @@search logic
	fixRegexpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = requireObjectCoercible(this);
	      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
	      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	    function (regexp) {
	      var res = maybeCallNative(nativeSearch, regexp, this);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);

	      var previousLastIndex = rx.lastIndex;
	      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	      var result = regexpExecAbstract(rx, S);
	      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	      return result === null ? -1 : result.index;
	    }
	  ];
	});

	var arrayPush = [].push;
	var min$7 = Math.min;
	var MAX_UINT32 = 0xFFFFFFFF;

	// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
	var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

	// @@split logic
	fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'.split(/(b)*/)[1] == 'c' ||
	    'test'.split(/(?:)/, -1).length != 4 ||
	    'ab'.split(/(?:ab)*/).length != 2 ||
	    '.'.split(/(.?)(.?)/).length != 4 ||
	    '.'.split(/()()/).length > 1 ||
	    ''.split(/.?/).length
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = String(requireObjectCoercible(this));
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (separator === undefined) return [string];
	      // If `separator` is not a regex, use native split
	      if (!isRegexp(separator)) {
	        return nativeSplit.call(string, separator, lim);
	      }
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy.lastIndex;
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
	          lastLength = match[0].length;
	          lastLastIndex = lastIndex;
	          if (output.length >= lim) break;
	        }
	        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string.length) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output.length > lim ? output.slice(0, lim) : output;
	    };
	  // Chakra, V8
	  } else if ('0'.split(undefined, 0).length) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
	    };
	  } else internalSplit = nativeSplit;

	  return [
	    // `String.prototype.split` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = requireObjectCoercible(this);
	      var splitter = separator == undefined ? undefined : separator[SPLIT];
	      return splitter !== undefined
	        ? splitter.call(separator, O, limit)
	        : internalSplit.call(String(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (regexp, limit) {
	      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);
	      var C = speciesConstructor(rx, RegExp);

	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                  (rx.multiline ? 'm' : '') +
	                  (rx.unicode ? 'u' : '') +
	                  (SUPPORTS_Y ? 'y' : 'g');

	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = SUPPORTS_Y ? q : 0;
	        var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
	        var e;
	        if (
	          z === null ||
	          (e = min$7(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
	        ) {
	          q = advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          A.push(S.slice(p, q));
	          if (A.length === lim) return A;
	          for (var i = 1; i <= z.length - 1; i++) {
	            A.push(z[i]);
	            if (A.length === lim) return A;
	          }
	          q = p = e;
	        }
	      }
	      A.push(S.slice(p));
	      return A;
	    }
	  ];
	}, !SUPPORTS_Y);

	var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;






	var nativeStartsWith = ''.startsWith;
	var min$8 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('startsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG$1 =  !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
	  var descriptor = getOwnPropertyDescriptor$5(String.prototype, 'startsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.startsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$8(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return nativeStartsWith
	      ? nativeStartsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	// a string of all valid unicode whitespaces
	// eslint-disable-next-line max-len
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$6 = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$6(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
	  end: createMethod$6(2),
	  // `String.prototype.trim` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
	  trim: createMethod$6(3)
	};

	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.trim
	_export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var $trimStart = stringTrim.start;


	var FORCED$4 = stringTrimForced('trimStart');

	var trimStart = FORCED$4 ? function trimStart() {
	  return $trimStart(this);
	} : ''.trimStart;

	// `String.prototype.{ trimStart, trimLeft }` methods
	// https://github.com/tc39/ecmascript-string-left-right-trim
	_export({ target: 'String', proto: true, forced: FORCED$4 }, {
	  trimStart: trimStart,
	  trimLeft: trimStart
	});

	var $trimEnd = stringTrim.end;


	var FORCED$5 = stringTrimForced('trimEnd');

	var trimEnd = FORCED$5 ? function trimEnd() {
	  return $trimEnd(this);
	} : ''.trimEnd;

	// `String.prototype.{ trimEnd, trimRight }` methods
	// https://github.com/tc39/ecmascript-string-left-right-trim
	_export({ target: 'String', proto: true, forced: FORCED$5 }, {
	  trimEnd: trimEnd,
	  trimRight: trimEnd
	});

	var charAt$1 = stringMultibyte.charAt;



	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$3 = internalState.set;
	var getInternalState$3 = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState$3(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState$3(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt$1(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	var quot = /"/g;

	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	// https://tc39.github.io/ecma262/#sec-createhtml
	var createHtml = function (string, tag, attribute, value) {
	  var S = String(requireObjectCoercible(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};

	// check the existence of a method, lowercase
	// of a tag and escaping quotes in arguments
	var stringHtmlForced = function (METHOD_NAME) {
	  return fails(function () {
	    var test = ''[METHOD_NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  });
	};

	// `String.prototype.anchor` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.anchor
	_export({ target: 'String', proto: true, forced: stringHtmlForced('anchor') }, {
	  anchor: function anchor(name) {
	    return createHtml(this, 'a', 'name', name);
	  }
	});

	// `String.prototype.big` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.big
	_export({ target: 'String', proto: true, forced: stringHtmlForced('big') }, {
	  big: function big() {
	    return createHtml(this, 'big', '', '');
	  }
	});

	// `String.prototype.blink` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.blink
	_export({ target: 'String', proto: true, forced: stringHtmlForced('blink') }, {
	  blink: function blink() {
	    return createHtml(this, 'blink', '', '');
	  }
	});

	// `String.prototype.bold` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.bold
	_export({ target: 'String', proto: true, forced: stringHtmlForced('bold') }, {
	  bold: function bold() {
	    return createHtml(this, 'b', '', '');
	  }
	});

	// `String.prototype.fixed` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fixed
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fixed') }, {
	  fixed: function fixed() {
	    return createHtml(this, 'tt', '', '');
	  }
	});

	// `String.prototype.fontcolor` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fontcolor
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fontcolor') }, {
	  fontcolor: function fontcolor(color) {
	    return createHtml(this, 'font', 'color', color);
	  }
	});

	// `String.prototype.fontsize` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fontsize
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fontsize') }, {
	  fontsize: function fontsize(size) {
	    return createHtml(this, 'font', 'size', size);
	  }
	});

	// `String.prototype.italics` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.italics
	_export({ target: 'String', proto: true, forced: stringHtmlForced('italics') }, {
	  italics: function italics() {
	    return createHtml(this, 'i', '', '');
	  }
	});

	// `String.prototype.link` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.link
	_export({ target: 'String', proto: true, forced: stringHtmlForced('link') }, {
	  link: function link(url) {
	    return createHtml(this, 'a', 'href', url);
	  }
	});

	// `String.prototype.small` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.small
	_export({ target: 'String', proto: true, forced: stringHtmlForced('small') }, {
	  small: function small() {
	    return createHtml(this, 'small', '', '');
	  }
	});

	// `String.prototype.strike` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.strike
	_export({ target: 'String', proto: true, forced: stringHtmlForced('strike') }, {
	  strike: function strike() {
	    return createHtml(this, 'strike', '', '');
	  }
	});

	// `String.prototype.sub` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.sub
	_export({ target: 'String', proto: true, forced: stringHtmlForced('sub') }, {
	  sub: function sub() {
	    return createHtml(this, 'sub', '', '');
	  }
	});

	// `String.prototype.sup` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.sup
	_export({ target: 'String', proto: true, forced: stringHtmlForced('sup') }, {
	  sup: function sup() {
	    return createHtml(this, 'sup', '', '');
	  }
	});

	// makes subclassing work correct for wrapped built-ins
	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if (
	    // it can work only with native `setPrototypeOf`
	    objectSetPrototypeOf &&
	    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	    typeof (NewTarget = dummy.constructor) == 'function' &&
	    NewTarget !== Wrapper &&
	    isObject(NewTargetPrototype = NewTarget.prototype) &&
	    NewTargetPrototype !== Wrapper.prototype
	  ) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	var defineProperty$6 = objectDefineProperty.f;
	var getOwnPropertyNames = objectGetOwnPropertyNames.f;





	var setInternalState$4 = internalState.set;



	var MATCH$2 = wellKnownSymbol('match');
	var NativeRegExp = global_1.RegExp;
	var RegExpPrototype$1 = NativeRegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;

	// "new" should create a new object, old webkit bug
	var CORRECT_NEW = new NativeRegExp(re1) !== re1;

	var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;

	var FORCED$6 = descriptors && isForced_1('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y$2 || fails(function () {
	  re2[MATCH$2] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
	})));

	// `RegExp` constructor
	// https://tc39.github.io/ecma262/#sec-regexp-constructor
	if (FORCED$6) {
	  var RegExpWrapper = function RegExp(pattern, flags) {
	    var thisIsRegExp = this instanceof RegExpWrapper;
	    var patternIsRegExp = isRegexp(pattern);
	    var flagsAreUndefined = flags === undefined;
	    var sticky;

	    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
	      return pattern;
	    }

	    if (CORRECT_NEW) {
	      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
	    } else if (pattern instanceof RegExpWrapper) {
	      if (flagsAreUndefined) flags = regexpFlags.call(pattern);
	      pattern = pattern.source;
	    }

	    if (UNSUPPORTED_Y$2) {
	      sticky = !!flags && flags.indexOf('y') > -1;
	      if (sticky) flags = flags.replace(/y/g, '');
	    }

	    var result = inheritIfRequired(
	      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
	      thisIsRegExp ? this : RegExpPrototype$1,
	      RegExpWrapper
	    );

	    if (UNSUPPORTED_Y$2 && sticky) setInternalState$4(result, { sticky: sticky });

	    return result;
	  };
	  var proxy = function (key) {
	    key in RegExpWrapper || defineProperty$6(RegExpWrapper, key, {
	      configurable: true,
	      get: function () { return NativeRegExp[key]; },
	      set: function (it) { NativeRegExp[key] = it; }
	    });
	  };
	  var keys$1 = getOwnPropertyNames(NativeRegExp);
	  var index = 0;
	  while (keys$1.length > index) proxy(keys$1[index++]);
	  RegExpPrototype$1.constructor = RegExpWrapper;
	  RegExpWrapper.prototype = RegExpPrototype$1;
	  redefine(global_1, 'RegExp', RegExpWrapper);
	}

	// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
	setSpecies('RegExp');

	var UNSUPPORTED_Y$3 = regexpStickyHelpers.UNSUPPORTED_Y;

	// `RegExp.prototype.flags` getter
	// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
	if (descriptors && (/./g.flags != 'g' || UNSUPPORTED_Y$3)) {
	  objectDefineProperty.f(RegExp.prototype, 'flags', {
	    configurable: true,
	    get: regexpFlags
	  });
	}

	var UNSUPPORTED_Y$4 = regexpStickyHelpers.UNSUPPORTED_Y;
	var defineProperty$7 = objectDefineProperty.f;
	var getInternalState$4 = internalState.get;
	var RegExpPrototype$2 = RegExp.prototype;

	// `RegExp.prototype.sticky` getter
	if (descriptors && UNSUPPORTED_Y$4) {
	  defineProperty$7(RegExp.prototype, 'sticky', {
	    configurable: true,
	    get: function () {
	      if (this === RegExpPrototype$2) return undefined;
	      // We can't use InternalStateModule.getterFor because
	      // we don't add metadata for regexps created by a literal.
	      if (this instanceof RegExp) {
	        return !!getInternalState$4(this).sticky;
	      }
	      throw TypeError('Incompatible receiver, RegExp required');
	    }
	  });
	}

	// TODO: Remove from `core-js@4` since it's moved to entry points




	var DELEGATES_TO_EXEC = function () {
	  var execCalled = false;
	  var re = /[ac]/;
	  re.exec = function () {
	    execCalled = true;
	    return /./.exec.apply(this, arguments);
	  };
	  return re.test('abc') === true && execCalled;
	}();

	var nativeTest = /./.test;

	_export({ target: 'RegExp', proto: true, forced: !DELEGATES_TO_EXEC }, {
	  test: function (str) {
	    if (typeof this.exec !== 'function') {
	      return nativeTest.call(this, str);
	    }
	    var result = this.exec(str);
	    if (result !== null && !isObject(result)) {
	      throw new Error('RegExp exec method returned something other than an Object or null');
	    }
	    return !!result;
	  }
	});

	var TO_STRING = 'toString';
	var RegExpPrototype$3 = RegExp.prototype;
	var nativeToString = RegExpPrototype$3[TO_STRING];

	var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
	// FF44- RegExp#toString has a wrong name
	var INCORRECT_NAME = nativeToString.name != TO_STRING;

	// `RegExp.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
	if (NOT_GENERIC || INCORRECT_NAME) {
	  redefine(RegExp.prototype, TO_STRING, function toString() {
	    var R = anObject(this);
	    var p = String(R.source);
	    var rf = R.flags;
	    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype$3) ? regexpFlags.call(R) : rf);
	    return '/' + p + '/' + f;
	  }, { unsafe: true });
	}

	var trim = stringTrim.trim;


	var $parseInt = global_1.parseInt;
	var hex = /^[+-]?0[Xx]/;
	var FORCED$7 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

	// `parseInt` method
	// https://tc39.github.io/ecma262/#sec-parseint-string-radix
	var numberParseInt = FORCED$7 ? function parseInt(string, radix) {
	  var S = trim(String(string));
	  return $parseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
	} : $parseInt;

	// `parseInt` method
	// https://tc39.github.io/ecma262/#sec-parseint-string-radix
	_export({ global: true, forced: parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	var trim$1 = stringTrim.trim;


	var $parseFloat = global_1.parseFloat;
	var FORCED$8 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity;

	// `parseFloat` method
	// https://tc39.github.io/ecma262/#sec-parsefloat-string
	var numberParseFloat = FORCED$8 ? function parseFloat(string) {
	  var trimmedString = trim$1(String(string));
	  var result = $parseFloat(trimmedString);
	  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// `parseFloat` method
	// https://tc39.github.io/ecma262/#sec-parsefloat-string
	_export({ global: true, forced: parseFloat != numberParseFloat }, {
	  parseFloat: numberParseFloat
	});

	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
	var getOwnPropertyDescriptor$6 = objectGetOwnPropertyDescriptor.f;
	var defineProperty$8 = objectDefineProperty.f;
	var trim$2 = stringTrim.trim;

	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype;

	// Opera ~12 has broken Object#toString
	var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;

	// `ToNumber` abstract operation
	// https://tc39.github.io/ecma262/#sec-tonumber
	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  var first, third, radix, maxCode, digits, length, index, code;
	  if (typeof it == 'string' && it.length > 2) {
	    it = trim$2(it);
	    first = it.charCodeAt(0);
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
	        default: return +it;
	      }
	      digits = it.slice(2);
	      length = digits.length;
	      for (index = 0; index < length; index++) {
	        code = digits.charCodeAt(index);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	// `Number` constructor
	// https://tc39.github.io/ecma262/#sec-number-constructor
	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var dummy = this;
	    return dummy instanceof NumberWrapper
	      // check on 1..constructor(foo) case
	      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
	        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
	  };
	  for (var keys$2 = descriptors ? getOwnPropertyNames$1(NativeNumber) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES2015 (in case, if modules with ES2015 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys$2.length > j; j++) {
	    if (has(NativeNumber, key = keys$2[j]) && !has(NumberWrapper, key)) {
	      defineProperty$8(NumberWrapper, key, getOwnPropertyDescriptor$6(NativeNumber, key));
	    }
	  }
	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	// `Number.EPSILON` constant
	// https://tc39.github.io/ecma262/#sec-number.epsilon
	_export({ target: 'Number', stat: true }, {
	  EPSILON: Math.pow(2, -52)
	});

	var globalIsFinite = global_1.isFinite;

	// `Number.isFinite` method
	// https://tc39.github.io/ecma262/#sec-number.isfinite
	var numberIsFinite = Number.isFinite || function isFinite(it) {
	  return typeof it == 'number' && globalIsFinite(it);
	};

	// `Number.isFinite` method
	// https://tc39.github.io/ecma262/#sec-number.isfinite
	_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });

	var floor$2 = Math.floor;

	// `Number.isInteger` method implementation
	// https://tc39.github.io/ecma262/#sec-number.isinteger
	var isInteger = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor$2(it) === it;
	};

	// `Number.isInteger` method
	// https://tc39.github.io/ecma262/#sec-number.isinteger
	_export({ target: 'Number', stat: true }, {
	  isInteger: isInteger
	});

	// `Number.isNaN` method
	// https://tc39.github.io/ecma262/#sec-number.isnan
	_export({ target: 'Number', stat: true }, {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	var abs = Math.abs;

	// `Number.isSafeInteger` method
	// https://tc39.github.io/ecma262/#sec-number.issafeinteger
	_export({ target: 'Number', stat: true }, {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1FFFFFFFFFFFFF;
	  }
	});

	// `Number.MAX_SAFE_INTEGER` constant
	// https://tc39.github.io/ecma262/#sec-number.max_safe_integer
	_export({ target: 'Number', stat: true }, {
	  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
	});

	// `Number.MIN_SAFE_INTEGER` constant
	// https://tc39.github.io/ecma262/#sec-number.min_safe_integer
	_export({ target: 'Number', stat: true }, {
	  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
	});

	// `Number.parseFloat` method
	// https://tc39.github.io/ecma262/#sec-number.parseFloat
	_export({ target: 'Number', stat: true, forced: Number.parseFloat != numberParseFloat }, {
	  parseFloat: numberParseFloat
	});

	// `Number.parseInt` method
	// https://tc39.github.io/ecma262/#sec-number.parseint
	_export({ target: 'Number', stat: true, forced: Number.parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	// `thisNumberValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-thisnumbervalue
	var thisNumberValue = function (value) {
	  if (typeof value != 'number' && classofRaw(value) != 'Number') {
	    throw TypeError('Incorrect invocation');
	  }
	  return +value;
	};

	var nativeToFixed = 1.0.toFixed;
	var floor$3 = Math.floor;

	var pow = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};

	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	var FORCED$9 = nativeToFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !fails(function () {
	  // V8 ~ Android 4.3-
	  nativeToFixed.call({});
	});

	// `Number.prototype.toFixed` method
	// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
	_export({ target: 'Number', proto: true, forced: FORCED$9 }, {
	  // eslint-disable-next-line max-statements
	  toFixed: function toFixed(fractionDigits) {
	    var number = thisNumberValue(this);
	    var fractDigits = toInteger(fractionDigits);
	    var data = [0, 0, 0, 0, 0, 0];
	    var sign = '';
	    var result = '0';
	    var e, z, j, k;

	    var multiply = function (n, c) {
	      var index = -1;
	      var c2 = c;
	      while (++index < 6) {
	        c2 += n * data[index];
	        data[index] = c2 % 1e7;
	        c2 = floor$3(c2 / 1e7);
	      }
	    };

	    var divide = function (n) {
	      var index = 6;
	      var c = 0;
	      while (--index >= 0) {
	        c += data[index];
	        data[index] = floor$3(c / n);
	        c = (c % n) * 1e7;
	      }
	    };

	    var dataToString = function () {
	      var index = 6;
	      var s = '';
	      while (--index >= 0) {
	        if (s !== '' || index === 0 || data[index] !== 0) {
	          var t = String(data[index]);
	          s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
	        }
	      } return s;
	    };

	    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
	    // eslint-disable-next-line no-self-compare
	    if (number != number) return 'NaN';
	    if (number <= -1e21 || number >= 1e21) return String(number);
	    if (number < 0) {
	      sign = '-';
	      number = -number;
	    }
	    if (number > 1e-21) {
	      e = log(number * pow(2, 69, 1)) - 69;
	      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = fractDigits;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        result = dataToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        result = dataToString() + stringRepeat.call('0', fractDigits);
	      }
	    }
	    if (fractDigits > 0) {
	      k = result.length;
	      result = sign + (k <= fractDigits
	        ? '0.' + stringRepeat.call('0', fractDigits - k) + result
	        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
	    } else {
	      result = sign + result;
	    } return result;
	  }
	});

	var nativeToPrecision = 1.0.toPrecision;

	var FORCED$a = fails(function () {
	  // IE7-
	  return nativeToPrecision.call(1, undefined) !== '1';
	}) || !fails(function () {
	  // V8 ~ Android 4.3-
	  nativeToPrecision.call({});
	});

	// `Number.prototype.toPrecision` method
	// https://tc39.github.io/ecma262/#sec-number.prototype.toprecision
	_export({ target: 'Number', proto: true, forced: FORCED$a }, {
	  toPrecision: function toPrecision(precision) {
	    return precision === undefined
	      ? nativeToPrecision.call(thisNumberValue(this))
	      : nativeToPrecision.call(thisNumberValue(this), precision);
	  }
	});

	var log$1 = Math.log;

	// `Math.log1p` method implementation
	// https://tc39.github.io/ecma262/#sec-math.log1p
	var mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log$1(1 + x);
	};

	var nativeAcosh = Math.acosh;
	var log$2 = Math.log;
	var sqrt = Math.sqrt;
	var LN2 = Math.LN2;

	var FORCED$b = !nativeAcosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  || Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  || nativeAcosh(Infinity) != Infinity;

	// `Math.acosh` method
	// https://tc39.github.io/ecma262/#sec-math.acosh
	_export({ target: 'Math', stat: true, forced: FORCED$b }, {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? log$2(x) + LN2
	      : mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

	var nativeAsinh = Math.asinh;
	var log$3 = Math.log;
	var sqrt$1 = Math.sqrt;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log$3(x + sqrt$1(x * x + 1));
	}

	// `Math.asinh` method
	// https://tc39.github.io/ecma262/#sec-math.asinh
	// Tor Browser bug: Math.asinh(0) -> -0
	_export({ target: 'Math', stat: true, forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0) }, {
	  asinh: asinh
	});

	var nativeAtanh = Math.atanh;
	var log$4 = Math.log;

	// `Math.atanh` method
	// https://tc39.github.io/ecma262/#sec-math.atanh
	// Tor Browser bug: Math.atanh(-0) -> 0
	_export({ target: 'Math', stat: true, forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0) }, {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : log$4((1 + x) / (1 - x)) / 2;
	  }
	});

	// `Math.sign` method implementation
	// https://tc39.github.io/ecma262/#sec-math.sign
	var mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	var abs$1 = Math.abs;
	var pow$1 = Math.pow;

	// `Math.cbrt` method
	// https://tc39.github.io/ecma262/#sec-math.cbrt
	_export({ target: 'Math', stat: true }, {
	  cbrt: function cbrt(x) {
	    return mathSign(x = +x) * pow$1(abs$1(x), 1 / 3);
	  }
	});

	var floor$4 = Math.floor;
	var log$5 = Math.log;
	var LOG2E = Math.LOG2E;

	// `Math.clz32` method
	// https://tc39.github.io/ecma262/#sec-math.clz32
	_export({ target: 'Math', stat: true }, {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - floor$4(log$5(x + 0.5) * LOG2E) : 32;
	  }
	});

	var nativeExpm1 = Math.expm1;
	var exp = Math.exp;

	// `Math.expm1` method implementation
	// https://tc39.github.io/ecma262/#sec-math.expm1
	var mathExpm1 = (!nativeExpm1
	  // Old FF bug
	  || nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || nativeExpm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
	} : nativeExpm1;

	var nativeCosh = Math.cosh;
	var abs$2 = Math.abs;
	var E = Math.E;

	// `Math.cosh` method
	// https://tc39.github.io/ecma262/#sec-math.cosh
	_export({ target: 'Math', stat: true, forced: !nativeCosh || nativeCosh(710) === Infinity }, {
	  cosh: function cosh(x) {
	    var t = mathExpm1(abs$2(x) - 1) + 1;
	    return (t + 1 / (t * E * E)) * (E / 2);
	  }
	});

	// `Math.expm1` method
	// https://tc39.github.io/ecma262/#sec-math.expm1
	_export({ target: 'Math', stat: true, forced: mathExpm1 != Math.expm1 }, { expm1: mathExpm1 });

	var abs$3 = Math.abs;
	var pow$2 = Math.pow;
	var EPSILON = pow$2(2, -52);
	var EPSILON32 = pow$2(2, -23);
	var MAX32 = pow$2(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$2(2, -126);

	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	// `Math.fround` method implementation
	// https://tc39.github.io/ecma262/#sec-math.fround
	var mathFround = Math.fround || function fround(x) {
	  var $abs = abs$3(x);
	  var $sign = mathSign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	// `Math.fround` method
	// https://tc39.github.io/ecma262/#sec-math.fround
	_export({ target: 'Math', stat: true }, { fround: mathFround });

	var $hypot = Math.hypot;
	var abs$4 = Math.abs;
	var sqrt$2 = Math.sqrt;

	// Chrome 77 bug
	// https://bugs.chromium.org/p/v8/issues/detail?id=9546
	var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;

	// `Math.hypot` method
	// https://tc39.github.io/ecma262/#sec-math.hypot
	_export({ target: 'Math', stat: true, forced: BUGGY }, {
	  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs$4(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * sqrt$2(sum);
	  }
	});

	var nativeImul = Math.imul;

	var FORCED$c = fails(function () {
	  return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
	});

	// `Math.imul` method
	// https://tc39.github.io/ecma262/#sec-math.imul
	// some WebKit versions fails with big numbers, some has wrong arity
	_export({ target: 'Math', stat: true, forced: FORCED$c }, {
	  imul: function imul(x, y) {
	    var UINT16 = 0xFFFF;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	var log$6 = Math.log;
	var LOG10E = Math.LOG10E;

	// `Math.log10` method
	// https://tc39.github.io/ecma262/#sec-math.log10
	_export({ target: 'Math', stat: true }, {
	  log10: function log10(x) {
	    return log$6(x) * LOG10E;
	  }
	});

	// `Math.log1p` method
	// https://tc39.github.io/ecma262/#sec-math.log1p
	_export({ target: 'Math', stat: true }, { log1p: mathLog1p });

	var log$7 = Math.log;
	var LN2$1 = Math.LN2;

	// `Math.log2` method
	// https://tc39.github.io/ecma262/#sec-math.log2
	_export({ target: 'Math', stat: true }, {
	  log2: function log2(x) {
	    return log$7(x) / LN2$1;
	  }
	});

	// `Math.sign` method
	// https://tc39.github.io/ecma262/#sec-math.sign
	_export({ target: 'Math', stat: true }, {
	  sign: mathSign
	});

	var abs$5 = Math.abs;
	var exp$1 = Math.exp;
	var E$1 = Math.E;

	var FORCED$d = fails(function () {
	  return Math.sinh(-2e-17) != -2e-17;
	});

	// `Math.sinh` method
	// https://tc39.github.io/ecma262/#sec-math.sinh
	// V8 near Chromium 38 has a problem with very small numbers
	_export({ target: 'Math', stat: true, forced: FORCED$d }, {
	  sinh: function sinh(x) {
	    return abs$5(x = +x) < 1 ? (mathExpm1(x) - mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (E$1 / 2);
	  }
	});

	var exp$2 = Math.exp;

	// `Math.tanh` method
	// https://tc39.github.io/ecma262/#sec-math.tanh
	_export({ target: 'Math', stat: true }, {
	  tanh: function tanh(x) {
	    var a = mathExpm1(x = +x);
	    var b = mathExpm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
	  }
	});

	// Math[@@toStringTag] property
	// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
	setToStringTag(Math, 'Math', true);

	var ceil$2 = Math.ceil;
	var floor$5 = Math.floor;

	// `Math.trunc` method
	// https://tc39.github.io/ecma262/#sec-math.trunc
	_export({ target: 'Math', stat: true }, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$5 : ceil$2)(it);
	  }
	});

	// `Date.now` method
	// https://tc39.github.io/ecma262/#sec-date.now
	_export({ target: 'Date', stat: true }, {
	  now: function now() {
	    return new Date().getTime();
	  }
	});

	var FORCED$e = fails(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	});

	// `Date.prototype.toJSON` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.tojson
	_export({ target: 'Date', proto: true, forced: FORCED$e }, {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	var padStart = stringPad.start;

	var abs$6 = Math.abs;
	var DatePrototype = Date.prototype;
	var getTime = DatePrototype.getTime;
	var nativeDateToISOString = DatePrototype.toISOString;

	// `Date.prototype.toISOString` method implementation
	// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit fails here:
	var dateToIsoString = (fails(function () {
	  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  nativeDateToISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var date = this;
	  var year = date.getUTCFullYear();
	  var milliseconds = date.getUTCMilliseconds();
	  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
	  return sign + padStart(abs$6(year), sign ? 6 : 4, 0) +
	    '-' + padStart(date.getUTCMonth() + 1, 2, 0) +
	    '-' + padStart(date.getUTCDate(), 2, 0) +
	    'T' + padStart(date.getUTCHours(), 2, 0) +
	    ':' + padStart(date.getUTCMinutes(), 2, 0) +
	    ':' + padStart(date.getUTCSeconds(), 2, 0) +
	    '.' + padStart(milliseconds, 3, 0) +
	    'Z';
	} : nativeDateToISOString;

	// `Date.prototype.toISOString` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit has a broken implementations
	_export({ target: 'Date', proto: true, forced: Date.prototype.toISOString !== dateToIsoString }, {
	  toISOString: dateToIsoString
	});

	var DatePrototype$1 = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING$1 = 'toString';
	var nativeDateToString = DatePrototype$1[TO_STRING$1];
	var getTime$1 = DatePrototype$1.getTime;

	// `Date.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.tostring
	if (new Date(NaN) + '' != INVALID_DATE) {
	  redefine(DatePrototype$1, TO_STRING$1, function toString() {
	    var value = getTime$1.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
	  });
	}

	var dateToPrimitive = function (hint) {
	  if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
	    throw TypeError('Incorrect hint');
	  } return toPrimitive(anObject(this), hint !== 'number');
	};

	var TO_PRIMITIVE$1 = wellKnownSymbol('toPrimitive');
	var DatePrototype$2 = Date.prototype;

	// `Date.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-date.prototype-@@toprimitive
	if (!(TO_PRIMITIVE$1 in DatePrototype$2)) {
	  createNonEnumerableProperty(DatePrototype$2, TO_PRIMITIVE$1, dateToPrimitive);
	}

	var $stringify$1 = getBuiltIn('JSON', 'stringify');
	var re = /[\uD800-\uDFFF]/g;
	var low = /^[\uD800-\uDBFF]$/;
	var hi = /^[\uDC00-\uDFFF]$/;

	var fix = function (match, offset, string) {
	  var prev = string.charAt(offset - 1);
	  var next = string.charAt(offset + 1);
	  if ((low.test(match) && !hi.test(next)) || (hi.test(match) && !low.test(prev))) {
	    return '\\u' + match.charCodeAt(0).toString(16);
	  } return match;
	};

	var FORCED$f = fails(function () {
	  return $stringify$1('\uDF06\uD834') !== '"\\udf06\\ud834"'
	    || $stringify$1('\uDEAD') !== '"\\udead"';
	});

	if ($stringify$1) {
	  // https://github.com/tc39/proposal-well-formed-stringify
	  _export({ target: 'JSON', stat: true, forced: FORCED$f }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var result = $stringify$1.apply(null, arguments);
	      return typeof result == 'string' ? result.replace(re, fix) : result;
	    }
	  });
	}

	// JSON[@@toStringTag] property
	// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
	setToStringTag(global_1.JSON, 'JSON', true);

	var nativePromiseConstructor = global_1.Promise;

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);
	  return target;
	};

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  } return it;
	};

	var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

	var location$1 = global_1.location;
	var set$1 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$1 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch = global_1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run = function (id) {
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location$1.protocol + '//' + location$1.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$1 || !clear) {
	  set$1 = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (classofRaw(process$1) == 'process') {
	    defer = function (id) {
	      process$1.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global_1.addEventListener &&
	    typeof postMessage == 'function' &&
	    !global_1.importScripts &&
	    !fails(post) &&
	    location$1.protocol !== 'file:'
	  ) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task = {
	  set: set$1,
	  clear: clear
	};

	var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;

	var macrotask = task.set;


	var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var process$2 = global_1.process;
	var Promise$1 = global_1.Promise;
	var IS_NODE = classofRaw(process$2) == 'process';
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$7(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush, head, last, notify, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (IS_NODE && (parent = process$2.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (IS_NODE) {
	    notify = function () {
	      process$2.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  } else if (MutationObserver$1 && !engineIsIos) {
	    toggle = true;
	    node = document.createTextNode('');
	    new MutationObserver$1(flush).observe(node, { characterData: true });
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$1.resolve(undefined);
	    then = promise.then;
	    notify = function () {
	      then.call(promise, flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify();
	  } last = task;
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction$1(resolve);
	  this.reject = aFunction$1(reject);
	};

	// 25.4.1.5 NewPromiseCapability(C)
	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability = {
		f: f$7
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var task$1 = task.set;










	var SPECIES$6 = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$5 = internalState.get;
	var setInternalState$5 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var PromiseConstructor = nativePromiseConstructor;
	var TypeError$1 = global_1.TypeError;
	var document$2 = global_1.document;
	var process$3 = global_1.process;
	var $fetch = getBuiltIn('fetch');
	var newPromiseCapability$1 = newPromiseCapability.f;
	var newGenericPromiseCapability = newPromiseCapability$1;
	var IS_NODE$1 = classofRaw(process$3) == 'process';
	var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

	var FORCED$g = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE) {
	    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // We can't detect it synchronously, so just check versions
	    if (engineV8Version === 66) return true;
	    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
	  }
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = PromiseConstructor.resolve(1);
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$6] = FakePromise;
	  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
	});

	var INCORRECT_ITERATION$1 = FORCED$g || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
	});

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify$1 = function (promise, state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
	            state.rejection = HANDLED;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (error) {
	        if (domain && !exited) domain.exit();
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(promise, state);
	  });
	};

	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$2.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (handler = global_1['on' + name]) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (IS_NODE$1) {
	          process$3.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (promise, state) {
	  task$1.call(global_1, function () {
	    if (IS_NODE$1) {
	      process$3.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind = function (fn, promise, state, unwrap) {
	  return function (value) {
	    fn(promise, state, value, unwrap);
	  };
	};

	var internalReject = function (promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify$1(promise, state, true);
	};

	var internalResolve = function (promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          then.call(value,
	            bind(internalResolve, promise, wrapper, state),
	            bind(internalReject, promise, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(promise, wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify$1(promise, state, false);
	    }
	  } catch (error) {
	    internalReject(promise, { done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED$g) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction$1(executor);
	    Internal.call(this);
	    var state = getInternalState$5(this);
	    try {
	      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
	    } catch (error) {
	      internalReject(this, state, error);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    setInternalState$5(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = IS_NODE$1 ? process$3.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) notify$1(this, state, false);
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState$5(promise);
	    this.promise = promise;
	    this.resolve = bind(internalResolve, promise, state);
	    this.reject = bind(internalReject, promise, state);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };

	  if ( typeof nativePromiseConstructor == 'function') {
	    nativeThen = nativePromiseConstructor.prototype.then;

	    // wrap native Promise#then for native async functions
	    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
	      var that = this;
	      return new PromiseConstructor(function (resolve, reject) {
	        nativeThen.call(that, resolve, reject);
	      }).then(onFulfilled, onRejected);
	    // https://github.com/zloirock/core-js/issues/640
	    }, { unsafe: true });

	    // wrap fetch result
	    if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
	      // eslint-disable-next-line no-unused-vars
	      fetch: function fetch(input /* , init */) {
	        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
	      }
	    });
	  }
	}

	_export({ global: true, wrap: true, forced: FORCED$g }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false);
	setSpecies(PROMISE);

	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({ target: PROMISE, stat: true, forced: FORCED$g }, {
	  // `Promise.reject` method
	  // https://tc39.github.io/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});

	_export({ target: PROMISE, stat: true, forced:  FORCED$g }, {
	  // `Promise.resolve` method
	  // https://tc39.github.io/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve( this, x);
	  }
	});

	_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION$1 }, {
	  // `Promise.all` method
	  // https://tc39.github.io/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.github.io/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      iterate_1(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// `Promise.allSettled` method
	// https://github.com/tc39/proposal-promise-allSettled
	_export({ target: 'Promise', stat: true }, {
	  allSettled: function allSettled(iterable) {
	    var C = this;
	    var capability = newPromiseCapability.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'fulfilled', value: value };
	          --remaining || resolve(values);
	        }, function (e) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'rejected', reason: e };
	          --remaining || resolve(values);
	        });
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
	var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
	  nativePromiseConstructor.prototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
	});

	// `Promise.prototype.finally` method
	// https://tc39.github.io/ecma262/#sec-promise.prototype.finally
	_export({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
	  'finally': function (onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = typeof onFinally == 'function';
	    return this.then(
	      isFunction ? function (x) {
	        return promiseResolve(C, onFinally()).then(function () { return x; });
	      } : onFinally,
	      isFunction ? function (e) {
	        return promiseResolve(C, onFinally()).then(function () { throw e; });
	      } : onFinally
	    );
	  }
	});

	// patch native Promise.prototype for native async functions
	if ( typeof nativePromiseConstructor == 'function' && !nativePromiseConstructor.prototype['finally']) {
	  redefine(nativePromiseConstructor.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
	}

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var Constructor = NativeConstructor;
	  var exported = {};

	  var fixMethod = function (KEY) {
	    var nativeMethod = NativePrototype[KEY];
	    redefine(NativePrototype, KEY,
	      KEY == 'add' ? function add(value) {
	        nativeMethod.call(this, value === 0 ? 0 : value);
	        return this;
	      } : KEY == 'delete' ? function (key) {
	        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : KEY == 'get' ? function get(key) {
	        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : KEY == 'has' ? function has(key) {
	        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : function set(key, value) {
	        nativeMethod.call(this, key === 0 ? 0 : key, value);
	        return this;
	      }
	    );
	  };

	  // eslint-disable-next-line max-len
	  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
	    new NativeConstructor().entries().next();
	  })))) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.REQUIRED = true;
	  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
	    var instance = new Constructor();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    // eslint-disable-next-line no-new
	    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new NativeConstructor();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });

	    if (!ACCEPT_ITERABLES) {
	      Constructor = wrapper(function (dummy, iterable) {
	        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
	        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
	        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	        return that;
	      });
	      Constructor.prototype = NativePrototype;
	      NativePrototype.constructor = Constructor;
	    }

	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }

	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

	    // weak collections should not contains .clear method
	    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
	  }

	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({ global: true, forced: Constructor != NativeConstructor }, exported);

	  setToStringTag(Constructor, CONSTRUCTOR_NAME);

	  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

	  return Constructor;
	};

	var defineProperty$9 = objectDefineProperty.f;








	var fastKey = internalMetadata.fastKey;


	var setInternalState$6 = internalState.set;
	var internalStateGetterFor = internalState.getterFor;

	var collectionStrong = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$6(that, {
	        type: CONSTRUCTOR_NAME,
	        index: objectCreate(null),
	        first: undefined,
	        last: undefined,
	        size: 0
	      });
	      if (!descriptors) that.size = 0;
	      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	    });

	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var entry = getEntry(that, key);
	      var previous, index;
	      // change existing entry
	      if (entry) {
	        entry.value = value;
	      // create new entry
	      } else {
	        state.last = entry = {
	          index: index = fastKey(key, true),
	          key: key,
	          value: value,
	          previous: previous = state.last,
	          next: undefined,
	          removed: false
	        };
	        if (!state.first) state.first = entry;
	        if (previous) previous.next = entry;
	        if (descriptors) state.size++;
	        else that.size++;
	        // add to index
	        if (index !== 'F') state.index[index] = entry;
	      } return that;
	    };

	    var getEntry = function (that, key) {
	      var state = getInternalState(that);
	      // fast case
	      var index = fastKey(key);
	      var entry;
	      if (index !== 'F') return state.index[index];
	      // frozen object case
	      for (entry = state.first; entry; entry = entry.next) {
	        if (entry.key == key) return entry;
	      }
	    };

	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        var that = this;
	        var state = getInternalState(that);
	        var data = state.index;
	        var entry = state.first;
	        while (entry) {
	          entry.removed = true;
	          if (entry.previous) entry.previous = entry.previous.next = undefined;
	          delete data[entry.index];
	          entry = entry.next;
	        }
	        state.first = state.last = undefined;
	        if (descriptors) state.size = 0;
	        else that.size = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = this;
	        var state = getInternalState(that);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.next;
	          var prev = entry.previous;
	          delete state.index[entry.index];
	          entry.removed = true;
	          if (prev) prev.next = next;
	          if (next) next.previous = prev;
	          if (state.first == entry) state.first = next;
	          if (state.last == entry) state.last = prev;
	          if (descriptors) state.size--;
	          else that.size--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        var state = getInternalState(this);
	        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.next : state.first) {
	          boundFunction(entry.value, entry.key, this);
	          // revert to the last existing entry
	          while (entry && entry.removed) entry = entry.previous;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });

	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.1.3.6 Map.prototype.get(key)
	      get: function get(key) {
	        var entry = getEntry(this, key);
	        return entry && entry.value;
	      },
	      // 23.1.3.9 Map.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key === 0 ? 0 : key, value);
	      }
	    } : {
	      // 23.2.3.1 Set.prototype.add(value)
	      add: function add(value) {
	        return define(this, value = value === 0 ? 0 : value, value);
	      }
	    });
	    if (descriptors) defineProperty$9(C.prototype, 'size', {
	      get: function () {
	        return getInternalState(this).size;
	      }
	    });
	    return C;
	  },
	  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
	    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
	    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
	    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
	      setInternalState$6(this, {
	        type: ITERATOR_NAME,
	        target: iterated,
	        state: getInternalCollectionState(iterated),
	        kind: kind,
	        last: undefined
	      });
	    }, function () {
	      var state = getInternalIteratorState(this);
	      var kind = state.kind;
	      var entry = state.last;
	      // revert to the last existing entry
	      while (entry && entry.removed) entry = entry.previous;
	      // get next entry
	      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
	        // or finish the iteration
	        state.target = undefined;
	        return { value: undefined, done: true };
	      }
	      // return step by kind
	      if (kind == 'keys') return { value: entry.key, done: false };
	      if (kind == 'values') return { value: entry.value, done: false };
	      return { value: [entry.key, entry.value], done: false };
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(CONSTRUCTOR_NAME);
	  }
	};

	// `Map` constructor
	// https://tc39.github.io/ecma262/#sec-map-objects
	var es_map = collection('Map', function (init) {
	  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	// `Set` constructor
	// https://tc39.github.io/ecma262/#sec-set-objects
	var es_set = collection('Set', function (init) {
	  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	var getWeakData = internalMetadata.getWeakData;








	var setInternalState$7 = internalState.set;
	var internalStateGetterFor$1 = internalState.getterFor;
	var find = arrayIteration.find;
	var findIndex = arrayIteration.findIndex;
	var id$1 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (store) {
	  return store.frozen || (store.frozen = new UncaughtFrozenStore());
	};

	var UncaughtFrozenStore = function () {
	  this.entries = [];
	};

	var findUncaughtFrozen = function (store, key) {
	  return find(store.entries, function (it) {
	    return it[0] === key;
	  });
	};

	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.entries.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = findIndex(this.entries, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.entries.splice(index, 1);
	    return !!~index;
	  }
	};

	var collectionWeak = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$7(that, {
	        type: CONSTRUCTOR_NAME,
	        id: id$1++,
	        frozen: undefined
	      });
	      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	    });

	    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var data = getWeakData(anObject(key), true);
	      if (data === true) uncaughtFrozenStore(state).set(key, value);
	      else data[state.id] = value;
	      return that;
	    };

	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        var state = getInternalState(this);
	        if (!isObject(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
	        return data && has(data, state.id) && delete data[state.id];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has$1(key) {
	        var state = getInternalState(this);
	        if (!isObject(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state).has(key);
	        return data && has(data, state.id);
	      }
	    });

	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.3.3.3 WeakMap.prototype.get(key)
	      get: function get(key) {
	        var state = getInternalState(this);
	        if (isObject(key)) {
	          var data = getWeakData(key);
	          if (data === true) return uncaughtFrozenStore(state).get(key);
	          return data ? data[state.id] : undefined;
	        }
	      },
	      // 23.3.3.5 WeakMap.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key, value);
	      }
	    } : {
	      // 23.4.3.1 WeakSet.prototype.add(value)
	      add: function add(value) {
	        return define(this, value, true);
	      }
	    });

	    return C;
	  }
	};

	var es_weakMap = createCommonjsModule(function (module) {






	var enforceIternalState = internalState.enforce;


	var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;
	var isExtensible = Object.isExtensible;
	var InternalWeakMap;

	var wrapper = function (init) {
	  return function WeakMap() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	};

	// `WeakMap` constructor
	// https://tc39.github.io/ecma262/#sec-weakmap-constructor
	var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);

	// IE11 WeakMap frozen keys fix
	// We can't use feature detection because it crash some old IE builds
	// https://github.com/zloirock/core-js/issues/485
	if (nativeWeakMap && IS_IE11) {
	  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
	  internalMetadata.REQUIRED = true;
	  var WeakMapPrototype = $WeakMap.prototype;
	  var nativeDelete = WeakMapPrototype['delete'];
	  var nativeHas = WeakMapPrototype.has;
	  var nativeGet = WeakMapPrototype.get;
	  var nativeSet = WeakMapPrototype.set;
	  redefineAll(WeakMapPrototype, {
	    'delete': function (key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeDelete.call(this, key) || state.frozen['delete'](key);
	      } return nativeDelete.call(this, key);
	    },
	    has: function has(key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas.call(this, key) || state.frozen.has(key);
	      } return nativeHas.call(this, key);
	    },
	    get: function get(key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
	      } return nativeGet.call(this, key);
	    },
	    set: function set(key, value) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
	      } else nativeSet.call(this, key, value);
	      return this;
	    }
	  });
	}
	});

	// `WeakSet` constructor
	// https://tc39.github.io/ecma262/#sec-weakset-constructor
	collection('WeakSet', function (init) {
	  return function WeakSet() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionWeak);

	var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

	// `ToIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-toindex
	var toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length or index');
	  return length;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity$1 = 1 / 0;
	var abs$7 = Math.abs;
	var pow$3 = Math.pow;
	var floor$6 = Math.floor;
	var log$8 = Math.log;
	var LN2$2 = Math.LN2;

	var pack = function (number, mantissaLength, bytes) {
	  var buffer = new Array(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow$3(2, -24) - pow$3(2, -77) : 0;
	  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs$7(number);
	  // eslint-disable-next-line no-self-compare
	  if (number != number || number === Infinity$1) {
	    // eslint-disable-next-line no-self-compare
	    mantissa = number != number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$6(log$8(number) / LN2$2);
	    if (number * (c = pow$3(2, -exponent)) < 1) {
	      exponent--;
	      c *= 2;
	    }
	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow$3(2, 1 - eBias);
	    }
	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }
	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = (number * c - 1) * pow$3(2, mantissaLength);
	      exponent = exponent + eBias;
	    } else {
	      mantissa = number * pow$3(2, eBias - 1) * pow$3(2, mantissaLength);
	      exponent = 0;
	    }
	  }
	  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;
	  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
	  buffer[--index] |= sign * 128;
	  return buffer;
	};

	var unpack = function (buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var sign = buffer[index--];
	  var exponent = sign & 127;
	  var mantissa;
	  sign >>= 7;
	  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;
	  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : sign ? -Infinity$1 : Infinity$1;
	  } else {
	    mantissa = mantissa + pow$3(2, mantissaLength);
	    exponent = exponent - eBias;
	  } return (sign ? -1 : 1) * mantissa * pow$3(2, exponent - mantissaLength);
	};

	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
	var defineProperty$a = objectDefineProperty.f;




	var getInternalState$6 = internalState.get;
	var setInternalState$8 = internalState.set;
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE$2 = 'prototype';
	var WRONG_LENGTH = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var NativeArrayBuffer = global_1[ARRAY_BUFFER];
	var $ArrayBuffer = NativeArrayBuffer;
	var $DataView = global_1[DATA_VIEW];
	var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$2];
	var ObjectPrototype$2 = Object.prototype;
	var RangeError$1 = global_1.RangeError;

	var packIEEE754 = ieee754.pack;
	var unpackIEEE754 = ieee754.unpack;

	var packInt8 = function (number) {
	  return [number & 0xFF];
	};

	var packInt16 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};

	var packInt32 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};

	var unpackInt32 = function (buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};

	var packFloat32 = function (number) {
	  return packIEEE754(number, 23, 4);
	};

	var packFloat64 = function (number) {
	  return packIEEE754(number, 52, 8);
	};

	var addGetter = function (Constructor, key) {
	  defineProperty$a(Constructor[PROTOTYPE$2], key, { get: function () { return getInternalState$6(this)[key]; } });
	};

	var get$1 = function (view, count, index, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$6(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$6(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = bytes.slice(start, start + count);
	  return isLittleEndian ? pack : pack.reverse();
	};

	var set$2 = function (view, count, index, conversion, value, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$6(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$6(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = conversion(+value);
	  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
	};

	if (!arrayBufferNative) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    setInternalState$8(this, {
	      bytes: arrayFill.call(new Array(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!descriptors) this.byteLength = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = getInternalState$6(buffer).byteLength;
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
	    setInternalState$8(this, {
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset
	    });
	    if (!descriptors) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };

	  if (descriptors) {
	    addGetter($ArrayBuffer, 'byteLength');
	    addGetter($DataView, 'buffer');
	    addGetter($DataView, 'byteLength');
	    addGetter($DataView, 'byteOffset');
	  }

	  redefineAll($DataView[PROTOTYPE$2], {
	    getInt8: function getInt8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set$2(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set$2(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set$2(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set$2(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
	    }
	  });
	} else {
	  if (!fails(function () {
	    NativeArrayBuffer(1);
	  }) || !fails(function () {
	    new NativeArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new NativeArrayBuffer(); // eslint-disable-line no-new
	    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
	    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
	    return NativeArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new NativeArrayBuffer(toIndex(length));
	    };
	    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$2] = NativeArrayBuffer[PROTOTYPE$2];
	    for (var keys$3 = getOwnPropertyNames$2(NativeArrayBuffer), j$1 = 0, key$1; keys$3.length > j$1;) {
	      if (!((key$1 = keys$3[j$1++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty($ArrayBuffer, key$1, NativeArrayBuffer[key$1]);
	      }
	    }
	    ArrayBufferPrototype.constructor = $ArrayBuffer;
	  }

	  // WebKit bug - the same parent prototype for typed arrays and data view
	  if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$2) {
	    objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$2);
	  }

	  // iOS Safari 7.x bug
	  var testView = new $DataView(new $ArrayBuffer(2));
	  var nativeSetInt8 = $DataViewPrototype.setInt8;
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
	    setInt8: function setInt8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, { unsafe: true });
	}

	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);

	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var ARRAY_BUFFER$1 = 'ArrayBuffer';
	var ArrayBuffer$1 = arrayBuffer[ARRAY_BUFFER$1];
	var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];

	// `ArrayBuffer` constructor
	// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
	_export({ global: true, forced: NativeArrayBuffer$1 !== ArrayBuffer$1 }, {
	  ArrayBuffer: ArrayBuffer$1
	});

	setSpecies(ARRAY_BUFFER$1);

	var defineProperty$b = objectDefineProperty.f;





	var Int8Array$1 = global_1.Int8Array;
	var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
	var Uint8ClampedArray = global_1.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
	var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
	var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
	var ObjectPrototype$3 = Object.prototype;
	var isPrototypeOf = ObjectPrototype$3.isPrototypeOf;

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
	// Fixing native typed arrays in Opera Presto crashes the browser, see #595
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQIRED = false;
	var NAME$1;

	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};

	var isView = function isView(it) {
	  var klass = classof(it);
	  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
	};

	var isTypedArray = function (it) {
	  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
	};

	var aTypedArray = function (it) {
	  if (isTypedArray(it)) return it;
	  throw TypeError('Target is not a typed array');
	};

	var aTypedArrayConstructor = function (C) {
	  if (objectSetPrototypeOf) {
	    if (isPrototypeOf.call(TypedArray, C)) return C;
	  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME$1)) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
	      return C;
	    }
	  } throw TypeError('Target is not a typed array constructor');
	};

	var exportTypedArrayMethod = function (KEY, property, forced) {
	  if (!descriptors) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
	      delete TypedArrayConstructor.prototype[KEY];
	    }
	  }
	  if (!TypedArrayPrototype[KEY] || forced) {
	    redefine(TypedArrayPrototype, KEY, forced ? property
	      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
	  }
	};

	var exportTypedArrayStaticMethod = function (KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!descriptors) return;
	  if (objectSetPrototypeOf) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global_1[ARRAY];
	      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
	        delete TypedArrayConstructor[KEY];
	      }
	    }
	    if (!TypedArray[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
	      } catch (error) { /* empty */ }
	    } else return;
	  }
	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      redefine(TypedArrayConstructor, KEY, property);
	    }
	  }
	};

	for (NAME$1 in TypedArrayConstructorsList) {
	  if (!global_1[NAME$1]) NATIVE_ARRAY_BUFFER_VIEWS = false;
	}

	// WebKit bug - typed arrays constructors prototype is Object.prototype
	if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
	  // eslint-disable-next-line no-shadow
	  TypedArray = function TypedArray() {
	    throw TypeError('Incorrect invocation');
	  };
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
	    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1], TypedArray);
	  }
	}

	if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$3) {
	  TypedArrayPrototype = TypedArray.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
	    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1].prototype, TypedArrayPrototype);
	  }
	}

	// WebKit bug - one more object in Uint8ClampedArray prototype chain
	if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
	  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
	}

	if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$3)) {
	  TYPED_ARRAY_TAG_REQIRED = true;
	  defineProperty$b(TypedArrayPrototype, TO_STRING_TAG$3, { get: function () {
	    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
	  } });
	  for (NAME$1 in TypedArrayConstructorsList) if (global_1[NAME$1]) {
	    createNonEnumerableProperty(global_1[NAME$1], TYPED_ARRAY_TAG, NAME$1);
	  }
	}

	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
	  aTypedArray: aTypedArray,
	  aTypedArrayConstructor: aTypedArrayConstructor,
	  exportTypedArrayMethod: exportTypedArrayMethod,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
	  isView: isView,
	  isTypedArray: isTypedArray,
	  TypedArray: TypedArray,
	  TypedArrayPrototype: TypedArrayPrototype
	};

	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	// `ArrayBuffer.isView` method
	// https://tc39.github.io/ecma262/#sec-arraybuffer.isview
	_export({ target: 'ArrayBuffer', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS$1 }, {
	  isView: arrayBufferViewCore.isView
	});

	var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
	var DataView$1 = arrayBuffer.DataView;
	var nativeArrayBufferSlice = ArrayBuffer$2.prototype.slice;

	var INCORRECT_SLICE = fails(function () {
	  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
	});

	// `ArrayBuffer.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
	_export({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
	  slice: function slice(start, end) {
	    if (nativeArrayBufferSlice !== undefined && end === undefined) {
	      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
	    }
	    var length = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
	    var viewSource = new DataView$1(this);
	    var viewTarget = new DataView$1(result);
	    var index = 0;
	    while (first < fin) {
	      viewTarget.setUint8(index++, viewSource.getUint8(first++));
	    } return result;
	  }
	});

	// `DataView` constructor
	// https://tc39.github.io/ecma262/#sec-dataview-constructor
	_export({ global: true, forced: !arrayBufferNative }, {
	  DataView: arrayBuffer.DataView
	});

	/* eslint-disable no-new */



	var NATIVE_ARRAY_BUFFER_VIEWS$2 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	var ArrayBuffer$3 = global_1.ArrayBuffer;
	var Int8Array$2 = global_1.Int8Array;

	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$2 || !fails(function () {
	  Int8Array$2(1);
	}) || !fails(function () {
	  new Int8Array$2(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$2();
	  new Int8Array$2(null);
	  new Int8Array$2(1.5);
	  new Int8Array$2(iterable);
	}, true) || fails(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$2(new ArrayBuffer$3(2), 1, undefined).length !== 1;
	});

	var toPositiveInteger = function (it) {
	  var result = toInteger(it);
	  if (result < 0) throw RangeError("The argument can't be less than 0");
	  return result;
	};

	var toOffset = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw RangeError('Wrong offset');
	  return offset;
	};

	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

	var typedArrayFrom = function from(source /* , mapfn, thisArg */) {
	  var O = toObject(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, step, iterator, next;
	  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    O = [];
	    while (!(step = next.call(iterator)).done) {
	      O.push(step.value);
	    }
	  }
	  if (mapping && argumentsLength > 2) {
	    mapfn = functionBindContext(mapfn, arguments[2], 2);
	  }
	  length = toLength(O.length);
	  result = new (aTypedArrayConstructor$1(this))(length);
	  for (i = 0; length > i; i++) {
	    result[i] = mapping ? mapfn(O[i], i) : O[i];
	  }
	  return result;
	};

	var typedArrayConstructor = createCommonjsModule(function (module) {


















	var getOwnPropertyNames = objectGetOwnPropertyNames.f;

	var forEach = arrayIteration.forEach;






	var getInternalState = internalState.get;
	var setInternalState = internalState.set;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var round = Math.round;
	var RangeError = global_1.RangeError;
	var ArrayBuffer = arrayBuffer.ArrayBuffer;
	var DataView = arrayBuffer.DataView;
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
	var TypedArray = arrayBufferViewCore.TypedArray;
	var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
	var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	var isTypedArray = arrayBufferViewCore.isTypedArray;
	var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	var WRONG_LENGTH = 'Wrong length';

	var fromList = function (C, list) {
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	};

	var addGetter = function (it, key) {
	  nativeDefineProperty(it, key, { get: function () {
	    return getInternalState(this)[key];
	  } });
	};

	var isArrayBuffer = function (it) {
	  var klass;
	  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
	};

	var isTypedArrayIndex = function (target, key) {
	  return isTypedArray(target)
	    && typeof key != 'symbol'
	    && key in target
	    && String(+key) == String(key);
	};

	var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	  return isTypedArrayIndex(target, key = toPrimitive(key, true))
	    ? createPropertyDescriptor(2, target[key])
	    : nativeGetOwnPropertyDescriptor(target, key);
	};

	var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
	    && isObject(descriptor)
	    && has(descriptor, 'value')
	    && !has(descriptor, 'get')
	    && !has(descriptor, 'set')
	    // TODO: add validation descriptor w/o calling accessors
	    && !descriptor.configurable
	    && (!has(descriptor, 'writable') || descriptor.writable)
	    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
	  ) {
	    target[key] = descriptor.value;
	    return target;
	  } return nativeDefineProperty(target, key, descriptor);
	};

	if (descriptors) {
	  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	    objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
	    objectDefineProperty.f = wrappedDefineProperty;
	    addGetter(TypedArrayPrototype, 'buffer');
	    addGetter(TypedArrayPrototype, 'byteOffset');
	    addGetter(TypedArrayPrototype, 'byteLength');
	    addGetter(TypedArrayPrototype, 'length');
	  }

	  _export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
	    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	    defineProperty: wrappedDefineProperty
	  });

	  module.exports = function (TYPE, wrapper, CLAMPED) {
	    var BYTES = TYPE.match(/\d+$/)[0] / 8;
	    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + TYPE;
	    var SETTER = 'set' + TYPE;
	    var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
	    var TypedArrayConstructor = NativeTypedArrayConstructor;
	    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	    var exported = {};

	    var getter = function (that, index) {
	      var data = getInternalState(that);
	      return data.view[GETTER](index * BYTES + data.byteOffset, true);
	    };

	    var setter = function (that, index, value) {
	      var data = getInternalState(that);
	      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
	    };

	    var addElement = function (that, index) {
	      nativeDefineProperty(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };

	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
	        var index = 0;
	        var byteOffset = 0;
	        var buffer, byteLength, length;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new ArrayBuffer(byteLength);
	        } else if (isArrayBuffer(data)) {
	          buffer = data;
	          byteOffset = toOffset(offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - byteOffset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (isTypedArray(data)) {
	          return fromList(TypedArrayConstructor, data);
	        } else {
	          return typedArrayFrom.call(TypedArrayConstructor, data);
	        }
	        setInternalState(that, {
	          buffer: buffer,
	          byteOffset: byteOffset,
	          byteLength: byteLength,
	          length: length,
	          view: new DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });

	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
	    } else if (typedArrayConstructorsRequireWrappers) {
	      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
	        return inheritIfRequired(function () {
	          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
	          if (isArrayBuffer(data)) return $length !== undefined
	            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
	            : typedArrayOffset !== undefined
	              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
	              : new NativeTypedArrayConstructor(data);
	          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	          return typedArrayFrom.call(TypedArrayConstructor, data);
	        }(), dummy, TypedArrayConstructor);
	      });

	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	        if (!(key in TypedArrayConstructor)) {
	          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	        }
	      });
	      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	    }

	    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	    }

	    if (TYPED_ARRAY_TAG) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	    }

	    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

	    _export({
	      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
	    }, exported);

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	    }

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	    }

	    setSpecies(CONSTRUCTOR_NAME);
	  };
	} else module.exports = function () { /* empty */ };
	});

	// `Int8Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int8', function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8ClampedArray` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	// `Int16Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int16', function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint16Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint16', function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int32', function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint32', function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Float32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Float32', function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Float64Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Float64', function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod;


	// `%TypedArray%.from` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.from
	exportTypedArrayStaticMethod$1('from', typedArrayFrom, typedArrayConstructorsRequireWrappers);

	var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod;

	// `%TypedArray%.of` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.of
	exportTypedArrayStaticMethod$2('of', function of(/* ...items */) {
	  var index = 0;
	  var length = arguments.length;
	  var result = new (aTypedArrayConstructor$2(this))(length);
	  while (length > index) result[index] = arguments[index++];
	  return result;
	}, typedArrayConstructorsRequireWrappers);

	var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.copyWithin` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
	exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start /* , end */) {
	  return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	});

	var $every$1 = arrayIteration.every;

	var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
	exportTypedArrayMethod$2('every', function every(callbackfn /* , thisArg */) {
	  return $every$1(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {
	  return arrayFill.apply(aTypedArray$3(this), arguments);
	});

	var $filter$1 = arrayIteration.filter;


	var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
	exportTypedArrayMethod$4('filter', function filter(callbackfn /* , thisArg */) {
	  var list = $filter$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$3(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	});

	var $find$1 = arrayIteration.find;

	var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
	exportTypedArrayMethod$5('find', function find(predicate /* , thisArg */) {
	  return $find$1(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $findIndex$1 = arrayIteration.findIndex;

	var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
	exportTypedArrayMethod$6('findIndex', function findIndex(predicate /* , thisArg */) {
	  return $findIndex$1(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $forEach$2 = arrayIteration.forEach;

	var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
	exportTypedArrayMethod$7('forEach', function forEach(callbackfn /* , thisArg */) {
	  $forEach$2(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $includes$1 = arrayIncludes.includes;

	var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
	exportTypedArrayMethod$8('includes', function includes(searchElement /* , fromIndex */) {
	  return $includes$1(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $indexOf$1 = arrayIncludes.indexOf;

	var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
	exportTypedArrayMethod$9('indexOf', function indexOf(searchElement /* , fromIndex */) {
	  return $indexOf$1(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var ITERATOR$5 = wellKnownSymbol('iterator');
	var Uint8Array = global_1.Uint8Array;
	var arrayValues = es_array_iterator.values;
	var arrayKeys = es_array_iterator.keys;
	var arrayEntries = es_array_iterator.entries;
	var aTypedArray$a = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
	var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR$5];

	var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
	  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

	var typedArrayValues = function values() {
	  return arrayValues.call(aTypedArray$a(this));
	};

	// `%TypedArray%.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
	exportTypedArrayMethod$a('entries', function entries() {
	  return arrayEntries.call(aTypedArray$a(this));
	});
	// `%TypedArray%.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
	exportTypedArrayMethod$a('keys', function keys() {
	  return arrayKeys.call(aTypedArray$a(this));
	});
	// `%TypedArray%.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
	exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME);
	// `%TypedArray%.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
	exportTypedArrayMethod$a(ITERATOR$5, typedArrayValues, !CORRECT_ITER_NAME);

	var aTypedArray$b = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
	var $join = [].join;

	// `%TypedArray%.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$b('join', function join(separator) {
	  return $join.apply(aTypedArray$b(this), arguments);
	});

	var aTypedArray$c = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
	  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
	});

	var $map$1 = arrayIteration.map;


	var aTypedArray$d = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
	exportTypedArrayMethod$d('map', function map(mapfn /* , thisArg */) {
	  return $map$1(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
	    return new (aTypedArrayConstructor$4(speciesConstructor(O, O.constructor)))(length);
	  });
	});

	var $reduce$1 = arrayReduce.left;

	var aTypedArray$e = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
	exportTypedArrayMethod$e('reduce', function reduce(callbackfn /* , initialValue */) {
	  return $reduce$1(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $reduceRight$1 = arrayReduce.right;

	var aTypedArray$f = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.reduceRicht` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
	exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
	  return $reduceRight$1(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$g = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
	var floor$7 = Math.floor;

	// `%TypedArray%.prototype.reverse` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
	exportTypedArrayMethod$g('reverse', function reverse() {
	  var that = this;
	  var length = aTypedArray$g(that).length;
	  var middle = floor$7(length / 2);
	  var index = 0;
	  var value;
	  while (index < middle) {
	    value = that[index];
	    that[index++] = that[--length];
	    that[length] = value;
	  } return that;
	});

	var aTypedArray$h = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;

	var FORCED$h = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).set({});
	});

	// `%TypedArray%.prototype.set` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
	exportTypedArrayMethod$h('set', function set(arrayLike /* , offset */) {
	  aTypedArray$h(this);
	  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
	  var length = this.length;
	  var src = toObject(arrayLike);
	  var len = toLength(src.length);
	  var index = 0;
	  if (len + offset > length) throw RangeError('Wrong length');
	  while (index < len) this[offset + index] = src[index++];
	}, FORCED$h);

	var aTypedArray$i = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$5 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
	var $slice = [].slice;

	var FORCED$i = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).slice();
	});

	// `%TypedArray%.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
	exportTypedArrayMethod$i('slice', function slice(start, end) {
	  var list = $slice.call(aTypedArray$i(this), start, end);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$5(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	}, FORCED$i);

	var $some$1 = arrayIteration.some;

	var aTypedArray$j = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
	exportTypedArrayMethod$j('some', function some(callbackfn /* , thisArg */) {
	  return $some$1(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$k = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
	var $sort = [].sort;

	// `%TypedArray%.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
	exportTypedArrayMethod$k('sort', function sort(comparefn) {
	  return $sort.call(aTypedArray$k(this), comparefn);
	});

	var aTypedArray$l = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.subarray` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
	exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
	  var O = aTypedArray$l(this);
	  var length = O.length;
	  var beginIndex = toAbsoluteIndex(begin, length);
	  return new (speciesConstructor(O, O.constructor))(
	    O.buffer,
	    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
	    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
	  );
	});

	var Int8Array$3 = global_1.Int8Array;
	var aTypedArray$m = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
	var $toLocaleString = [].toLocaleString;
	var $slice$1 = [].slice;

	// iOS Safari 6.x fails here
	var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
	  $toLocaleString.call(new Int8Array$3(1));
	});

	var FORCED$j = fails(function () {
	  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
	}) || !fails(function () {
	  Int8Array$3.prototype.toLocaleString.call([1, 2]);
	});

	// `%TypedArray%.prototype.toLocaleString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
	exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
	  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
	}, FORCED$j);

	var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;



	var Uint8Array$1 = global_1.Uint8Array;
	var Uint8ArrayPrototype = Uint8Array$1 && Uint8Array$1.prototype || {};
	var arrayToString = [].toString;
	var arrayJoin = [].join;

	if (fails(function () { arrayToString.call({}); })) {
	  arrayToString = function toString() {
	    return arrayJoin.call(this);
	  };
	}

	var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

	// `%TypedArray%.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
	exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

	var nativeApply = getBuiltIn('Reflect', 'apply');
	var functionApply = Function.apply;

	// MS Edge argumentsList argument is optional
	var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
	  nativeApply(function () { /* empty */ });
	});

	// `Reflect.apply` method
	// https://tc39.github.io/ecma262/#sec-reflect.apply
	_export({ target: 'Reflect', stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
	  apply: function apply(target, thisArgument, argumentsList) {
	    aFunction$1(target);
	    anObject(argumentsList);
	    return nativeApply
	      ? nativeApply(target, thisArgument, argumentsList)
	      : functionApply.call(target, thisArgument, argumentsList);
	  }
	});

	var nativeConstruct = getBuiltIn('Reflect', 'construct');

	// `Reflect.construct` method
	// https://tc39.github.io/ecma262/#sec-reflect.construct
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() { /* empty */ }
	  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  nativeConstruct(function () { /* empty */ });
	});
	var FORCED$k = NEW_TARGET_BUG || ARGS_BUG;

	_export({ target: 'Reflect', stat: true, forced: FORCED$k, sham: FORCED$k }, {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction$1(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (functionBind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	var ERROR_INSTEAD_OF_FALSE = fails(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(objectDefineProperty.f({}, 1, { value: 1 }), 1, { value: 2 });
	});

	// `Reflect.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-reflect.defineproperty
	_export({ target: 'Reflect', stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !descriptors }, {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    var key = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      objectDefineProperty.f(target, key, attributes);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	var getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;

	// `Reflect.deleteProperty` method
	// https://tc39.github.io/ecma262/#sec-reflect.deleteproperty
	_export({ target: 'Reflect', stat: true }, {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var descriptor = getOwnPropertyDescriptor$8(anObject(target), propertyKey);
	    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
	  }
	});

	// `Reflect.get` method
	// https://tc39.github.io/ecma262/#sec-reflect.get
	function get$2(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var descriptor, prototype;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, 'value')
	    ? descriptor.value
	    : descriptor.get === undefined
	      ? undefined
	      : descriptor.get.call(receiver);
	  if (isObject(prototype = objectGetPrototypeOf(target))) return get$2(prototype, propertyKey, receiver);
	}

	_export({ target: 'Reflect', stat: true }, {
	  get: get$2
	});

	// `Reflect.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor
	_export({ target: 'Reflect', stat: true, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  }
	});

	// `Reflect.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-reflect.getprototypeof
	_export({ target: 'Reflect', stat: true, sham: !correctPrototypeGetter }, {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return objectGetPrototypeOf(anObject(target));
	  }
	});

	// `Reflect.has` method
	// https://tc39.github.io/ecma262/#sec-reflect.has
	_export({ target: 'Reflect', stat: true }, {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	var objectIsExtensible = Object.isExtensible;

	// `Reflect.isExtensible` method
	// https://tc39.github.io/ecma262/#sec-reflect.isextensible
	_export({ target: 'Reflect', stat: true }, {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return objectIsExtensible ? objectIsExtensible(target) : true;
	  }
	});

	// `Reflect.ownKeys` method
	// https://tc39.github.io/ecma262/#sec-reflect.ownkeys
	_export({ target: 'Reflect', stat: true }, {
	  ownKeys: ownKeys
	});

	// `Reflect.preventExtensions` method
	// https://tc39.github.io/ecma262/#sec-reflect.preventextensions
	_export({ target: 'Reflect', stat: true, sham: !freezing }, {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
	      if (objectPreventExtensions) objectPreventExtensions(target);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	// `Reflect.set` method
	// https://tc39.github.io/ecma262/#sec-reflect.set
	function set$3(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  var existingDescriptor, prototype;
	  if (!ownDescriptor) {
	    if (isObject(prototype = objectGetPrototypeOf(target))) {
	      return set$3(prototype, propertyKey, V, receiver);
	    }
	    ownDescriptor = createPropertyDescriptor(0);
	  }
	  if (has(ownDescriptor, 'value')) {
	    if (ownDescriptor.writable === false || !isObject(receiver)) return false;
	    if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      objectDefineProperty.f(receiver, propertyKey, existingDescriptor);
	    } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));
	    return true;
	  }
	  return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
	}

	// MS Edge 17-18 Reflect.set allows setting the property to object
	// with non-writable property on the prototype
	var MS_EDGE_BUG = fails(function () {
	  var object = objectDefineProperty.f({}, 'a', { configurable: true });
	  // eslint-disable-next-line no-undef
	  return Reflect.set(objectGetPrototypeOf(object), 'a', 1, object) !== false;
	});

	_export({ target: 'Reflect', stat: true, forced: MS_EDGE_BUG }, {
	  set: set$3
	});

	// `Reflect.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-reflect.setprototypeof
	if (objectSetPrototypeOf) _export({ target: 'Reflect', stat: true }, {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    anObject(target);
	    aPossiblePrototype(proto);
	    try {
	      objectSetPrototypeOf(target, proto);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`




	var metadata = shared('metadata');
	var store$2 = metadata.store || (metadata.store = new es_weakMap());

	var getOrCreateMetadataMap = function (target, targetKey, create) {
	  var targetMetadata = store$2.get(target);
	  if (!targetMetadata) {
	    if (!create) return;
	    store$2.set(target, targetMetadata = new es_map());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return;
	    targetMetadata.set(targetKey, keyMetadata = new es_map());
	  } return keyMetadata;
	};

	var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};

	var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};

	var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};

	var ordinaryOwnMetadataKeys = function (target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
	  return keys;
	};

	var toMetadataKey = function (it) {
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};

	var reflectMetadata = {
	  store: store$2,
	  getMap: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  toKey: toMetadataKey
	};

	var toMetadataKey$1 = reflectMetadata.toKey;
	var ordinaryDefineOwnMetadata$1 = reflectMetadata.set;

	// `Reflect.defineMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  defineMetadata: function defineMetadata(metadataKey, metadataValue, target /* , targetKey */) {
	    var targetKey = arguments.length < 4 ? undefined : toMetadataKey$1(arguments[3]);
	    ordinaryDefineOwnMetadata$1(metadataKey, metadataValue, anObject(target), targetKey);
	  }
	});

	var toMetadataKey$2 = reflectMetadata.toKey;
	var getOrCreateMetadataMap$1 = reflectMetadata.getMap;
	var store$3 = reflectMetadata.store;

	// `Reflect.deleteMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$2(arguments[2]);
	    var metadataMap = getOrCreateMetadataMap$1(anObject(target), targetKey, false);
	    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	    if (metadataMap.size) return true;
	    var targetMetadata = store$3.get(target);
	    targetMetadata['delete'](targetKey);
	    return !!targetMetadata.size || store$3['delete'](target);
	  }
	});

	var ordinaryHasOwnMetadata$1 = reflectMetadata.has;
	var ordinaryGetOwnMetadata$1 = reflectMetadata.get;
	var toMetadataKey$3 = reflectMetadata.toKey;

	var ordinaryGetMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$1(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata$1(MetadataKey, O, P);
	  var parent = objectGetPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	// `Reflect.getMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$3(arguments[2]);
	    return ordinaryGetMetadata(metadataKey, anObject(target), targetKey);
	  }
	});

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`






	var ordinaryOwnMetadataKeys$1 = reflectMetadata.keys;
	var toMetadataKey$4 = reflectMetadata.toKey;

	var from = function (iter) {
	  var result = [];
	  iterate_1(iter, result.push, result);
	  return result;
	};

	var ordinaryMetadataKeys = function (O, P) {
	  var oKeys = ordinaryOwnMetadataKeys$1(O, P);
	  var parent = objectGetPrototypeOf(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new es_set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};

	// `Reflect.getMetadataKeys` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
	    var targetKey = arguments.length < 2 ? undefined : toMetadataKey$4(arguments[1]);
	    return ordinaryMetadataKeys(anObject(target), targetKey);
	  }
	});

	var ordinaryGetOwnMetadata$2 = reflectMetadata.get;
	var toMetadataKey$5 = reflectMetadata.toKey;

	// `Reflect.getOwnMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$5(arguments[2]);
	    return ordinaryGetOwnMetadata$2(metadataKey, anObject(target), targetKey);
	  }
	});

	var ordinaryOwnMetadataKeys$2 = reflectMetadata.keys;
	var toMetadataKey$6 = reflectMetadata.toKey;

	// `Reflect.getOwnMetadataKeys` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
	    var targetKey = arguments.length < 2 ? undefined : toMetadataKey$6(arguments[1]);
	    return ordinaryOwnMetadataKeys$2(anObject(target), targetKey);
	  }
	});

	var ordinaryHasOwnMetadata$2 = reflectMetadata.has;
	var toMetadataKey$7 = reflectMetadata.toKey;

	var ordinaryHasMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$2(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = objectGetPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	// `Reflect.hasMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$7(arguments[2]);
	    return ordinaryHasMetadata(metadataKey, anObject(target), targetKey);
	  }
	});

	var ordinaryHasOwnMetadata$3 = reflectMetadata.has;
	var toMetadataKey$8 = reflectMetadata.toKey;

	// `Reflect.hasOwnMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$8(arguments[2]);
	    return ordinaryHasOwnMetadata$3(metadataKey, anObject(target), targetKey);
	  }
	});

	var toMetadataKey$9 = reflectMetadata.toKey;
	var ordinaryDefineOwnMetadata$2 = reflectMetadata.set;

	// `Reflect.metadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  metadata: function metadata(metadataKey, metadataValue) {
	    return function decorator(target, key) {
	      ordinaryDefineOwnMetadata$2(metadataKey, metadataValue, anObject(target), toMetadataKey$9(key));
	    };
	  }
	});

	// `Math.iaddh` method
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	// TODO: Remove from `core-js@4`
	_export({ target: 'Math', stat: true }, {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

	// `Math.isubh` method
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	// TODO: Remove from `core-js@4`
	_export({ target: 'Math', stat: true }, {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

	// `Math.imulh` method
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	// TODO: Remove from `core-js@4`
	_export({ target: 'Math', stat: true }, {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xFFFF;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

	// `Math.umulh` method
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	// TODO: Remove from `core-js@4`
	_export({ target: 'Math', stat: true }, {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xFFFF;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

	var charAt$2 = stringMultibyte.charAt;

	// `String.prototype.at` method
	// https://github.com/mathiasbynens/String.prototype.at
	_export({ target: 'String', proto: true }, {
	  at: function at(pos) {
	    return charAt$2(this, pos);
	  }
	});

	var ITERATOR$6 = wellKnownSymbol('iterator');

	var nativeUrl = !fails(function () {
	  var url = new URL('b?a=1&b=2&c=3', 'http://a');
	  var searchParams = url.searchParams;
	  var result = '';
	  url.pathname = 'c%20d';
	  searchParams.forEach(function (value, key) {
	    searchParams['delete']('b');
	    result += key + value;
	  });
	  return (isPure && !url.toJSON)
	    || !searchParams.sort
	    || url.href !== 'http://a/c%20d?a=1&c=3'
	    || searchParams.get('c') !== '3'
	    || String(new URLSearchParams('?a=1')) !== 'a=1'
	    || !searchParams[ITERATOR$6]
	    // throws in Edge
	    || new URL('https://a@b').username !== 'a'
	    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
	    // not punycoded in Edge
	    || new URL('http://ÑÐµÑÑ').host !== 'xn--e1aybc'
	    // not escaped in Chrome 62-
	    || new URL('http://a#Ð±').hash !== '#%D0%B1'
	    // fails in Chrome 66-
	    || result !== 'a1c3'
	    // throws in Safari
	    || new URL('http://x', undefined).host !== 'x';
	});

	// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'
	var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
	var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
	var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
	var baseMinusTMin = base - tMin;
	var floor$8 = Math.floor;
	var stringFromCharCode = String.fromCharCode;

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 */
	var ucs2decode = function (string) {
	  var output = [];
	  var counter = 0;
	  var length = string.length;
	  while (counter < length) {
	    var value = string.charCodeAt(counter++);
	    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	      // It's a high surrogate, and there is a next character.
	      var extra = string.charCodeAt(counter++);
	      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
	        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	      } else {
	        // It's an unmatched surrogate; only append this code unit, in case the
	        // next code unit is the high surrogate of a surrogate pair.
	        output.push(value);
	        counter--;
	      }
	    } else {
	      output.push(value);
	    }
	  }
	  return output;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 */
	var digitToBasic = function (digit) {
	  //  0..25 map to ASCII a..z or A..Z
	  // 26..35 map to ASCII 0..9
	  return digit + 22 + 75 * (digit < 26);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 */
	var adapt = function (delta, numPoints, firstTime) {
	  var k = 0;
	  delta = firstTime ? floor$8(delta / damp) : delta >> 1;
	  delta += floor$8(delta / numPoints);
	  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
	    delta = floor$8(delta / baseMinusTMin);
	  }
	  return floor$8(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 */
	// eslint-disable-next-line  max-statements
	var encode = function (input) {
	  var output = [];

	  // Convert the input in UCS-2 to an array of Unicode code points.
	  input = ucs2decode(input);

	  // Cache the length.
	  var inputLength = input.length;

	  // Initialize the state.
	  var n = initialN;
	  var delta = 0;
	  var bias = initialBias;
	  var i, currentValue;

	  // Handle the basic code points.
	  for (i = 0; i < input.length; i++) {
	    currentValue = input[i];
	    if (currentValue < 0x80) {
	      output.push(stringFromCharCode(currentValue));
	    }
	  }

	  var basicLength = output.length; // number of basic code points.
	  var handledCPCount = basicLength; // number of code points that have been handled;

	  // Finish the basic string with a delimiter unless it's empty.
	  if (basicLength) {
	    output.push(delimiter);
	  }

	  // Main encoding loop:
	  while (handledCPCount < inputLength) {
	    // All non-basic code points < n have been handled already. Find the next larger one:
	    var m = maxInt;
	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue >= n && currentValue < m) {
	        m = currentValue;
	      }
	    }

	    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
	    var handledCPCountPlusOne = handledCPCount + 1;
	    if (m - n > floor$8((maxInt - delta) / handledCPCountPlusOne)) {
	      throw RangeError(OVERFLOW_ERROR);
	    }

	    delta += (m - n) * handledCPCountPlusOne;
	    n = m;

	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue < n && ++delta > maxInt) {
	        throw RangeError(OVERFLOW_ERROR);
	      }
	      if (currentValue == n) {
	        // Represent delta as a generalized variable-length integer.
	        var q = delta;
	        for (var k = base; /* no condition */; k += base) {
	          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	          if (q < t) break;
	          var qMinusT = q - t;
	          var baseMinusT = base - t;
	          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
	          q = floor$8(qMinusT / baseMinusT);
	        }

	        output.push(stringFromCharCode(digitToBasic(q)));
	        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	        delta = 0;
	        ++handledCPCount;
	      }
	    }

	    ++delta;
	    ++n;
	  }
	  return output.join('');
	};

	var stringPunycodeToAscii = function (input) {
	  var encoded = [];
	  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
	  var i, label;
	  for (i = 0; i < labels.length; i++) {
	    label = labels[i];
	    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
	  }
	  return encoded.join('.');
	};

	var getIterator = function (it) {
	  var iteratorMethod = getIteratorMethod(it);
	  if (typeof iteratorMethod != 'function') {
	    throw TypeError(String(it) + ' is not iterable');
	  } return anObject(iteratorMethod.call(it));
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`





















	var $fetch$1 = getBuiltIn('fetch');
	var Headers = getBuiltIn('Headers');
	var ITERATOR$7 = wellKnownSymbol('iterator');
	var URL_SEARCH_PARAMS = 'URLSearchParams';
	var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
	var setInternalState$9 = internalState.set;
	var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
	var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);

	var plus = /\+/g;
	var sequences = Array(4);

	var percentSequence = function (bytes) {
	  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
	};

	var percentDecode = function (sequence) {
	  try {
	    return decodeURIComponent(sequence);
	  } catch (error) {
	    return sequence;
	  }
	};

	var deserialize = function (it) {
	  var result = it.replace(plus, ' ');
	  var bytes = 4;
	  try {
	    return decodeURIComponent(result);
	  } catch (error) {
	    while (bytes) {
	      result = result.replace(percentSequence(bytes--), percentDecode);
	    }
	    return result;
	  }
	};

	var find$1 = /[!'()~]|%20/g;

	var replace = {
	  '!': '%21',
	  "'": '%27',
	  '(': '%28',
	  ')': '%29',
	  '~': '%7E',
	  '%20': '+'
	};

	var replacer = function (match) {
	  return replace[match];
	};

	var serialize = function (it) {
	  return encodeURIComponent(it).replace(find$1, replacer);
	};

	var parseSearchParams = function (result, query) {
	  if (query) {
	    var attributes = query.split('&');
	    var index = 0;
	    var attribute, entry;
	    while (index < attributes.length) {
	      attribute = attributes[index++];
	      if (attribute.length) {
	        entry = attribute.split('=');
	        result.push({
	          key: deserialize(entry.shift()),
	          value: deserialize(entry.join('='))
	        });
	      }
	    }
	  }
	};

	var updateSearchParams = function (query) {
	  this.entries.length = 0;
	  parseSearchParams(this.entries, query);
	};

	var validateArgumentsLength = function (passed, required) {
	  if (passed < required) throw TypeError('Not enough arguments');
	};

	var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
	  setInternalState$9(this, {
	    type: URL_SEARCH_PARAMS_ITERATOR,
	    iterator: getIterator(getInternalParamsState(params).entries),
	    kind: kind
	  });
	}, 'Iterator', function next() {
	  var state = getInternalIteratorState(this);
	  var kind = state.kind;
	  var step = state.iterator.next();
	  var entry = step.value;
	  if (!step.done) {
	    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
	  } return step;
	});

	// `URLSearchParams` constructor
	// https://url.spec.whatwg.org/#interface-urlsearchparams
	var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
	  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
	  var init = arguments.length > 0 ? arguments[0] : undefined;
	  var that = this;
	  var entries = [];
	  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;

	  setInternalState$9(that, {
	    type: URL_SEARCH_PARAMS,
	    entries: entries,
	    updateURL: function () { /* empty */ },
	    updateSearchParams: updateSearchParams
	  });

	  if (init !== undefined) {
	    if (isObject(init)) {
	      iteratorMethod = getIteratorMethod(init);
	      if (typeof iteratorMethod === 'function') {
	        iterator = iteratorMethod.call(init);
	        next = iterator.next;
	        while (!(step = next.call(iterator)).done) {
	          entryIterator = getIterator(anObject(step.value));
	          entryNext = entryIterator.next;
	          if (
	            (first = entryNext.call(entryIterator)).done ||
	            (second = entryNext.call(entryIterator)).done ||
	            !entryNext.call(entryIterator).done
	          ) throw TypeError('Expected sequence with length 2');
	          entries.push({ key: first.value + '', value: second.value + '' });
	        }
	      } else for (key in init) if (has(init, key)) entries.push({ key: key, value: init[key] + '' });
	    } else {
	      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
	    }
	  }
	};

	var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

	redefineAll(URLSearchParamsPrototype, {
	  // `URLSearchParams.prototype.appent` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
	  append: function append(name, value) {
	    validateArgumentsLength(arguments.length, 2);
	    var state = getInternalParamsState(this);
	    state.entries.push({ key: name + '', value: value + '' });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.delete` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
	  'delete': function (name) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index].key === key) entries.splice(index, 1);
	      else index++;
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.get` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
	  get: function get(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) return entries[index].value;
	    }
	    return null;
	  },
	  // `URLSearchParams.prototype.getAll` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
	  getAll: function getAll(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var result = [];
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) result.push(entries[index].value);
	    }
	    return result;
	  },
	  // `URLSearchParams.prototype.has` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
	  has: function has(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index++].key === key) return true;
	    }
	    return false;
	  },
	  // `URLSearchParams.prototype.set` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
	  set: function set(name, value) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var found = false;
	    var key = name + '';
	    var val = value + '';
	    var index = 0;
	    var entry;
	    for (; index < entries.length; index++) {
	      entry = entries[index];
	      if (entry.key === key) {
	        if (found) entries.splice(index--, 1);
	        else {
	          found = true;
	          entry.value = val;
	        }
	      }
	    }
	    if (!found) entries.push({ key: key, value: val });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.sort` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
	  sort: function sort() {
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    // Array#sort is not stable in some engines
	    var slice = entries.slice();
	    var entry, entriesIndex, sliceIndex;
	    entries.length = 0;
	    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
	      entry = slice[sliceIndex];
	      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
	        if (entries[entriesIndex].key > entry.key) {
	          entries.splice(entriesIndex, 0, entry);
	          break;
	        }
	      }
	      if (entriesIndex === sliceIndex) entries.push(entry);
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.forEach` method
	  forEach: function forEach(callback /* , thisArg */) {
	    var entries = getInternalParamsState(this).entries;
	    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var index = 0;
	    var entry;
	    while (index < entries.length) {
	      entry = entries[index++];
	      boundFunction(entry.value, entry.key, this);
	    }
	  },
	  // `URLSearchParams.prototype.keys` method
	  keys: function keys() {
	    return new URLSearchParamsIterator(this, 'keys');
	  },
	  // `URLSearchParams.prototype.values` method
	  values: function values() {
	    return new URLSearchParamsIterator(this, 'values');
	  },
	  // `URLSearchParams.prototype.entries` method
	  entries: function entries() {
	    return new URLSearchParamsIterator(this, 'entries');
	  }
	}, { enumerable: true });

	// `URLSearchParams.prototype[@@iterator]` method
	redefine(URLSearchParamsPrototype, ITERATOR$7, URLSearchParamsPrototype.entries);

	// `URLSearchParams.prototype.toString` method
	// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
	redefine(URLSearchParamsPrototype, 'toString', function toString() {
	  var entries = getInternalParamsState(this).entries;
	  var result = [];
	  var index = 0;
	  var entry;
	  while (index < entries.length) {
	    entry = entries[index++];
	    result.push(serialize(entry.key) + '=' + serialize(entry.value));
	  } return result.join('&');
	}, { enumerable: true });

	setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

	_export({ global: true, forced: !nativeUrl }, {
	  URLSearchParams: URLSearchParamsConstructor
	});

	// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
	// https://github.com/zloirock/core-js/issues/674
	if (!nativeUrl && typeof $fetch$1 == 'function' && typeof Headers == 'function') {
	  _export({ global: true, enumerable: true, forced: true }, {
	    fetch: function fetch(input /* , init */) {
	      var args = [input];
	      var init, body, headers;
	      if (arguments.length > 1) {
	        init = arguments[1];
	        if (isObject(init)) {
	          body = init.body;
	          if (classof(body) === URL_SEARCH_PARAMS) {
	            headers = init.headers ? new Headers(init.headers) : new Headers();
	            if (!headers.has('content-type')) {
	              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	            }
	            init = objectCreate(init, {
	              body: createPropertyDescriptor(0, String(body)),
	              headers: createPropertyDescriptor(0, headers)
	            });
	          }
	        }
	        args.push(init);
	      } return $fetch$1.apply(this, args);
	    }
	  });
	}

	var web_urlSearchParams = {
	  URLSearchParams: URLSearchParamsConstructor,
	  getState: getInternalParamsState
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`











	var codeAt$1 = stringMultibyte.codeAt;





	var NativeURL = global_1.URL;
	var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
	var getInternalSearchParamsState = web_urlSearchParams.getState;
	var setInternalState$a = internalState.set;
	var getInternalURLState = internalState.getterFor('URL');
	var floor$9 = Math.floor;
	var pow$4 = Math.pow;

	var INVALID_AUTHORITY = 'Invalid authority';
	var INVALID_SCHEME = 'Invalid scheme';
	var INVALID_HOST = 'Invalid host';
	var INVALID_PORT = 'Invalid port';

	var ALPHA = /[A-Za-z]/;
	var ALPHANUMERIC = /[\d+-.A-Za-z]/;
	var DIGIT = /\d/;
	var HEX_START = /^(0x|0X)/;
	var OCT = /^[0-7]+$/;
	var DEC = /^\d+$/;
	var HEX = /^[\dA-Fa-f]+$/;
	// eslint-disable-next-line no-control-regex
	var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
	// eslint-disable-next-line no-control-regex
	var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
	// eslint-disable-next-line no-control-regex
	var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
	// eslint-disable-next-line no-control-regex
	var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
	var EOF;

	var parseHost = function (url, input) {
	  var result, codePoints, index;
	  if (input.charAt(0) == '[') {
	    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
	    result = parseIPv6(input.slice(1, -1));
	    if (!result) return INVALID_HOST;
	    url.host = result;
	  // opaque host
	  } else if (!isSpecial(url)) {
	    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
	    result = '';
	    codePoints = arrayFrom(input);
	    for (index = 0; index < codePoints.length; index++) {
	      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
	    }
	    url.host = result;
	  } else {
	    input = stringPunycodeToAscii(input);
	    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
	    result = parseIPv4(input);
	    if (result === null) return INVALID_HOST;
	    url.host = result;
	  }
	};

	var parseIPv4 = function (input) {
	  var parts = input.split('.');
	  var partsLength, numbers, index, part, radix, number, ipv4;
	  if (parts.length && parts[parts.length - 1] == '') {
	    parts.pop();
	  }
	  partsLength = parts.length;
	  if (partsLength > 4) return input;
	  numbers = [];
	  for (index = 0; index < partsLength; index++) {
	    part = parts[index];
	    if (part == '') return input;
	    radix = 10;
	    if (part.length > 1 && part.charAt(0) == '0') {
	      radix = HEX_START.test(part) ? 16 : 8;
	      part = part.slice(radix == 8 ? 1 : 2);
	    }
	    if (part === '') {
	      number = 0;
	    } else {
	      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
	      number = parseInt(part, radix);
	    }
	    numbers.push(number);
	  }
	  for (index = 0; index < partsLength; index++) {
	    number = numbers[index];
	    if (index == partsLength - 1) {
	      if (number >= pow$4(256, 5 - partsLength)) return null;
	    } else if (number > 255) return null;
	  }
	  ipv4 = numbers.pop();
	  for (index = 0; index < numbers.length; index++) {
	    ipv4 += numbers[index] * pow$4(256, 3 - index);
	  }
	  return ipv4;
	};

	// eslint-disable-next-line max-statements
	var parseIPv6 = function (input) {
	  var address = [0, 0, 0, 0, 0, 0, 0, 0];
	  var pieceIndex = 0;
	  var compress = null;
	  var pointer = 0;
	  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

	  var char = function () {
	    return input.charAt(pointer);
	  };

	  if (char() == ':') {
	    if (input.charAt(1) != ':') return;
	    pointer += 2;
	    pieceIndex++;
	    compress = pieceIndex;
	  }
	  while (char()) {
	    if (pieceIndex == 8) return;
	    if (char() == ':') {
	      if (compress !== null) return;
	      pointer++;
	      pieceIndex++;
	      compress = pieceIndex;
	      continue;
	    }
	    value = length = 0;
	    while (length < 4 && HEX.test(char())) {
	      value = value * 16 + parseInt(char(), 16);
	      pointer++;
	      length++;
	    }
	    if (char() == '.') {
	      if (length == 0) return;
	      pointer -= length;
	      if (pieceIndex > 6) return;
	      numbersSeen = 0;
	      while (char()) {
	        ipv4Piece = null;
	        if (numbersSeen > 0) {
	          if (char() == '.' && numbersSeen < 4) pointer++;
	          else return;
	        }
	        if (!DIGIT.test(char())) return;
	        while (DIGIT.test(char())) {
	          number = parseInt(char(), 10);
	          if (ipv4Piece === null) ipv4Piece = number;
	          else if (ipv4Piece == 0) return;
	          else ipv4Piece = ipv4Piece * 10 + number;
	          if (ipv4Piece > 255) return;
	          pointer++;
	        }
	        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
	        numbersSeen++;
	        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
	      }
	      if (numbersSeen != 4) return;
	      break;
	    } else if (char() == ':') {
	      pointer++;
	      if (!char()) return;
	    } else if (char()) return;
	    address[pieceIndex++] = value;
	  }
	  if (compress !== null) {
	    swaps = pieceIndex - compress;
	    pieceIndex = 7;
	    while (pieceIndex != 0 && swaps > 0) {
	      swap = address[pieceIndex];
	      address[pieceIndex--] = address[compress + swaps - 1];
	      address[compress + --swaps] = swap;
	    }
	  } else if (pieceIndex != 8) return;
	  return address;
	};

	var findLongestZeroSequence = function (ipv6) {
	  var maxIndex = null;
	  var maxLength = 1;
	  var currStart = null;
	  var currLength = 0;
	  var index = 0;
	  for (; index < 8; index++) {
	    if (ipv6[index] !== 0) {
	      if (currLength > maxLength) {
	        maxIndex = currStart;
	        maxLength = currLength;
	      }
	      currStart = null;
	      currLength = 0;
	    } else {
	      if (currStart === null) currStart = index;
	      ++currLength;
	    }
	  }
	  if (currLength > maxLength) {
	    maxIndex = currStart;
	    maxLength = currLength;
	  }
	  return maxIndex;
	};

	var serializeHost = function (host) {
	  var result, index, compress, ignore0;
	  // ipv4
	  if (typeof host == 'number') {
	    result = [];
	    for (index = 0; index < 4; index++) {
	      result.unshift(host % 256);
	      host = floor$9(host / 256);
	    } return result.join('.');
	  // ipv6
	  } else if (typeof host == 'object') {
	    result = '';
	    compress = findLongestZeroSequence(host);
	    for (index = 0; index < 8; index++) {
	      if (ignore0 && host[index] === 0) continue;
	      if (ignore0) ignore0 = false;
	      if (compress === index) {
	        result += index ? ':' : '::';
	        ignore0 = true;
	      } else {
	        result += host[index].toString(16);
	        if (index < 7) result += ':';
	      }
	    }
	    return '[' + result + ']';
	  } return host;
	};

	var C0ControlPercentEncodeSet = {};
	var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
	  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
	});
	var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
	  '#': 1, '?': 1, '{': 1, '}': 1
	});
	var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
	  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
	});

	var percentEncode = function (char, set) {
	  var code = codeAt$1(char, 0);
	  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
	};

	var specialSchemes = {
	  ftp: 21,
	  file: null,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443
	};

	var isSpecial = function (url) {
	  return has(specialSchemes, url.scheme);
	};

	var includesCredentials = function (url) {
	  return url.username != '' || url.password != '';
	};

	var cannotHaveUsernamePasswordPort = function (url) {
	  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
	};

	var isWindowsDriveLetter = function (string, normalized) {
	  var second;
	  return string.length == 2 && ALPHA.test(string.charAt(0))
	    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
	};

	var startsWithWindowsDriveLetter = function (string) {
	  var third;
	  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
	    string.length == 2 ||
	    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
	  );
	};

	var shortenURLsPath = function (url) {
	  var path = url.path;
	  var pathSize = path.length;
	  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
	    path.pop();
	  }
	};

	var isSingleDot = function (segment) {
	  return segment === '.' || segment.toLowerCase() === '%2e';
	};

	var isDoubleDot = function (segment) {
	  segment = segment.toLowerCase();
	  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
	};

	// States:
	var SCHEME_START = {};
	var SCHEME = {};
	var NO_SCHEME = {};
	var SPECIAL_RELATIVE_OR_AUTHORITY = {};
	var PATH_OR_AUTHORITY = {};
	var RELATIVE = {};
	var RELATIVE_SLASH = {};
	var SPECIAL_AUTHORITY_SLASHES = {};
	var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
	var AUTHORITY = {};
	var HOST = {};
	var HOSTNAME = {};
	var PORT = {};
	var FILE = {};
	var FILE_SLASH = {};
	var FILE_HOST = {};
	var PATH_START = {};
	var PATH = {};
	var CANNOT_BE_A_BASE_URL_PATH = {};
	var QUERY = {};
	var FRAGMENT = {};

	// eslint-disable-next-line max-statements
	var parseURL = function (url, input, stateOverride, base) {
	  var state = stateOverride || SCHEME_START;
	  var pointer = 0;
	  var buffer = '';
	  var seenAt = false;
	  var seenBracket = false;
	  var seenPasswordToken = false;
	  var codePoints, char, bufferCodePoints, failure;

	  if (!stateOverride) {
	    url.scheme = '';
	    url.username = '';
	    url.password = '';
	    url.host = null;
	    url.port = null;
	    url.path = [];
	    url.query = null;
	    url.fragment = null;
	    url.cannotBeABaseURL = false;
	    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
	  }

	  input = input.replace(TAB_AND_NEW_LINE, '');

	  codePoints = arrayFrom(input);

	  while (pointer <= codePoints.length) {
	    char = codePoints[pointer];
	    switch (state) {
	      case SCHEME_START:
	        if (char && ALPHA.test(char)) {
	          buffer += char.toLowerCase();
	          state = SCHEME;
	        } else if (!stateOverride) {
	          state = NO_SCHEME;
	          continue;
	        } else return INVALID_SCHEME;
	        break;

	      case SCHEME:
	        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
	          buffer += char.toLowerCase();
	        } else if (char == ':') {
	          if (stateOverride && (
	            (isSpecial(url) != has(specialSchemes, buffer)) ||
	            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
	            (url.scheme == 'file' && !url.host)
	          )) return;
	          url.scheme = buffer;
	          if (stateOverride) {
	            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
	            return;
	          }
	          buffer = '';
	          if (url.scheme == 'file') {
	            state = FILE;
	          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
	            state = SPECIAL_RELATIVE_OR_AUTHORITY;
	          } else if (isSpecial(url)) {
	            state = SPECIAL_AUTHORITY_SLASHES;
	          } else if (codePoints[pointer + 1] == '/') {
	            state = PATH_OR_AUTHORITY;
	            pointer++;
	          } else {
	            url.cannotBeABaseURL = true;
	            url.path.push('');
	            state = CANNOT_BE_A_BASE_URL_PATH;
	          }
	        } else if (!stateOverride) {
	          buffer = '';
	          state = NO_SCHEME;
	          pointer = 0;
	          continue;
	        } else return INVALID_SCHEME;
	        break;

	      case NO_SCHEME:
	        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
	        if (base.cannotBeABaseURL && char == '#') {
	          url.scheme = base.scheme;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          url.cannotBeABaseURL = true;
	          state = FRAGMENT;
	          break;
	        }
	        state = base.scheme == 'file' ? FILE : RELATIVE;
	        continue;

	      case SPECIAL_RELATIVE_OR_AUTHORITY:
	        if (char == '/' && codePoints[pointer + 1] == '/') {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          pointer++;
	        } else {
	          state = RELATIVE;
	          continue;
	        } break;

	      case PATH_OR_AUTHORITY:
	        if (char == '/') {
	          state = AUTHORITY;
	          break;
	        } else {
	          state = PATH;
	          continue;
	        }

	      case RELATIVE:
	        url.scheme = base.scheme;
	        if (char == EOF) {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
	          state = RELATIVE_SLASH;
	        } else if (char == '?') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = '';
	          state = QUERY;
	        } else if (char == '#') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          state = FRAGMENT;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.path.pop();
	          state = PATH;
	          continue;
	        } break;

	      case RELATIVE_SLASH:
	        if (isSpecial(url) && (char == '/' || char == '\\')) {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        } else if (char == '/') {
	          state = AUTHORITY;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          state = PATH;
	          continue;
	        } break;

	      case SPECIAL_AUTHORITY_SLASHES:
	        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
	        pointer++;
	        break;

	      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
	        if (char != '/' && char != '\\') {
	          state = AUTHORITY;
	          continue;
	        } break;

	      case AUTHORITY:
	        if (char == '@') {
	          if (seenAt) buffer = '%40' + buffer;
	          seenAt = true;
	          bufferCodePoints = arrayFrom(buffer);
	          for (var i = 0; i < bufferCodePoints.length; i++) {
	            var codePoint = bufferCodePoints[i];
	            if (codePoint == ':' && !seenPasswordToken) {
	              seenPasswordToken = true;
	              continue;
	            }
	            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
	            if (seenPasswordToken) url.password += encodedCodePoints;
	            else url.username += encodedCodePoints;
	          }
	          buffer = '';
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url))
	        ) {
	          if (seenAt && buffer == '') return INVALID_AUTHORITY;
	          pointer -= arrayFrom(buffer).length + 1;
	          buffer = '';
	          state = HOST;
	        } else buffer += char;
	        break;

	      case HOST:
	      case HOSTNAME:
	        if (stateOverride && url.scheme == 'file') {
	          state = FILE_HOST;
	          continue;
	        } else if (char == ':' && !seenBracket) {
	          if (buffer == '') return INVALID_HOST;
	          failure = parseHost(url, buffer);
	          if (failure) return failure;
	          buffer = '';
	          state = PORT;
	          if (stateOverride == HOSTNAME) return;
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url))
	        ) {
	          if (isSpecial(url) && buffer == '') return INVALID_HOST;
	          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
	          failure = parseHost(url, buffer);
	          if (failure) return failure;
	          buffer = '';
	          state = PATH_START;
	          if (stateOverride) return;
	          continue;
	        } else {
	          if (char == '[') seenBracket = true;
	          else if (char == ']') seenBracket = false;
	          buffer += char;
	        } break;

	      case PORT:
	        if (DIGIT.test(char)) {
	          buffer += char;
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url)) ||
	          stateOverride
	        ) {
	          if (buffer != '') {
	            var port = parseInt(buffer, 10);
	            if (port > 0xFFFF) return INVALID_PORT;
	            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
	            buffer = '';
	          }
	          if (stateOverride) return;
	          state = PATH_START;
	          continue;
	        } else return INVALID_PORT;
	        break;

	      case FILE:
	        url.scheme = 'file';
	        if (char == '/' || char == '\\') state = FILE_SLASH;
	        else if (base && base.scheme == 'file') {
	          if (char == EOF) {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	          } else if (char == '?') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = '';
	            state = QUERY;
	          } else if (char == '#') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	            url.fragment = '';
	            state = FRAGMENT;
	          } else {
	            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	              url.host = base.host;
	              url.path = base.path.slice();
	              shortenURLsPath(url);
	            }
	            state = PATH;
	            continue;
	          }
	        } else {
	          state = PATH;
	          continue;
	        } break;

	      case FILE_SLASH:
	        if (char == '/' || char == '\\') {
	          state = FILE_HOST;
	          break;
	        }
	        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
	          else url.host = base.host;
	        }
	        state = PATH;
	        continue;

	      case FILE_HOST:
	        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
	          if (!stateOverride && isWindowsDriveLetter(buffer)) {
	            state = PATH;
	          } else if (buffer == '') {
	            url.host = '';
	            if (stateOverride) return;
	            state = PATH_START;
	          } else {
	            failure = parseHost(url, buffer);
	            if (failure) return failure;
	            if (url.host == 'localhost') url.host = '';
	            if (stateOverride) return;
	            buffer = '';
	            state = PATH_START;
	          } continue;
	        } else buffer += char;
	        break;

	      case PATH_START:
	        if (isSpecial(url)) {
	          state = PATH;
	          if (char != '/' && char != '\\') continue;
	        } else if (!stateOverride && char == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (!stateOverride && char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          state = PATH;
	          if (char != '/') continue;
	        } break;

	      case PATH:
	        if (
	          char == EOF || char == '/' ||
	          (char == '\\' && isSpecial(url)) ||
	          (!stateOverride && (char == '?' || char == '#'))
	        ) {
	          if (isDoubleDot(buffer)) {
	            shortenURLsPath(url);
	            if (char != '/' && !(char == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else if (isSingleDot(buffer)) {
	            if (char != '/' && !(char == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else {
	            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
	              if (url.host) url.host = '';
	              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
	            }
	            url.path.push(buffer);
	          }
	          buffer = '';
	          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
	            while (url.path.length > 1 && url.path[0] === '') {
	              url.path.shift();
	            }
	          }
	          if (char == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (char == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          }
	        } else {
	          buffer += percentEncode(char, pathPercentEncodeSet);
	        } break;

	      case CANNOT_BE_A_BASE_URL_PATH:
	        if (char == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
	        } break;

	      case QUERY:
	        if (!stateOverride && char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          if (char == "'" && isSpecial(url)) url.query += '%27';
	          else if (char == '#') url.query += '%23';
	          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
	        } break;

	      case FRAGMENT:
	        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
	        break;
	    }

	    pointer++;
	  }
	};

	// `URL` constructor
	// https://url.spec.whatwg.org/#url-class
	var URLConstructor = function URL(url /* , base */) {
	  var that = anInstance(this, URLConstructor, 'URL');
	  var base = arguments.length > 1 ? arguments[1] : undefined;
	  var urlString = String(url);
	  var state = setInternalState$a(that, { type: 'URL' });
	  var baseState, failure;
	  if (base !== undefined) {
	    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
	    else {
	      failure = parseURL(baseState = {}, String(base));
	      if (failure) throw TypeError(failure);
	    }
	  }
	  failure = parseURL(state, urlString, null, baseState);
	  if (failure) throw TypeError(failure);
	  var searchParams = state.searchParams = new URLSearchParams$1();
	  var searchParamsState = getInternalSearchParamsState(searchParams);
	  searchParamsState.updateSearchParams(state.query);
	  searchParamsState.updateURL = function () {
	    state.query = String(searchParams) || null;
	  };
	  if (!descriptors) {
	    that.href = serializeURL.call(that);
	    that.origin = getOrigin.call(that);
	    that.protocol = getProtocol.call(that);
	    that.username = getUsername.call(that);
	    that.password = getPassword.call(that);
	    that.host = getHost.call(that);
	    that.hostname = getHostname.call(that);
	    that.port = getPort.call(that);
	    that.pathname = getPathname.call(that);
	    that.search = getSearch.call(that);
	    that.searchParams = getSearchParams.call(that);
	    that.hash = getHash.call(that);
	  }
	};

	var URLPrototype = URLConstructor.prototype;

	var serializeURL = function () {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var username = url.username;
	  var password = url.password;
	  var host = url.host;
	  var port = url.port;
	  var path = url.path;
	  var query = url.query;
	  var fragment = url.fragment;
	  var output = scheme + ':';
	  if (host !== null) {
	    output += '//';
	    if (includesCredentials(url)) {
	      output += username + (password ? ':' + password : '') + '@';
	    }
	    output += serializeHost(host);
	    if (port !== null) output += ':' + port;
	  } else if (scheme == 'file') output += '//';
	  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	  if (query !== null) output += '?' + query;
	  if (fragment !== null) output += '#' + fragment;
	  return output;
	};

	var getOrigin = function () {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var port = url.port;
	  if (scheme == 'blob') try {
	    return new URL(scheme.path[0]).origin;
	  } catch (error) {
	    return 'null';
	  }
	  if (scheme == 'file' || !isSpecial(url)) return 'null';
	  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
	};

	var getProtocol = function () {
	  return getInternalURLState(this).scheme + ':';
	};

	var getUsername = function () {
	  return getInternalURLState(this).username;
	};

	var getPassword = function () {
	  return getInternalURLState(this).password;
	};

	var getHost = function () {
	  var url = getInternalURLState(this);
	  var host = url.host;
	  var port = url.port;
	  return host === null ? ''
	    : port === null ? serializeHost(host)
	    : serializeHost(host) + ':' + port;
	};

	var getHostname = function () {
	  var host = getInternalURLState(this).host;
	  return host === null ? '' : serializeHost(host);
	};

	var getPort = function () {
	  var port = getInternalURLState(this).port;
	  return port === null ? '' : String(port);
	};

	var getPathname = function () {
	  var url = getInternalURLState(this);
	  var path = url.path;
	  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	};

	var getSearch = function () {
	  var query = getInternalURLState(this).query;
	  return query ? '?' + query : '';
	};

	var getSearchParams = function () {
	  return getInternalURLState(this).searchParams;
	};

	var getHash = function () {
	  var fragment = getInternalURLState(this).fragment;
	  return fragment ? '#' + fragment : '';
	};

	var accessorDescriptor = function (getter, setter) {
	  return { get: getter, set: setter, configurable: true, enumerable: true };
	};

	if (descriptors) {
	  objectDefineProperties(URLPrototype, {
	    // `URL.prototype.href` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-href
	    href: accessorDescriptor(serializeURL, function (href) {
	      var url = getInternalURLState(this);
	      var urlString = String(href);
	      var failure = parseURL(url, urlString);
	      if (failure) throw TypeError(failure);
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.origin` getter
	    // https://url.spec.whatwg.org/#dom-url-origin
	    origin: accessorDescriptor(getOrigin),
	    // `URL.prototype.protocol` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-protocol
	    protocol: accessorDescriptor(getProtocol, function (protocol) {
	      var url = getInternalURLState(this);
	      parseURL(url, String(protocol) + ':', SCHEME_START);
	    }),
	    // `URL.prototype.username` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-username
	    username: accessorDescriptor(getUsername, function (username) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(username));
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      url.username = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.password` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-password
	    password: accessorDescriptor(getPassword, function (password) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(password));
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      url.password = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.host` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-host
	    host: accessorDescriptor(getHost, function (host) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      parseURL(url, String(host), HOST);
	    }),
	    // `URL.prototype.hostname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hostname
	    hostname: accessorDescriptor(getHostname, function (hostname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      parseURL(url, String(hostname), HOSTNAME);
	    }),
	    // `URL.prototype.port` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-port
	    port: accessorDescriptor(getPort, function (port) {
	      var url = getInternalURLState(this);
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      port = String(port);
	      if (port == '') url.port = null;
	      else parseURL(url, port, PORT);
	    }),
	    // `URL.prototype.pathname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-pathname
	    pathname: accessorDescriptor(getPathname, function (pathname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      url.path = [];
	      parseURL(url, pathname + '', PATH_START);
	    }),
	    // `URL.prototype.search` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-search
	    search: accessorDescriptor(getSearch, function (search) {
	      var url = getInternalURLState(this);
	      search = String(search);
	      if (search == '') {
	        url.query = null;
	      } else {
	        if ('?' == search.charAt(0)) search = search.slice(1);
	        url.query = '';
	        parseURL(url, search, QUERY);
	      }
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.searchParams` getter
	    // https://url.spec.whatwg.org/#dom-url-searchparams
	    searchParams: accessorDescriptor(getSearchParams),
	    // `URL.prototype.hash` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hash
	    hash: accessorDescriptor(getHash, function (hash) {
	      var url = getInternalURLState(this);
	      hash = String(hash);
	      if (hash == '') {
	        url.fragment = null;
	        return;
	      }
	      if ('#' == hash.charAt(0)) hash = hash.slice(1);
	      url.fragment = '';
	      parseURL(url, hash, FRAGMENT);
	    })
	  });
	}

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	redefine(URLPrototype, 'toJSON', function toJSON() {
	  return serializeURL.call(this);
	}, { enumerable: true });

	// `URL.prototype.toString` method
	// https://url.spec.whatwg.org/#URL-stringification-behavior
	redefine(URLPrototype, 'toString', function toString() {
	  return serializeURL.call(this);
	}, { enumerable: true });

	if (NativeURL) {
	  var nativeCreateObjectURL = NativeURL.createObjectURL;
	  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
	  // `URL.createObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
	  // eslint-disable-next-line no-unused-vars
	  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
	    return nativeCreateObjectURL.apply(NativeURL, arguments);
	  });
	  // `URL.revokeObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
	  // eslint-disable-next-line no-unused-vars
	  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
	    return nativeRevokeObjectURL.apply(NativeURL, arguments);
	  });
	}

	setToStringTag(URLConstructor, 'URL');

	_export({ global: true, forced: !nativeUrl, sham: !descriptors }, {
	  URL: URLConstructor
	});

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	_export({ target: 'URL', proto: true, enumerable: true }, {
	  toJSON: function toJSON() {
	    return URL.prototype.toString.call(this);
	  }
	});

	var defineProperty$c = objectDefineProperty.f;

	// `Array.prototype.lastIndex` getter
	// https://github.com/keithamus/proposal-array-last
	if (descriptors && !('lastIndex' in [])) {
	  defineProperty$c(Array.prototype, 'lastIndex', {
	    configurable: true,
	    get: function lastIndex() {
	      var O = toObject(this);
	      var len = toLength(O.length);
	      return len == 0 ? 0 : len - 1;
	    }
	  });

	  addToUnscopables('lastIndex');
	}

	var defineProperty$d = objectDefineProperty.f;

	// `Array.prototype.lastIndex` accessor
	// https://github.com/keithamus/proposal-array-last
	if (descriptors && !('lastItem' in [])) {
	  defineProperty$d(Array.prototype, 'lastItem', {
	    configurable: true,
	    get: function lastItem() {
	      var O = toObject(this);
	      var len = toLength(O.length);
	      return len == 0 ? undefined : O[len - 1];
	    },
	    set: function lastItem(value) {
	      var O = toObject(this);
	      var len = toLength(O.length);
	      return O[len == 0 ? 0 : len - 1] = value;
	    }
	  });

	  addToUnscopables('lastItem');
	}

	// `Map.groupBy` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', stat: true }, {
	  groupBy: function groupBy(iterable, keyDerivative) {
	    var newMap = new this();
	    aFunction$1(keyDerivative);
	    var has = aFunction$1(newMap.has);
	    var get = aFunction$1(newMap.get);
	    var set = aFunction$1(newMap.set);
	    iterate_1(iterable, function (element) {
	      var derivedKey = keyDerivative(element);
	      if (!has.call(newMap, derivedKey)) set.call(newMap, derivedKey, [element]);
	      else get.call(newMap, derivedKey).push(element);
	    });
	    return newMap;
	  }
	});

	// `Map.keyBy` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', stat: true }, {
	  keyBy: function keyBy(iterable, keyDerivative) {
	    var newMap = new this();
	    aFunction$1(keyDerivative);
	    var setter = aFunction$1(newMap.set);
	    iterate_1(iterable, function (element) {
	      setter.call(newMap, keyDerivative(element), element);
	    });
	    return newMap;
	  }
	});

	// https://github.com/tc39/collection-methods
	var collectionDeleteAll = function (/* ...elements */) {
	  var collection = anObject(this);
	  var remover = aFunction$1(collection['delete']);
	  var allDeleted = true;
	  var wasDeleted;
	  for (var k = 0, len = arguments.length; k < len; k++) {
	    wasDeleted = remover.call(collection, arguments[k]);
	    allDeleted = allDeleted && wasDeleted;
	  }
	  return !!allDeleted;
	};

	// `Map.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  deleteAll: function deleteAll(/* ...elements */) {
	    return collectionDeleteAll.apply(this, arguments);
	  }
	});

	var getMapIterator =  function (it) {
	  // eslint-disable-next-line no-undef
	  return Map.prototype.entries.call(it);
	};

	// `Map.prototype.every` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  every: function every(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return !iterate_1(iterator, function (key, value) {
	      if (!boundFunction(value, key, map)) return iterate_1.stop();
	    }, undefined, true, true).stopped;
	  }
	});

	// `Map.prototype.filter` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aFunction$1(newMap.set);
	    iterate_1(iterator, function (key, value) {
	      if (boundFunction(value, key, map)) setter.call(newMap, key, value);
	    }, undefined, true, true);
	    return newMap;
	  }
	});

	// `Map.prototype.find` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  find: function find(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return iterate_1(iterator, function (key, value) {
	      if (boundFunction(value, key, map)) return iterate_1.stop(value);
	    }, undefined, true, true).result;
	  }
	});

	// `Map.prototype.findKey` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  findKey: function findKey(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return iterate_1(iterator, function (key, value) {
	      if (boundFunction(value, key, map)) return iterate_1.stop(key);
	    }, undefined, true, true).result;
	  }
	});

	// `SameValueZero` abstract operation
	// https://tc39.github.io/ecma262/#sec-samevaluezero
	var sameValueZero = function (x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y || x != x && y != y;
	};

	// `Map.prototype.includes` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  includes: function includes(searchElement) {
	    return iterate_1(getMapIterator(anObject(this)), function (key, value) {
	      if (sameValueZero(value, searchElement)) return iterate_1.stop();
	    }, undefined, true, true).stopped;
	  }
	});

	// `Map.prototype.includes` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  keyOf: function keyOf(searchElement) {
	    return iterate_1(getMapIterator(anObject(this)), function (key, value) {
	      if (value === searchElement) return iterate_1.stop(key);
	    }, undefined, true, true).result;
	  }
	});

	// `Map.prototype.mapKeys` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  mapKeys: function mapKeys(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aFunction$1(newMap.set);
	    iterate_1(iterator, function (key, value) {
	      setter.call(newMap, boundFunction(value, key, map), value);
	    }, undefined, true, true);
	    return newMap;
	  }
	});

	// `Map.prototype.mapValues` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  mapValues: function mapValues(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aFunction$1(newMap.set);
	    iterate_1(iterator, function (key, value) {
	      setter.call(newMap, key, boundFunction(value, key, map));
	    }, undefined, true, true);
	    return newMap;
	  }
	});

	// `Map.prototype.merge` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  // eslint-disable-next-line no-unused-vars
	  merge: function merge(iterable /* ...iterbles */) {
	    var map = anObject(this);
	    var setter = aFunction$1(map.set);
	    var i = 0;
	    while (i < arguments.length) {
	      iterate_1(arguments[i++], setter, map, true);
	    }
	    return map;
	  }
	});

	// `Map.prototype.reduce` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    aFunction$1(callbackfn);
	    iterate_1(iterator, function (key, value) {
	      if (noInitial) {
	        noInitial = false;
	        accumulator = value;
	      } else {
	        accumulator = callbackfn(accumulator, value, key, map);
	      }
	    }, undefined, true, true);
	    if (noInitial) throw TypeError('Reduce of empty map with no initial value');
	    return accumulator;
	  }
	});

	// `Set.prototype.some` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  some: function some(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return iterate_1(iterator, function (key, value) {
	      if (boundFunction(value, key, map)) return iterate_1.stop();
	    }, undefined, true, true).stopped;
	  }
	});

	// `Set.prototype.update` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  update: function update(key, callback /* , thunk */) {
	    var map = anObject(this);
	    var length = arguments.length;
	    aFunction$1(callback);
	    var isPresentInMap = map.has(key);
	    if (!isPresentInMap && length < 3) {
	      throw TypeError('Updating absent value');
	    }
	    var value = isPresentInMap ? map.get(key) : aFunction$1(length > 2 ? arguments[2] : undefined)(key, map);
	    map.set(key, callback(value, key, map));
	    return map;
	  }
	});

	// https://github.com/tc39/collection-methods
	var collectionAddAll = function (/* ...elements */) {
	  var set = anObject(this);
	  var adder = aFunction$1(set.add);
	  for (var k = 0, len = arguments.length; k < len; k++) {
	    adder.call(set, arguments[k]);
	  }
	  return set;
	};

	// `Set.prototype.addAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  addAll: function addAll(/* ...elements */) {
	    return collectionAddAll.apply(this, arguments);
	  }
	});

	// `Set.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  deleteAll: function deleteAll(/* ...elements */) {
	    return collectionDeleteAll.apply(this, arguments);
	  }
	});

	var getSetIterator =  function (it) {
	  // eslint-disable-next-line no-undef
	  return Set.prototype.values.call(it);
	};

	// `Set.prototype.every` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  every: function every(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return !iterate_1(iterator, function (value) {
	      if (!boundFunction(value, value, set)) return iterate_1.stop();
	    }, undefined, false, true).stopped;
	  }
	});

	// `Set.prototype.filter` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
	    var adder = aFunction$1(newSet.add);
	    iterate_1(iterator, function (value) {
	      if (boundFunction(value, value, set)) adder.call(newSet, value);
	    }, undefined, false, true);
	    return newSet;
	  }
	});

	// `Set.prototype.find` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  find: function find(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return iterate_1(iterator, function (value) {
	      if (boundFunction(value, value, set)) return iterate_1.stop(value);
	    }, undefined, false, true).result;
	  }
	});

	// `Set.prototype.join` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  join: function join(separator) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var sep = separator === undefined ? ',' : String(separator);
	    var result = [];
	    iterate_1(iterator, result.push, result, false, true);
	    return result.join(sep);
	  }
	});

	// `Set.prototype.map` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  map: function map(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
	    var adder = aFunction$1(newSet.add);
	    iterate_1(iterator, function (value) {
	      adder.call(newSet, boundFunction(value, value, set));
	    }, undefined, false, true);
	    return newSet;
	  }
	});

	// `Set.prototype.reduce` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    aFunction$1(callbackfn);
	    iterate_1(iterator, function (value) {
	      if (noInitial) {
	        noInitial = false;
	        accumulator = value;
	      } else {
	        accumulator = callbackfn(accumulator, value, value, set);
	      }
	    }, undefined, false, true);
	    if (noInitial) throw TypeError('Reduce of empty set with no initial value');
	    return accumulator;
	  }
	});

	// `Set.prototype.some` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  some: function some(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return iterate_1(iterator, function (value) {
	      if (boundFunction(value, value, set)) return iterate_1.stop();
	    }, undefined, false, true).stopped;
	  }
	});

	// `WeakMap.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'WeakMap', proto: true, real: true, forced: isPure }, {
	  deleteAll: function deleteAll(/* ...elements */) {
	    return collectionDeleteAll.apply(this, arguments);
	  }
	});

	// `WeakSet.prototype.addAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'WeakSet', proto: true, real: true, forced: isPure }, {
	  addAll: function addAll(/* ...elements */) {
	    return collectionAddAll.apply(this, arguments);
	  }
	});

	// `WeakSet.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'WeakSet', proto: true, real: true, forced: isPure }, {
	  deleteAll: function deleteAll(/* ...elements */) {
	    return collectionDeleteAll.apply(this, arguments);
	  }
	});

	// https://tc39.github.io/proposal-setmap-offrom/




	var collectionFrom = function from(source /* , mapFn, thisArg */) {
	  var length = arguments.length;
	  var mapFn = length > 1 ? arguments[1] : undefined;
	  var mapping, A, n, boundFunction;
	  aFunction$1(this);
	  mapping = mapFn !== undefined;
	  if (mapping) aFunction$1(mapFn);
	  if (source == undefined) return new this();
	  A = [];
	  if (mapping) {
	    n = 0;
	    boundFunction = functionBindContext(mapFn, length > 2 ? arguments[2] : undefined, 2);
	    iterate_1(source, function (nextItem) {
	      A.push(boundFunction(nextItem, n++));
	    });
	  } else {
	    iterate_1(source, A.push, A);
	  }
	  return new this(A);
	};

	// `Map.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	_export({ target: 'Map', stat: true }, {
	  from: collectionFrom
	});

	// https://tc39.github.io/proposal-setmap-offrom/
	var collectionOf = function of() {
	  var length = arguments.length;
	  var A = new Array(length);
	  while (length--) A[length] = arguments[length];
	  return new this(A);
	};

	// `Map.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	_export({ target: 'Map', stat: true }, {
	  of: collectionOf
	});

	// `Set.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	_export({ target: 'Set', stat: true }, {
	  from: collectionFrom
	});

	// `Set.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	_export({ target: 'Set', stat: true }, {
	  of: collectionOf
	});

	// `WeakMap.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	_export({ target: 'WeakMap', stat: true }, {
	  from: collectionFrom
	});

	// `WeakMap.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	_export({ target: 'WeakMap', stat: true }, {
	  of: collectionOf
	});

	// `WeakSet.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	_export({ target: 'WeakSet', stat: true }, {
	  from: collectionFrom
	});

	// `WeakSet.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	_export({ target: 'WeakSet', stat: true }, {
	  of: collectionOf
	});

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`





	var Node$1 = function () {
	  // keys
	  this.object = null;
	  this.symbol = null;
	  // child nodes
	  this.primitives = null;
	  this.objectsByIndex = objectCreate(null);
	};

	Node$1.prototype.get = function (key, initializer) {
	  return this[key] || (this[key] = initializer());
	};

	Node$1.prototype.next = function (i, it, IS_OBJECT) {
	  var store = IS_OBJECT
	    ? this.objectsByIndex[i] || (this.objectsByIndex[i] = new es_weakMap())
	    : this.primitives || (this.primitives = new es_map());
	  var entry = store.get(it);
	  if (!entry) store.set(it, entry = new Node$1());
	  return entry;
	};

	var root = new Node$1();

	var compositeKey = function () {
	  var active = root;
	  var length = arguments.length;
	  var i, it;
	  // for prevent leaking, start from objects
	  for (i = 0; i < length; i++) {
	    if (isObject(it = arguments[i])) active = active.next(i, it, true);
	  }
	  if (this === Object && active === root) throw TypeError('Composite keys must contain a non-primitive component');
	  for (i = 0; i < length; i++) {
	    if (!isObject(it = arguments[i])) active = active.next(i, it, false);
	  } return active;
	};

	var initializer = function () {
	  var freeze = getBuiltIn('Object', 'freeze');
	  return freeze ? freeze(objectCreate(null)) : objectCreate(null);
	};

	// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
	_export({ global: true }, {
	  compositeKey: function compositeKey$1() {
	    return compositeKey.apply(Object, arguments).get('object', initializer);
	  }
	});

	// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
	_export({ global: true }, {
	  compositeSymbol: function compositeSymbol() {
	    if (arguments.length === 1 && typeof arguments[0] === 'string') return getBuiltIn('Symbol')['for'](arguments[0]);
	    return compositeKey.apply(null, arguments).get('symbol', getBuiltIn('Symbol'));
	  }
	});

	var min$9 = Math.min;
	var max$4 = Math.max;

	// `Math.clamp` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true }, {
	  clamp: function clamp(x, lower, upper) {
	    return min$9(upper, max$4(lower, x));
	  }
	});

	// `Math.DEG_PER_RAD` constant
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true }, {
	  DEG_PER_RAD: Math.PI / 180
	});

	var RAD_PER_DEG = 180 / Math.PI;

	// `Math.degrees` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true }, {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});

	// `Math.scale` method implementation
	// https://rwaldron.github.io/proposal-math-extensions/
	var mathScale = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  if (
	    arguments.length === 0
	      /* eslint-disable no-self-compare */
	      || x != x
	      || inLow != inLow
	      || inHigh != inHigh
	      || outLow != outLow
	      || outHigh != outHigh
	      /* eslint-enable no-self-compare */
	  ) return NaN;
	  if (x === Infinity || x === -Infinity) return x;
	  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
	};

	// `Math.fscale` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true }, {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return mathFround(mathScale(x, inLow, inHigh, outLow, outHigh));
	  }
	});

	// `Math.RAD_PER_DEG` constant
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true }, {
	  RAD_PER_DEG: 180 / Math.PI
	});

	var DEG_PER_RAD = Math.PI / 180;

	// `Math.radians` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true }, {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});

	// `Math.scale` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true }, {
	  scale: mathScale
	});

	// `Math.signbit` method
	// https://github.com/tc39/proposal-Math.signbit
	_export({ target: 'Math', stat: true }, {
	  signbit: function signbit(x) {
	    return (x = +x) == x && x == 0 ? 1 / x == -Infinity : x < 0;
	  }
	});

	var INVALID_NUMBER_REPRESENTATION = 'Invalid number representation';
	var INVALID_RADIX = 'Invalid radix';
	var valid = /^[\da-z]+$/;

	// `Number.fromString` method
	// https://github.com/tc39/proposal-number-fromstring
	_export({ target: 'Number', stat: true }, {
	  fromString: function fromString(string, radix) {
	    var sign = 1;
	    var R, mathNum;
	    if (typeof string != 'string') throw TypeError(INVALID_NUMBER_REPRESENTATION);
	    if (!string.length) throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
	    if (string.charAt(0) == '-') {
	      sign = -1;
	      string = string.slice(1);
	      if (!string.length) throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
	    }
	    R = radix === undefined ? 10 : toInteger(radix);
	    if (R < 2 || R > 36) throw RangeError(INVALID_RADIX);
	    if (!valid.test(string) || (mathNum = numberParseInt(string, R)).toString(R) !== string) {
	      throw SyntaxError(INVALID_NUMBER_REPRESENTATION);
	    }
	    return sign * mathNum;
	  }
	});

	var OBJECT_ITERATOR = 'Object Iterator';
	var setInternalState$b = internalState.set;
	var getInternalState$7 = internalState.getterFor(OBJECT_ITERATOR);

	var objectIterator = createIteratorConstructor(function ObjectIterator(source, mode) {
	  var object = toObject(source);
	  setInternalState$b(this, {
	    type: OBJECT_ITERATOR,
	    mode: mode,
	    object: object,
	    keys: objectKeys(object),
	    index: 0
	  });
	}, 'Object', function next() {
	  var state = getInternalState$7(this);
	  var keys = state.keys;
	  while (true) {
	    if (keys === null || state.index >= keys.length) {
	      state.object = state.keys = null;
	      return { value: undefined, done: true };
	    }
	    var key = keys[state.index++];
	    var object = state.object;
	    if (!has(object, key)) continue;
	    switch (state.mode) {
	      case 'keys': return { value: key, done: false };
	      case 'values': return { value: object[key], done: false };
	    } /* entries */ return { value: [key, object[key]], done: false };
	  }
	});

	// `Object.iterateEntries` method
	// https://github.com/tc39/proposal-object-iteration
	_export({ target: 'Object', stat: true }, {
	  iterateEntries: function iterateEntries(object) {
	    return new objectIterator(object, 'entries');
	  }
	});

	// `Object.iterateKeys` method
	// https://github.com/tc39/proposal-object-iteration
	_export({ target: 'Object', stat: true }, {
	  iterateKeys: function iterateKeys(object) {
	    return new objectIterator(object, 'keys');
	  }
	});

	// `Object.iterateValues` method
	// https://github.com/tc39/proposal-object-iteration
	_export({ target: 'Object', stat: true }, {
	  iterateValues: function iterateValues(object) {
	    return new objectIterator(object, 'values');
	  }
	});

	// https://github.com/tc39/proposal-observable







	var defineProperty$e = objectDefineProperty.f;








	var OBSERVABLE = wellKnownSymbol('observable');
	var getInternalState$8 = internalState.get;
	var setInternalState$c = internalState.set;

	var getMethod = function (fn) {
	  return fn == null ? undefined : aFunction$1(fn);
	};

	var cleanupSubscription = function (subscriptionState) {
	  var cleanup = subscriptionState.cleanup;
	  if (cleanup) {
	    subscriptionState.cleanup = undefined;
	    try {
	      cleanup();
	    } catch (error) {
	      hostReportErrors(error);
	    }
	  }
	};

	var subscriptionClosed = function (subscriptionState) {
	  return subscriptionState.observer === undefined;
	};

	var close = function (subscription, subscriptionState) {
	  if (!descriptors) {
	    subscription.closed = true;
	    var subscriptionObserver = subscriptionState.subscriptionObserver;
	    if (subscriptionObserver) subscriptionObserver.closed = true;
	  } subscriptionState.observer = undefined;
	};

	var Subscription = function (observer, subscriber) {
	  var subscriptionState = setInternalState$c(this, {
	    cleanup: undefined,
	    observer: anObject(observer),
	    subscriptionObserver: undefined
	  });
	  var start;
	  if (!descriptors) this.closed = false;
	  try {
	    if (start = getMethod(observer.start)) start.call(observer, this);
	  } catch (error) {
	    hostReportErrors(error);
	  }
	  if (subscriptionClosed(subscriptionState)) return;
	  var subscriptionObserver = subscriptionState.subscriptionObserver = new SubscriptionObserver(this);
	  try {
	    var cleanup = subscriber(subscriptionObserver);
	    var subscription = cleanup;
	    if (cleanup != null) subscriptionState.cleanup = typeof cleanup.unsubscribe === 'function'
	      ? function () { subscription.unsubscribe(); }
	      : aFunction$1(cleanup);
	  } catch (error) {
	    subscriptionObserver.error(error);
	    return;
	  } if (subscriptionClosed(subscriptionState)) cleanupSubscription(subscriptionState);
	};

	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe() {
	    var subscriptionState = getInternalState$8(this);
	    if (!subscriptionClosed(subscriptionState)) {
	      close(this, subscriptionState);
	      cleanupSubscription(subscriptionState);
	    }
	  }
	});

	if (descriptors) defineProperty$e(Subscription.prototype, 'closed', {
	  configurable: true,
	  get: function () {
	    return subscriptionClosed(getInternalState$8(this));
	  }
	});

	var SubscriptionObserver = function (subscription) {
	  setInternalState$c(this, { subscription: subscription });
	  if (!descriptors) this.closed = false;
	};

	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value) {
	    var subscriptionState = getInternalState$8(getInternalState$8(this).subscription);
	    if (!subscriptionClosed(subscriptionState)) {
	      var observer = subscriptionState.observer;
	      try {
	        var nextMethod = getMethod(observer.next);
	        if (nextMethod) nextMethod.call(observer, value);
	      } catch (error) {
	        hostReportErrors(error);
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = getInternalState$8(this).subscription;
	    var subscriptionState = getInternalState$8(subscription);
	    if (!subscriptionClosed(subscriptionState)) {
	      var observer = subscriptionState.observer;
	      close(subscription, subscriptionState);
	      try {
	        var errorMethod = getMethod(observer.error);
	        if (errorMethod) errorMethod.call(observer, value);
	        else hostReportErrors(value);
	      } catch (err) {
	        hostReportErrors(err);
	      } cleanupSubscription(subscriptionState);
	    }
	  },
	  complete: function complete() {
	    var subscription = getInternalState$8(this).subscription;
	    var subscriptionState = getInternalState$8(subscription);
	    if (!subscriptionClosed(subscriptionState)) {
	      var observer = subscriptionState.observer;
	      close(subscription, subscriptionState);
	      try {
	        var completeMethod = getMethod(observer.complete);
	        if (completeMethod) completeMethod.call(observer);
	      } catch (error) {
	        hostReportErrors(error);
	      } cleanupSubscription(subscriptionState);
	    }
	  }
	});

	if (descriptors) defineProperty$e(SubscriptionObserver.prototype, 'closed', {
	  configurable: true,
	  get: function () {
	    return subscriptionClosed(getInternalState$8(getInternalState$8(this).subscription));
	  }
	});

	var $Observable = function Observable(subscriber) {
	  anInstance(this, $Observable, 'Observable');
	  setInternalState$c(this, { subscriber: aFunction$1(subscriber) });
	};

	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    var length = arguments.length;
	    return new Subscription(typeof observer === 'function' ? {
	      next: observer,
	      error: length > 1 ? arguments[1] : undefined,
	      complete: length > 2 ? arguments[2] : undefined
	    } : isObject(observer) ? observer : {}, getInternalState$8(this).subscriber);
	  }
	});

	redefineAll($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var observableMethod = getMethod(anObject(x)[OBSERVABLE]);
	    if (observableMethod) {
	      var observable = anObject(observableMethod.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    var iterator = getIterator(x);
	    return new C(function (observer) {
	      iterate_1(iterator, function (it) {
	        observer.next(it);
	        if (observer.closed) return iterate_1.stop();
	      }, undefined, false, true);
	      observer.complete();
	    });
	  },
	  of: function of() {
	    var C = typeof this === 'function' ? this : $Observable;
	    var length = arguments.length;
	    var items = new Array(length);
	    var index = 0;
	    while (index < length) items[index] = arguments[index++];
	    return new C(function (observer) {
	      for (var i = 0; i < length; i++) {
	        observer.next(items[i]);
	        if (observer.closed) return;
	      } observer.complete();
	    });
	  }
	});

	createNonEnumerableProperty($Observable.prototype, OBSERVABLE, function () { return this; });

	_export({ global: true }, {
	  Observable: $Observable
	});

	setSpecies('Observable');

	// `Symbol.observable` well-known symbol
	// https://github.com/tc39/proposal-observable
	defineWellKnownSymbol('observable');

	// `Symbol.patternMatch` well-known symbol
	// https://github.com/tc39/proposal-pattern-matching
	defineWellKnownSymbol('patternMatch');

	// `Promise.try` method
	// https://github.com/tc39/proposal-promise-try
	_export({ target: 'Promise', stat: true }, {
	  'try': function (callbackfn) {
	    var promiseCapability = newPromiseCapability.f(this);
	    var result = perform(callbackfn);
	    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
	    return promiseCapability.promise;
	  }
	});

	var SEEDED_RANDOM = 'Seeded Random';
	var SEEDED_RANDOM_GENERATOR = SEEDED_RANDOM + ' Generator';
	var setInternalState$d = internalState.set;
	var getInternalState$9 = internalState.getterFor(SEEDED_RANDOM_GENERATOR);
	var SEED_TYPE_ERROR = 'Math.seededPRNG() argument should have a "seed" field with a finite value.';

	var $SeededRandomGenerator = createIteratorConstructor(function SeededRandomGenerator(seed) {
	  setInternalState$d(this, {
	    type: SEEDED_RANDOM_GENERATOR,
	    seed: seed % 2147483647
	  });
	}, SEEDED_RANDOM, function next() {
	  var state = getInternalState$9(this);
	  var seed = state.seed = (state.seed * 1103515245 + 12345) % 2147483647;
	  return { value: (seed & 1073741823) / 1073741823, done: false };
	});

	// `Math.seededPRNG` method
	// https://github.com/tc39/proposal-seeded-random
	// based on https://github.com/tc39/proposal-seeded-random/blob/78b8258835b57fc2100d076151ab506bc3202ae6/demo.html
	_export({ target: 'Math', stat: true, forced: true }, {
	  seededPRNG: function seededPRNG(it) {
	    var seed = anObject(it).seed;
	    if (!numberIsFinite(seed)) throw TypeError(SEED_TYPE_ERROR);
	    return new $SeededRandomGenerator(seed);
	  }
	});

	var codeAt$2 = stringMultibyte.codeAt;
	var charAt$3 = stringMultibyte.charAt;
	var STRING_ITERATOR$1 = 'String Iterator';
	var setInternalState$e = internalState.set;
	var getInternalState$a = internalState.getterFor(STRING_ITERATOR$1);

	// TODO: unify with String#@@iterator
	var $StringIterator = createIteratorConstructor(function StringIterator(string) {
	  setInternalState$e(this, {
	    type: STRING_ITERATOR$1,
	    string: string,
	    index: 0
	  });
	}, 'String', function next() {
	  var state = getInternalState$a(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt$3(string, index);
	  state.index += point.length;
	  return { value: { codePoint: codeAt$2(point, 0), position: index }, done: false };
	});

	// `String.prototype.codePoints` method
	// https://github.com/tc39/proposal-string-prototype-codepoints
	_export({ target: 'String', proto: true }, {
	  codePoints: function codePoints() {
	    return new $StringIterator(String(requireObjectCoercible(this)));
	  }
	});

	var isFrozen = Object.isFrozen;

	var isFrozenStringArray = function (array, allowUndefined) {
	  if (!isFrozen || !isArray(array) || !isFrozen(array)) return false;
	  var index = 0;
	  var length = array.length;
	  var element;
	  while (index < length) {
	    element = array[index++];
	    if (!(typeof element === 'string' || (allowUndefined && typeof element === 'undefined'))) {
	      return false;
	    }
	  } return length !== 0;
	};

	// `Array.isTemplateObject` method
	// https://github.com/tc39/proposal-array-is-template-object
	_export({ target: 'Array', stat: true }, {
	  isTemplateObject: function isTemplateObject(value) {
	    if (!isFrozenStringArray(value, true)) return false;
	    var raw = value.raw;
	    if (raw.length !== value.length || !isFrozenStringArray(raw, false)) return false;
	    return true;
	  }
	});

	var USE_FUNCTION_CONSTRUCTOR = 'USE_FUNCTION_CONSTRUCTOR';
	var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
	var AsyncIterator = global_1.AsyncIterator;
	var PassedAsyncIteratorPrototype = sharedStore.AsyncIteratorPrototype;
	var AsyncIteratorPrototype, prototype;

	{
	  if (PassedAsyncIteratorPrototype) {
	    AsyncIteratorPrototype = PassedAsyncIteratorPrototype;
	  } else if (typeof AsyncIterator == 'function') {
	    AsyncIteratorPrototype = AsyncIterator.prototype;
	  } else if (sharedStore[USE_FUNCTION_CONSTRUCTOR] || global_1[USE_FUNCTION_CONSTRUCTOR]) {
	    try {
	      // eslint-disable-next-line no-new-func
	      prototype = objectGetPrototypeOf(objectGetPrototypeOf(objectGetPrototypeOf(Function('return async function*(){}()')())));
	      if (objectGetPrototypeOf(prototype) === Object.prototype) AsyncIteratorPrototype = prototype;
	    } catch (error) { /* empty */ }
	  }
	}

	if (!AsyncIteratorPrototype) AsyncIteratorPrototype = {};

	if (!has(AsyncIteratorPrototype, ASYNC_ITERATOR)) {
	  createNonEnumerableProperty(AsyncIteratorPrototype, ASYNC_ITERATOR, function () {
	    return this;
	  });
	}

	var asyncIteratorPrototype = AsyncIteratorPrototype;

	// https://github.com/tc39/proposal-iterator-helpers








	var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');

	var AsyncIteratorConstructor = function AsyncIterator() {
	  anInstance(this, AsyncIteratorConstructor);
	};

	AsyncIteratorConstructor.prototype = asyncIteratorPrototype;

	if (!has(asyncIteratorPrototype, TO_STRING_TAG$4)) {
	  createNonEnumerableProperty(asyncIteratorPrototype, TO_STRING_TAG$4, 'AsyncIterator');
	}

	if (!has(asyncIteratorPrototype, 'constructor') || asyncIteratorPrototype.constructor === Object) {
	  createNonEnumerableProperty(asyncIteratorPrototype, 'constructor', AsyncIteratorConstructor);
	}

	_export({ global: true, forced: isPure }, {
	  AsyncIterator: AsyncIteratorConstructor
	});

	var Promise$2 = getBuiltIn('Promise');

	var setInternalState$f = internalState.set;
	var getInternalState$b = internalState.get;

	var TO_STRING_TAG$5 = wellKnownSymbol('toStringTag');

	var $return = function (value) {
	  var iterator = getInternalState$b(this).iterator;
	  var $$return = iterator['return'];
	  return $$return === undefined
	    ? Promise$2.resolve({ done: true, value: value })
	    : anObject($$return.call(iterator, value));
	};

	var $throw = function (value) {
	  var iterator = getInternalState$b(this).iterator;
	  var $$throw = iterator['throw'];
	  return $$throw === undefined
	    ? Promise$2.reject(value)
	    : $$throw.call(iterator, value);
	};

	var asyncIteratorCreateProxy = function (nextHandler, IS_ITERATOR) {
	  var AsyncIteratorProxy = function AsyncIterator(state) {
	    state.next = aFunction$1(state.iterator.next);
	    state.done = false;
	    setInternalState$f(this, state);
	  };

	  AsyncIteratorProxy.prototype = redefineAll(objectCreate(path.AsyncIterator.prototype), {
	    next: function next(arg) {
	      var state = getInternalState$b(this);
	      if (state.done) return Promise$2.resolve({ done: true, value: undefined });
	      try {
	        return Promise$2.resolve(anObject(nextHandler.call(state, arg, Promise$2)));
	      } catch (error) {
	        return Promise$2.reject(error);
	      }
	    },
	    'return': $return,
	    'throw': $throw
	  });

	  if (!IS_ITERATOR) {
	    createNonEnumerableProperty(AsyncIteratorProxy.prototype, TO_STRING_TAG$5, 'Generator');
	  }

	  return AsyncIteratorProxy;
	};

	// https://github.com/tc39/proposal-iterator-helpers




	var AsyncIteratorProxy = asyncIteratorCreateProxy(function (arg, Promise) {
	  var state = this;
	  var iterator = state.iterator;

	  return Promise.resolve(anObject(state.next.call(iterator, arg))).then(function (step) {
	    if (anObject(step).done) {
	      state.done = true;
	      return { done: true, value: undefined };
	    }
	    return { done: false, value: [state.index++, step.value] };
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  asIndexedPairs: function asIndexedPairs() {
	    return new AsyncIteratorProxy({
	      iterator: anObject(this),
	      index: 0
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	var AsyncIteratorProxy$1 = asyncIteratorCreateProxy(function (arg, Promise) {
	  var state = this;

	  return new Promise(function (resolve, reject) {
	    var loop = function () {
	      try {
	        Promise.resolve(
	          anObject(state.next.call(state.iterator, state.remaining ? undefined : arg))
	        ).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve({ done: true, value: undefined });
	            } else if (state.remaining) {
	              state.remaining--;
	              loop();
	            } else resolve({ done: false, value: step.value });
	          } catch (err) { reject(err); }
	        }, reject);
	      } catch (error) { reject(error); }
	    };

	    loop();
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  drop: function drop(limit) {
	    return new AsyncIteratorProxy$1({
	      iterator: anObject(this),
	      remaining: toPositiveInteger(limit)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers




	var Promise$3 = getBuiltIn('Promise');
	var push$1 = [].push;

	var createMethod$7 = function (TYPE) {
	  var IS_TO_ARRAY = TYPE == 0;
	  var IS_FOR_EACH = TYPE == 1;
	  var IS_EVERY = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  return function (iterator, fn) {
	    anObject(iterator);
	    var next = aFunction$1(iterator.next);
	    var array = IS_TO_ARRAY ? [] : undefined;
	    if (!IS_TO_ARRAY) aFunction$1(fn);

	    return new Promise$3(function (resolve, reject) {
	      var loop = function () {
	        try {
	          Promise$3.resolve(anObject(next.call(iterator))).then(function (step) {
	            try {
	              if (anObject(step).done) {
	                resolve(IS_TO_ARRAY ? array : IS_SOME ? false : IS_EVERY || undefined);
	              } else {
	                var value = step.value;
	                if (IS_TO_ARRAY) {
	                  push$1.call(array, value);
	                  loop();
	                } else {
	                  Promise$3.resolve(fn(value)).then(function (result) {
	                    if (IS_FOR_EACH) {
	                      loop();
	                    } else if (IS_EVERY) {
	                      result ? loop() : resolve(false);
	                    } else {
	                      result ? resolve(IS_SOME || value) : loop();
	                    }
	                  }, reject);
	                }
	              }
	            } catch (err) { reject(err); }
	          }, reject);
	        } catch (error) { reject(error); }
	      };

	      loop();
	    });
	  };
	};

	var asyncIteratorIteration = {
	  toArray: createMethod$7(0),
	  forEach: createMethod$7(1),
	  every: createMethod$7(2),
	  some: createMethod$7(3),
	  find: createMethod$7(4)
	};

	// https://github.com/tc39/proposal-iterator-helpers

	var $every$2 = asyncIteratorIteration.every;

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  every: function every(fn) {
	    return $every$2(this, fn);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	var AsyncIteratorProxy$2 = asyncIteratorCreateProxy(function (arg, Promise) {
	  var state = this;
	  var filterer = state.filterer;

	  return new Promise(function (resolve, reject) {
	    var loop = function () {
	      try {
	        Promise.resolve(anObject(state.next.call(state.iterator, arg))).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve({ done: true, value: undefined });
	            } else {
	              var value = step.value;
	              Promise.resolve(filterer(value)).then(function (selected) {
	                selected ? resolve({ done: false, value: value }) : loop();
	              }, reject);
	            }
	          } catch (err) { reject(err); }
	        }, reject);
	      } catch (error) { reject(error); }
	    };

	    loop();
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  filter: function filter(filterer) {
	    return new AsyncIteratorProxy$2({
	      iterator: anObject(this),
	      filterer: aFunction$1(filterer)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $find$2 = asyncIteratorIteration.find;

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  find: function find(fn) {
	    return $find$2(this, fn);
	  }
	});

	var ASYNC_ITERATOR$1 = wellKnownSymbol('asyncIterator');

	var getAsyncIteratorMethod = function (it) {
	  var method = it[ASYNC_ITERATOR$1];
	  return method === undefined ? getIteratorMethod(it) : method;
	};

	// https://github.com/tc39/proposal-iterator-helpers






	var AsyncIteratorProxy$3 = asyncIteratorCreateProxy(function (arg, Promise) {
	  var state = this;
	  var mapper = state.mapper;
	  var innerIterator, iteratorMethod;

	  return new Promise(function (resolve, reject) {
	    var outerLoop = function () {
	      try {
	        Promise.resolve(anObject(state.next.call(state.iterator, arg))).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve({ done: true, value: undefined });
	            } else {
	              Promise.resolve(mapper(step.value)).then(function (mapped) {
	                try {
	                  iteratorMethod = getAsyncIteratorMethod(mapped);
	                  if (iteratorMethod !== undefined) {
	                    state.innerIterator = innerIterator = anObject(iteratorMethod.call(mapped));
	                    state.innerNext = aFunction$1(innerIterator.next);
	                    return innerLoop();
	                  } reject(TypeError('.flatMap callback should return an iterable object'));
	                } catch (error2) { reject(error2); }
	              }, reject);
	            }
	          } catch (error1) { reject(error1); }
	        }, reject);
	      } catch (error) { reject(error); }
	    };

	    var innerLoop = function () {
	      if (innerIterator = state.innerIterator) {
	        try {
	          Promise.resolve(anObject(state.innerNext.call(innerIterator))).then(function (result) {
	            try {
	              if (anObject(result).done) {
	                state.innerIterator = state.innerNext = null;
	                outerLoop();
	              } else resolve({ done: false, value: result.value });
	            } catch (error1) { reject(error1); }
	          }, reject);
	        } catch (error) { reject(error); }
	      } else outerLoop();
	    };

	    innerLoop();
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  flatMap: function flatMap(mapper) {
	    return new AsyncIteratorProxy$3({
	      iterator: anObject(this),
	      mapper: aFunction$1(mapper),
	      innerIterator: null,
	      innerNext: null
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $forEach$3 = asyncIteratorIteration.forEach;

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  forEach: function forEach(fn) {
	    return $forEach$3(this, fn);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers








	var AsyncIterator$1 = path.AsyncIterator;

	var AsyncIteratorProxy$4 = asyncIteratorCreateProxy(function (arg) {
	  return anObject(this.next.call(this.iterator, arg));
	}, true);

	_export({ target: 'AsyncIterator', stat: true }, {
	  from: function from(O) {
	    var object = toObject(O);
	    var usingIterator = getAsyncIteratorMethod(object);
	    var iterator;
	    if (usingIterator != null) {
	      iterator = aFunction$1(usingIterator).call(object);
	      if (iterator instanceof AsyncIterator$1) return iterator;
	    } else {
	      iterator = object;
	    } return new AsyncIteratorProxy$4({
	      iterator: iterator
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	var AsyncIteratorProxy$5 = asyncIteratorCreateProxy(function (arg, Promise) {
	  var state = this;
	  var mapper = state.mapper;

	  return Promise.resolve(anObject(state.next.call(state.iterator, arg))).then(function (step) {
	    if (anObject(step).done) {
	      state.done = true;
	      return { done: true, value: undefined };
	    }
	    return Promise.resolve(mapper(step.value)).then(function (value) {
	      return { done: false, value: value };
	    });
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  map: function map(mapper) {
	    return new AsyncIteratorProxy$5({
	      iterator: anObject(this),
	      mapper: aFunction$1(mapper)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	var Promise$4 = getBuiltIn('Promise');

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  reduce: function reduce(reducer /* , initialValue */) {
	    var iterator = anObject(this);
	    var next = aFunction$1(iterator.next);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    aFunction$1(reducer);

	    return new Promise$4(function (resolve, reject) {
	      var loop = function () {
	        try {
	          Promise$4.resolve(anObject(next.call(iterator))).then(function (step) {
	            try {
	              if (anObject(step).done) {
	                noInitial ? reject(TypeError('Reduce of empty iterator with no initial value')) : resolve(accumulator);
	              } else {
	                var value = step.value;
	                if (noInitial) {
	                  noInitial = false;
	                  accumulator = value;
	                  loop();
	                } else {
	                  Promise$4.resolve(reducer(accumulator, value)).then(function (result) {
	                    accumulator = result;
	                    loop();
	                  }, reject);
	                }
	              }
	            } catch (err) { reject(err); }
	          }, reject);
	        } catch (error) { reject(error); }
	      };

	      loop();
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $some$2 = asyncIteratorIteration.some;

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  some: function some(fn) {
	    return $some$2(this, fn);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	var AsyncIteratorProxy$6 = asyncIteratorCreateProxy(function (arg) {
	  if (!this.remaining--) {
	    this.done = true;
	    return { done: true, value: undefined };
	  } return this.next.call(this.iterator, arg);
	});

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  take: function take(limit) {
	    return new AsyncIteratorProxy$6({
	      iterator: anObject(this),
	      remaining: toPositiveInteger(limit)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $toArray = asyncIteratorIteration.toArray;

	_export({ target: 'AsyncIterator', proto: true, real: true }, {
	  toArray: function toArray() {
	    return $toArray(this);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var IteratorPrototype$3 = iteratorsCore.IteratorPrototype;


	var ITERATOR$8 = wellKnownSymbol('iterator');
	var TO_STRING_TAG$6 = wellKnownSymbol('toStringTag');

	var NativeIterator = global_1.Iterator;

	// FF56- have non-standard global helper `Iterator`
	var FORCED$l =  typeof NativeIterator != 'function'
	  || NativeIterator.prototype !== IteratorPrototype$3
	  // FF44- non-standard `Iterator` passes previous tests
	  || !fails(function () { NativeIterator({}); });

	var IteratorConstructor = function Iterator() {
	  anInstance(this, IteratorConstructor);
	};

	if (!has(IteratorPrototype$3, TO_STRING_TAG$6)) {
	  createNonEnumerableProperty(IteratorPrototype$3, TO_STRING_TAG$6, 'Iterator');
	}

	if (FORCED$l || !has(IteratorPrototype$3, 'constructor') || IteratorPrototype$3.constructor === Object) {
	  createNonEnumerableProperty(IteratorPrototype$3, 'constructor', IteratorConstructor);
	}

	IteratorConstructor.prototype = IteratorPrototype$3;

	_export({ global: true, forced: FORCED$l }, {
	  Iterator: IteratorConstructor
	});

	var setInternalState$g = internalState.set;
	var getInternalState$c = internalState.get;

	var TO_STRING_TAG$7 = wellKnownSymbol('toStringTag');

	var $return$1 = function (value) {
	  var iterator = getInternalState$c(this).iterator;
	  var $$return = iterator['return'];
	  return $$return === undefined ? { done: true, value: value } : anObject($$return.call(iterator, value));
	};

	var $throw$1 = function (value) {
	  var iterator = getInternalState$c(this).iterator;
	  var $$throw = iterator['throw'];
	  if ($$throw === undefined) throw value;
	  return $$throw.call(iterator, value);
	};

	var iteratorCreateProxy = function (nextHandler, IS_ITERATOR) {
	  var IteratorProxy = function Iterator(state) {
	    state.next = aFunction$1(state.iterator.next);
	    state.done = false;
	    setInternalState$g(this, state);
	  };

	  IteratorProxy.prototype = redefineAll(objectCreate(path.Iterator.prototype), {
	    next: function next() {
	      var state = getInternalState$c(this);
	      var result = state.done ? undefined : nextHandler.apply(state, arguments);
	      return { done: state.done, value: result };
	    },
	    'return': $return$1,
	    'throw': $throw$1
	  });

	  if (!IS_ITERATOR) {
	    createNonEnumerableProperty(IteratorProxy.prototype, TO_STRING_TAG$7, 'Generator');
	  }

	  return IteratorProxy;
	};

	// https://github.com/tc39/proposal-iterator-helpers




	var IteratorProxy = iteratorCreateProxy(function (arg) {
	  var result = anObject(this.next.call(this.iterator, arg));
	  var done = this.done = !!result.done;
	  if (!done) return [this.index++, result.value];
	});

	_export({ target: 'Iterator', proto: true, real: true }, {
	  asIndexedPairs: function asIndexedPairs() {
	    return new IteratorProxy({
	      iterator: anObject(this),
	      index: 0
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	var IteratorProxy$1 = iteratorCreateProxy(function (arg) {
	  var iterator = this.iterator;
	  var next = this.next;
	  var result, done;
	  while (this.remaining) {
	    this.remaining--;
	    result = anObject(next.call(iterator));
	    done = this.done = !!result.done;
	    if (done) return;
	  }
	  result = anObject(next.call(iterator, arg));
	  done = this.done = !!result.done;
	  if (!done) return result.value;
	});

	_export({ target: 'Iterator', proto: true, real: true }, {
	  drop: function drop(limit) {
	    return new IteratorProxy$1({
	      iterator: anObject(this),
	      remaining: toPositiveInteger(limit)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	_export({ target: 'Iterator', proto: true, real: true }, {
	  every: function every(fn) {
	    anObject(this);
	    aFunction$1(fn);
	    return !iterate_1(this, function (value) {
	      if (!fn(value)) return iterate_1.stop();
	    }, undefined, false, true).stopped;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers






	var IteratorProxy$2 = iteratorCreateProxy(function (arg) {
	  var iterator = this.iterator;
	  var filterer = this.filterer;
	  var next = this.next;
	  var result, done, value;
	  while (true) {
	    result = anObject(next.call(iterator, arg));
	    done = this.done = !!result.done;
	    if (done) return;
	    value = result.value;
	    if (callWithSafeIterationClosing(iterator, filterer, value)) return value;
	  }
	});

	_export({ target: 'Iterator', proto: true, real: true }, {
	  filter: function filter(filterer) {
	    return new IteratorProxy$2({
	      iterator: anObject(this),
	      filterer: aFunction$1(filterer)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	_export({ target: 'Iterator', proto: true, real: true }, {
	  find: function find(fn) {
	    anObject(this);
	    aFunction$1(fn);
	    return iterate_1(this, function (value) {
	      if (fn(value)) return iterate_1.stop(value);
	    }, undefined, false, true).result;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var IteratorProxy$3 = iteratorCreateProxy(function (arg) {
	  var iterator = this.iterator;
	  var result, mapped, iteratorMethod, innerIterator;

	  while (true) {
	    if (innerIterator = this.innerIterator) {
	      result = anObject(this.innerNext.call(innerIterator));
	      if (!result.done) return result.value;
	      this.innerIterator = this.innerNext = null;
	    }

	    result = anObject(this.next.call(iterator, arg));

	    if (this.done = !!result.done) return;

	    mapped = callWithSafeIterationClosing(iterator, this.mapper, result.value);
	    iteratorMethod = getIteratorMethod(mapped);

	    if (iteratorMethod === undefined) {
	      throw TypeError('.flatMap callback should return an iterable object');
	    }

	    this.innerIterator = innerIterator = anObject(iteratorMethod.call(mapped));
	    this.innerNext = aFunction$1(innerIterator.next);
	  }
	});

	_export({ target: 'Iterator', proto: true, real: true }, {
	  flatMap: function flatMap(mapper) {
	    return new IteratorProxy$3({
	      iterator: anObject(this),
	      mapper: aFunction$1(mapper),
	      innerIterator: null,
	      innerNext: null
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers




	_export({ target: 'Iterator', proto: true, real: true }, {
	  forEach: function forEach(fn) {
	    iterate_1(anObject(this), fn, undefined, false, true);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers








	var Iterator = path.Iterator;

	var IteratorProxy$4 = iteratorCreateProxy(function (arg) {
	  var result = anObject(this.next.call(this.iterator, arg));
	  var done = this.done = !!result.done;
	  if (!done) return result.value;
	}, true);

	_export({ target: 'Iterator', stat: true }, {
	  from: function from(O) {
	    var object = toObject(O);
	    var usingIterator = getIteratorMethod(object);
	    var iterator;
	    if (usingIterator != null) {
	      iterator = aFunction$1(usingIterator).call(object);
	      if (iterator instanceof Iterator) return iterator;
	    } else {
	      iterator = object;
	    } return new IteratorProxy$4({
	      iterator: iterator
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers






	var IteratorProxy$5 = iteratorCreateProxy(function (arg) {
	  var iterator = this.iterator;
	  var result = anObject(this.next.call(iterator, arg));
	  var done = this.done = !!result.done;
	  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, result.value);
	});

	_export({ target: 'Iterator', proto: true, real: true }, {
	  map: function map(mapper) {
	    return new IteratorProxy$5({
	      iterator: anObject(this),
	      mapper: aFunction$1(mapper)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	_export({ target: 'Iterator', proto: true, real: true }, {
	  reduce: function reduce(reducer /* , initialValue */) {
	    anObject(this);
	    aFunction$1(reducer);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    iterate_1(this, function (value) {
	      if (noInitial) {
	        noInitial = false;
	        accumulator = value;
	      } else {
	        accumulator = reducer(accumulator, value);
	      }
	    }, undefined, false, true);
	    if (noInitial) throw TypeError('Reduce of empty iterator with no initial value');
	    return accumulator;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	_export({ target: 'Iterator', proto: true, real: true }, {
	  some: function some(fn) {
	    anObject(this);
	    aFunction$1(fn);
	    return iterate_1(this, function (value) {
	      if (fn(value)) return iterate_1.stop();
	    }, undefined, false, true).stopped;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	var IteratorProxy$6 = iteratorCreateProxy(function (arg) {
	  if (!this.remaining--) {
	    this.done = true;
	    return;
	  }
	  var result = anObject(this.next.call(this.iterator, arg));
	  var done = this.done = !!result.done;
	  if (!done) return result.value;
	});

	_export({ target: 'Iterator', proto: true, real: true }, {
	  take: function take(limit) {
	    return new IteratorProxy$6({
	      iterator: anObject(this),
	      remaining: toPositiveInteger(limit)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers




	var push$2 = [].push;

	_export({ target: 'Iterator', proto: true, real: true }, {
	  toArray: function toArray() {
	    var result = [];
	    iterate_1(anObject(this), push$2, result, false, true);
	    return result;
	  }
	});

	// `Map.prototype.upsert` method
	// https://github.com/thumbsupep/proposal-upsert
	var mapUpsert = function upsert(key, updateFn /* , insertFn */) {
	  var map = anObject(this);
	  var insertFn = arguments.length > 2 ? arguments[2] : undefined;
	  var value;
	  if (typeof updateFn != 'function' && typeof insertFn != 'function') {
	    throw TypeError('At least one callback required');
	  }
	  if (map.has(key)) {
	    value = map.get(key);
	    if (typeof updateFn == 'function') {
	      value = updateFn(value);
	      map.set(key, value);
	    }
	  } else if (typeof insertFn == 'function') {
	    value = insertFn();
	    map.set(key, value);
	  } return value;
	};

	// TODO: remove from `core-js@4`




	// `Map.prototype.updateOrInsert` method (replaced by `Map.prototype.upsert`)
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  updateOrInsert: mapUpsert
	});

	// `Map.prototype.upsert` method
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  upsert: mapUpsert
	});

	// `WeakMap.prototype.upsert` method
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'WeakMap', proto: true, real: true, forced: isPure }, {
	  upsert: mapUpsert
	});

	// `Set.prototype.difference` method
	// https://github.com/tc39/proposal-set-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  difference: function difference(iterable) {
	    var set = anObject(this);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
	    var remover = aFunction$1(newSet['delete']);
	    iterate_1(iterable, function (value) {
	      remover.call(newSet, value);
	    });
	    return newSet;
	  }
	});

	// `Set.prototype.intersection` method
	// https://github.com/tc39/proposal-set-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  intersection: function intersection(iterable) {
	    var set = anObject(this);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
	    var hasCheck = aFunction$1(set.has);
	    var adder = aFunction$1(newSet.add);
	    iterate_1(iterable, function (value) {
	      if (hasCheck.call(set, value)) adder.call(newSet, value);
	    });
	    return newSet;
	  }
	});

	// `Set.prototype.isDisjointFrom` method
	// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  isDisjointFrom: function isDisjointFrom(iterable) {
	    var set = anObject(this);
	    var hasCheck = aFunction$1(set.has);
	    return !iterate_1(iterable, function (value) {
	      if (hasCheck.call(set, value) === true) return iterate_1.stop();
	    }).stopped;
	  }
	});

	// `Set.prototype.isSubsetOf` method
	// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  isSubsetOf: function isSubsetOf(iterable) {
	    var iterator = getIterator(this);
	    var otherSet = anObject(iterable);
	    var hasCheck = otherSet.has;
	    if (typeof hasCheck != 'function') {
	      otherSet = new (getBuiltIn('Set'))(iterable);
	      hasCheck = aFunction$1(otherSet.has);
	    }
	    return !iterate_1(iterator, function (value) {
	      if (hasCheck.call(otherSet, value) === false) return iterate_1.stop();
	    }, undefined, false, true).stopped;
	  }
	});

	// `Set.prototype.isSupersetOf` method
	// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  isSupersetOf: function isSupersetOf(iterable) {
	    var set = anObject(this);
	    var hasCheck = aFunction$1(set.has);
	    return !iterate_1(iterable, function (value) {
	      if (hasCheck.call(set, value) === false) return iterate_1.stop();
	    }).stopped;
	  }
	});

	// `Set.prototype.union` method
	// https://github.com/tc39/proposal-set-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  union: function union(iterable) {
	    var set = anObject(this);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
	    iterate_1(iterable, aFunction$1(newSet.add), newSet);
	    return newSet;
	  }
	});

	// `Set.prototype.symmetricDifference` method
	// https://github.com/tc39/proposal-set-methods
	_export({ target: 'Set', proto: true, real: true, forced: isPure }, {
	  symmetricDifference: function symmetricDifference(iterable) {
	    var set = anObject(this);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
	    var remover = aFunction$1(newSet['delete']);
	    var adder = aFunction$1(newSet.add);
	    iterate_1(iterable, function (value) {
	      remover.call(newSet, value) || adder.call(newSet, value);
	    });
	    return newSet;
	  }
	});

	// `Symbol.asyncDispose` well-known symbol
	// https://github.com/tc39/proposal-using-statement
	defineWellKnownSymbol('asyncDispose');

	// `Symbol.dispose` well-known symbol
	// https://github.com/tc39/proposal-using-statement
	defineWellKnownSymbol('dispose');

	var setInternalState$h = internalState.set;
	var getInternalAggregateErrorState = internalState.getterFor('AggregateError');

	var $AggregateError = function AggregateError(errors, message) {
	  var that = this;
	  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);
	  if (objectSetPrototypeOf) {
	    that = objectSetPrototypeOf(new Error(message), objectGetPrototypeOf(that));
	  }
	  var errorsArray = [];
	  iterate_1(errors, errorsArray.push, errorsArray);
	  if (descriptors) setInternalState$h(that, { errors: errorsArray, type: 'AggregateError' });
	  else that.errors = errorsArray;
	  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));
	  return that;
	};

	$AggregateError.prototype = objectCreate(Error.prototype, {
	  constructor: createPropertyDescriptor(5, $AggregateError),
	  message: createPropertyDescriptor(5, ''),
	  name: createPropertyDescriptor(5, 'AggregateError')
	});

	if (descriptors) objectDefineProperty.f($AggregateError.prototype, 'errors', {
	  get: function () {
	    return getInternalAggregateErrorState(this).errors;
	  },
	  configurable: true
	});

	_export({ global: true }, {
	  AggregateError: $AggregateError
	});

	var PROMISE_ANY_ERROR = 'No one promise resolved';

	// `Promise.any` method
	// https://github.com/tc39/proposal-promise-any
	_export({ target: 'Promise', stat: true }, {
	  any: function any(iterable) {
	    var C = this;
	    var capability = newPromiseCapability.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aFunction$1(C.resolve);
	      var errors = [];
	      var counter = 0;
	      var remaining = 1;
	      var alreadyResolved = false;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyRejected = false;
	        errors.push(undefined);
	        remaining++;
	        promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyResolved = true;
	          resolve(value);
	        }, function (e) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyRejected = true;
	          errors[index] = e;
	          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
	        });
	      });
	      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var REPLACE$1 = wellKnownSymbol('replace');
	var RegExpPrototype$4 = RegExp.prototype;

	// `String.prototype.replaceAll` method
	// https://github.com/tc39/proposal-string-replace-all
	_export({ target: 'String', proto: true }, {
	  replaceAll: function replaceAll(searchValue, replaceValue) {
	    var O = requireObjectCoercible(this);
	    var IS_REG_EXP, flags, replacer, string, searchString, template, result, position, index;
	    if (searchValue != null) {
	      IS_REG_EXP = isRegexp(searchValue);
	      if (IS_REG_EXP) {
	        flags = String(requireObjectCoercible('flags' in RegExpPrototype$4
	          ? searchValue.flags
	          : regexpFlags.call(searchValue)
	        ));
	        if (!~flags.indexOf('g')) throw TypeError('`.replaceAll` does not allow non-global regexes');
	      }
	      replacer = searchValue[REPLACE$1];
	      if (replacer !== undefined) {
	        return replacer.call(searchValue, O, replaceValue);
	      }
	    }
	    string = String(O);
	    searchString = String(searchValue);
	    if (searchString === '') return replaceAll.call(string, /(?:)/g, replaceValue);
	    template = string.split(searchString);
	    if (typeof replaceValue !== 'function') {
	      return template.join(String(replaceValue));
	    }
	    result = template[0];
	    position = result.length;
	    for (index = 1; index < template.length; index++) {
	      result += String(replaceValue(searchString, position, string));
	      position += searchString.length + template[index].length;
	      result += template[index];
	    }
	    return result;
	  }
	});

	// TODO: remove from `core-js@4`


	defineWellKnownSymbol('replaceAll');

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  // some Chrome versions have non-configurable methods on DOMTokenList
	  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
	    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype.forEach = arrayForEach;
	  }
	}

	var ITERATOR$9 = wellKnownSymbol('iterator');
	var TO_STRING_TAG$8 = wellKnownSymbol('toStringTag');
	var ArrayValues = es_array_iterator.values;

	for (var COLLECTION_NAME$1 in domIterables) {
	  var Collection$1 = global_1[COLLECTION_NAME$1];
	  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
	  if (CollectionPrototype$1) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype$1[ITERATOR$9] !== ArrayValues) try {
	      createNonEnumerableProperty(CollectionPrototype$1, ITERATOR$9, ArrayValues);
	    } catch (error) {
	      CollectionPrototype$1[ITERATOR$9] = ArrayValues;
	    }
	    if (!CollectionPrototype$1[TO_STRING_TAG$8]) {
	      createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG$8, COLLECTION_NAME$1);
	    }
	    if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
	        createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
	      }
	    }
	  }
	}

	var FORCED$m = !global_1.setImmediate || !global_1.clearImmediate;

	// http://w3c.github.io/setImmediate/
	_export({ global: true, bind: true, enumerable: true, forced: FORCED$m }, {
	  // `setImmediate` method
	  // http://w3c.github.io/setImmediate/#si-setImmediate
	  setImmediate: task.set,
	  // `clearImmediate` method
	  // http://w3c.github.io/setImmediate/#si-clearImmediate
	  clearImmediate: task.clear
	});

	var process$4 = global_1.process;
	var isNode = classofRaw(process$4) == 'process';

	// `queueMicrotask` method
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask
	_export({ global: true, enumerable: true, noTargetGet: true }, {
	  queueMicrotask: function queueMicrotask(fn) {
	    var domain = isNode && process$4.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

	var slice$1 = [].slice;
	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

	var wrap$1 = function (scheduler) {
	  return function (handler, timeout /* , ...arguments */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice$1.call(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
	    } : handler, timeout);
	  };
	};

	// ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
	_export({ global: true, bind: true, forced: MSIE }, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap$1(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap$1(global_1.setInterval)
	});

	var runtime_1 = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function define(obj, key, value) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	    return obj[key];
	  }
	  try {
	    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
	    define({}, "");
	  } catch (err) {
	    define = function(obj, key, value) {
	      return obj[key] = value;
	    };
	  }

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunction.displayName = define(
	    GeneratorFunctionPrototype,
	    toStringTagSymbol,
	    "GeneratorFunction"
	  );

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      define(prototype, method, function(arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      define(genFun, toStringTagSymbol, "GeneratorFunction");
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return PromiseImpl.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;

	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList),
	      PromiseImpl
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  define(Gp, toStringTagSymbol, "Generator");

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	   module.exports 
	));

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  Function("r", "regeneratorRuntime = r")(runtime);
	}
	});

	/**
	@license @nocompile
	Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
	This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	Code distributed by Google as part of the polymer project is also
	subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	*/
	(function(){/*

	 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
	 This code may only be used under the BSD style license found at
	 http://polymer.github.io/LICENSE.txt The complete set of authors may be found
	 at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
	 be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
	 Google as part of the polymer project is also subject to an additional IP
	 rights grant found at http://polymer.github.io/PATENTS.txt
	*/
	var w;function aa(a){var b=0;return function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}}}var ba="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value);},ca="undefined"!=typeof window&&window===this?this:"undefined"!=typeof commonjsGlobal&&null!=commonjsGlobal?commonjsGlobal:this;function da(){da=function(){};ca.Symbol||(ca.Symbol=fa);}
	function ha(a,b){this.a=a;ba(this,"description",{configurable:!0,writable:!0,value:b});}ha.prototype.toString=function(){return this.a};var fa=function(){function a(c){if(this instanceof a)throw new TypeError("Symbol is not a constructor");return new ha("jscomp_symbol_"+(c||"")+"_"+b++,c)}var b=0;return a}();
	function ia(){da();var a=ca.Symbol.iterator;a||(a=ca.Symbol.iterator=ca.Symbol("Symbol.iterator"));"function"!=typeof Array.prototype[a]&&ba(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return la(aa(this))}});ia=function(){};}function la(a){ia();a={next:a};a[ca.Symbol.iterator]=function(){return this};return a}function ma(a){var b="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];return b?b.call(a):{next:aa(a)}}
	function na(a){for(var b,c=[];!(b=a.next()).done;)c.push(b.value);return c}var oa;if("function"==typeof Object.setPrototypeOf)oa=Object.setPrototypeOf;else {var pa;a:{var qa={Pa:!0},ra={};try{ra.__proto__=qa;pa=ra.Pa;break a}catch(a){}pa=!1;}oa=pa?function(a,b){a.__proto__=b;if(a.__proto__!==b)throw new TypeError(a+" is not extensible");return a}:null;}var sa=oa;function wa(){this.l=!1;this.b=null;this.Ea=void 0;this.a=1;this.Y=0;this.c=null;}
	function ya(a){if(a.l)throw new TypeError("Generator is already running");a.l=!0;}wa.prototype.J=function(a){this.Ea=a;};function za(a,b){a.c={Sa:b,Wa:!0};a.a=a.Y;}wa.prototype.return=function(a){this.c={return:a};this.a=this.Y;};function Aa(a,b){a.a=3;return {value:b}}function Ba(a){this.a=new wa;this.b=a;}function Ca(a,b){ya(a.a);var c=a.a.b;if(c)return Da(a,"return"in c?c["return"]:function(d){return {value:d,done:!0}},b,a.a.return);a.a.return(b);return Ea(a)}
	function Da(a,b,c,d){try{var e=b.call(a.a.b,c);if(!(e instanceof Object))throw new TypeError("Iterator result "+e+" is not an object");if(!e.done)return a.a.l=!1,e;var f=e.value;}catch(g){return a.a.b=null,za(a.a,g),Ea(a)}a.a.b=null;d.call(a.a,f);return Ea(a)}function Ea(a){for(;a.a.a;)try{var b=a.b(a.a);if(b)return a.a.l=!1,{value:b.value,done:!1}}catch(c){a.a.Ea=void 0,za(a.a,c);}a.a.l=!1;if(a.a.c){b=a.a.c;a.a.c=null;if(b.Wa)throw b.Sa;return {value:b.return,done:!0}}return {value:void 0,done:!0}}
	function Fa(a){this.next=function(b){ya(a.a);a.a.b?b=Da(a,a.a.b.next,b,a.a.J):(a.a.J(b),b=Ea(a));return b};this.throw=function(b){ya(a.a);a.a.b?b=Da(a,a.a.b["throw"],b,a.a.J):(za(a.a,b),b=Ea(a));return b};this.return=function(b){return Ca(a,b)};ia();this[Symbol.iterator]=function(){return this};}function Ga(a,b){b=new Fa(new Ba(b));sa&&sa(b,a.prototype);return b}Array.from||(Array.from=function(a){return [].slice.call(a)});
	Object.assign||(Object.assign=function(a){for(var b=[].slice.call(arguments,1),c=0,d;c<b.length;c++)if(d=b[c])for(var e=a,f=Object.keys(d),g=0;g<f.length;g++){var h=f[g];e[h]=d[h];}return a});var Ha=document.createEvent("Event");Ha.initEvent("foo",!0,!0);Ha.preventDefault();if(!Ha.defaultPrevented){var Ia=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(Ia.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return !0},configurable:!0}));};}var Ja=/Trident/.test(navigator.userAgent);
	if(!window.Event||Ja&&"function"!==typeof window.Event){var Ka=window.Event;window.Event=function(a,b){b=b||{};var c=document.createEvent("Event");c.initEvent(a,!!b.bubbles,!!b.cancelable);return c};if(Ka){for(var La in Ka)window.Event[La]=Ka[La];window.Event.prototype=Ka.prototype;}}
	if(!window.CustomEvent||Ja&&"function"!==typeof window.CustomEvent)window.CustomEvent=function(a,b){b=b||{};var c=document.createEvent("CustomEvent");c.initCustomEvent(a,!!b.bubbles,!!b.cancelable,b.detail);return c},window.CustomEvent.prototype=window.Event.prototype;
	if(!window.MouseEvent||Ja&&"function"!==typeof window.MouseEvent){var Ma=window.MouseEvent;window.MouseEvent=function(a,b){b=b||{};var c=document.createEvent("MouseEvent");c.initMouseEvent(a,!!b.bubbles,!!b.cancelable,b.view||window,b.detail,b.screenX,b.screenY,b.clientX,b.clientY,b.ctrlKey,b.altKey,b.shiftKey,b.metaKey,b.button,b.relatedTarget);return c};if(Ma)for(var Na in Ma)window.MouseEvent[Na]=Ma[Na];window.MouseEvent.prototype=Ma.prototype;}(function(){function a(){}function b(p,r){if(!p.childNodes.length)return [];switch(p.nodeType){case Node.DOCUMENT_NODE:return F.call(p,r);case Node.DOCUMENT_FRAGMENT_NODE:return E.call(p,r);default:return t.call(p,r)}}var c="undefined"===typeof HTMLTemplateElement,d=!(document.createDocumentFragment().cloneNode()instanceof DocumentFragment),e=!1;/Trident/.test(navigator.userAgent)&&function(){function p(z,R){if(z instanceof DocumentFragment)for(var fb;fb=z.firstChild;)B.call(this,fb,R);else B.call(this,
	z,R);return z}e=!0;var r=Node.prototype.cloneNode;Node.prototype.cloneNode=function(z){z=r.call(this,z);this instanceof DocumentFragment&&(z.__proto__=DocumentFragment.prototype);return z};DocumentFragment.prototype.querySelectorAll=HTMLElement.prototype.querySelectorAll;DocumentFragment.prototype.querySelector=HTMLElement.prototype.querySelector;Object.defineProperties(DocumentFragment.prototype,{nodeType:{get:function(){return Node.DOCUMENT_FRAGMENT_NODE},configurable:!0},localName:{get:function(){},
	configurable:!0},nodeName:{get:function(){return "#document-fragment"},configurable:!0}});var B=Node.prototype.insertBefore;Node.prototype.insertBefore=p;var K=Node.prototype.appendChild;Node.prototype.appendChild=function(z){z instanceof DocumentFragment?p.call(this,z,null):K.call(this,z);return z};var Z=Node.prototype.removeChild,ja=Node.prototype.replaceChild;Node.prototype.replaceChild=function(z,R){z instanceof DocumentFragment?(p.call(this,z,R),Z.call(this,R)):ja.call(this,z,R);return R};Document.prototype.createDocumentFragment=
	function(){var z=this.createElement("df");z.__proto__=DocumentFragment.prototype;return z};var ta=Document.prototype.importNode;Document.prototype.importNode=function(z,R){R=ta.call(this,z,R||!1);z instanceof DocumentFragment&&(R.__proto__=DocumentFragment.prototype);return R};}();var f=Node.prototype.cloneNode,g=Document.prototype.createElement,h=Document.prototype.importNode,k=Node.prototype.removeChild,l=Node.prototype.appendChild,m=Node.prototype.replaceChild,q=DOMParser.prototype.parseFromString,
	H=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML")||{get:function(){return this.innerHTML},set:function(p){this.innerHTML=p;}},C=Object.getOwnPropertyDescriptor(window.Node.prototype,"childNodes")||{get:function(){return this.childNodes}},t=Element.prototype.querySelectorAll,F=Document.prototype.querySelectorAll,E=DocumentFragment.prototype.querySelectorAll,M=function(){if(!c){var p=document.createElement("template"),r=document.createElement("template");r.content.appendChild(document.createElement("div"));
	p.content.appendChild(r);p=p.cloneNode(!0);return 0===p.content.childNodes.length||0===p.content.firstChild.content.childNodes.length||d}}();if(c){var y=document.implementation.createHTMLDocument("template"),W=!0,v=document.createElement("style");v.textContent="template{display:none;}";var ua=document.head;ua.insertBefore(v,ua.firstElementChild);a.prototype=Object.create(HTMLElement.prototype);var ea=!document.createElement("div").hasOwnProperty("innerHTML");a.U=function(p){if(!p.content&&p.namespaceURI===
	document.documentElement.namespaceURI){p.content=y.createDocumentFragment();for(var r;r=p.firstChild;)l.call(p.content,r);if(ea)p.__proto__=a.prototype;else if(p.cloneNode=function(B){return a.b(this,B)},W)try{n(p),I(p);}catch(B){W=!1;}a.a(p.content);}};var va={option:["select"],thead:["table"],col:["colgroup","table"],tr:["tbody","table"],th:["tr","tbody","table"],td:["tr","tbody","table"]},n=function(p){Object.defineProperty(p,"innerHTML",{get:function(){return xa(this)},set:function(r){var B=va[(/<([a-z][^/\0>\x20\t\r\n\f]+)/i.exec(r)||
	["",""])[1].toLowerCase()];if(B)for(var K=0;K<B.length;K++)r="<"+B[K]+">"+r+"</"+B[K]+">";y.body.innerHTML=r;for(a.a(y);this.content.firstChild;)k.call(this.content,this.content.firstChild);r=y.body;if(B)for(K=0;K<B.length;K++)r=r.lastChild;for(;r.firstChild;)l.call(this.content,r.firstChild);},configurable:!0});},I=function(p){Object.defineProperty(p,"outerHTML",{get:function(){return "<template>"+this.innerHTML+"</template>"},set:function(r){if(this.parentNode){y.body.innerHTML=r;for(r=this.ownerDocument.createDocumentFragment();y.body.firstChild;)l.call(r,
	y.body.firstChild);m.call(this.parentNode,r,this);}else throw Error("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");},configurable:!0});};n(a.prototype);I(a.prototype);a.a=function(p){p=b(p,"template");for(var r=0,B=p.length,K;r<B&&(K=p[r]);r++)a.U(K);};document.addEventListener("DOMContentLoaded",function(){a.a(document);});Document.prototype.createElement=function(){var p=g.apply(this,arguments);"template"===p.localName&&a.U(p);return p};DOMParser.prototype.parseFromString=
	function(){var p=q.apply(this,arguments);a.a(p);return p};Object.defineProperty(HTMLElement.prototype,"innerHTML",{get:function(){return xa(this)},set:function(p){H.set.call(this,p);a.a(this);},configurable:!0,enumerable:!0});var ka=/[&\u00A0"]/g,bc=/[&\u00A0<>]/g,gb=function(p){switch(p){case "&":return "&amp;";case "<":return "&lt;";case ">":return "&gt;";case '"':return "&quot;";case "\u00a0":return "&nbsp;"}};v=function(p){for(var r={},B=0;B<p.length;B++)r[p[B]]=!0;return r};var Sa=v("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),
	hb=v("style script xmp iframe noembed noframes plaintext noscript".split(" ")),xa=function(p,r){"template"===p.localName&&(p=p.content);for(var B="",K=r?r(p):C.get.call(p),Z=0,ja=K.length,ta;Z<ja&&(ta=K[Z]);Z++){a:{var z=ta;var R=p;var fb=r;switch(z.nodeType){case Node.ELEMENT_NODE:for(var cc=z.localName,ib="<"+cc,rg=z.attributes,Bd=0;R=rg[Bd];Bd++)ib+=" "+R.name+'="'+R.value.replace(ka,gb)+'"';ib+=">";z=Sa[cc]?ib:ib+xa(z,fb)+"</"+cc+">";break a;case Node.TEXT_NODE:z=z.data;z=R&&hb[R.localName]?z:
	z.replace(bc,gb);break a;case Node.COMMENT_NODE:z="\x3c!--"+z.data+"--\x3e";break a;default:throw window.console.error(z),Error("not implemented");}}B+=z;}return B};}if(c||M){a.b=function(p,r){var B=f.call(p,!1);this.U&&this.U(B);r&&(l.call(B.content,f.call(p.content,!0)),J(B.content,p.content));return B};var J=function(p,r){if(r.querySelectorAll&&(r=b(r,"template"),0!==r.length)){p=b(p,"template");for(var B=0,K=p.length,Z,ja;B<K;B++)ja=r[B],Z=p[B],a&&a.U&&a.U(ja),m.call(Z.parentNode,u.call(ja,!0),
	Z);}},u=Node.prototype.cloneNode=function(p){if(!e&&d&&this instanceof DocumentFragment)if(p)var r=G.call(this.ownerDocument,this,!0);else return this.ownerDocument.createDocumentFragment();else this.nodeType===Node.ELEMENT_NODE&&"template"===this.localName&&this.namespaceURI==document.documentElement.namespaceURI?r=a.b(this,p):r=f.call(this,p);p&&J(r,this);return r},G=Document.prototype.importNode=function(p,r){r=r||!1;if("template"===p.localName)return a.b(p,r);var B=h.call(this,p,r);if(r){J(B,p);
	p=b(B,'script:not([type]),script[type="application/javascript"],script[type="text/javascript"]');for(var K,Z=0;Z<p.length;Z++){K=p[Z];r=g.call(document,"script");r.textContent=K.textContent;for(var ja=K.attributes,ta=0,z;ta<ja.length;ta++)z=ja[ta],r.setAttribute(z.name,z.value);m.call(K.parentNode,r,K);}}return B};}c&&(window.HTMLTemplateElement=a);})();var Oa=setTimeout;function Pa(){}function Qa(a,b){return function(){a.apply(b,arguments);}}function x(a){if(!(this instanceof x))throw new TypeError("Promises must be constructed via new");if("function"!==typeof a)throw new TypeError("not a function");this.I=0;this.za=!1;this.C=void 0;this.W=[];Ra(a,this);}
	function Ta(a,b){for(;3===a.I;)a=a.C;0===a.I?a.W.push(b):(a.za=!0,Ua(function(){var c=1===a.I?b.Ya:b.Za;if(null===c)(1===a.I?Va:Wa)(b.va,a.C);else {try{var d=c(a.C);}catch(e){Wa(b.va,e);return}Va(b.va,d);}}));}function Va(a,b){try{if(b===a)throw new TypeError("A promise cannot be resolved with itself.");if(b&&("object"===typeof b||"function"===typeof b)){var c=b.then;if(b instanceof x){a.I=3;a.C=b;Xa(a);return}if("function"===typeof c){Ra(Qa(c,b),a);return}}a.I=1;a.C=b;Xa(a);}catch(d){Wa(a,d);}}
	function Wa(a,b){a.I=2;a.C=b;Xa(a);}function Xa(a){2===a.I&&0===a.W.length&&Ua(function(){a.za||"undefined"!==typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",a.C);});for(var b=0,c=a.W.length;b<c;b++)Ta(a,a.W[b]);a.W=null;}function Ya(a,b,c){this.Ya="function"===typeof a?a:null;this.Za="function"===typeof b?b:null;this.va=c;}function Ra(a,b){var c=!1;try{a(function(d){c||(c=!0,Va(b,d));},function(d){c||(c=!0,Wa(b,d));});}catch(d){c||(c=!0,Wa(b,d));}}
	x.prototype["catch"]=function(a){return this.then(null,a)};x.prototype.then=function(a,b){var c=new this.constructor(Pa);Ta(this,new Ya(a,b,c));return c};x.prototype["finally"]=function(a){var b=this.constructor;return this.then(function(c){return b.resolve(a()).then(function(){return c})},function(c){return b.resolve(a()).then(function(){return b.reject(c)})})};
	function Za(a){return new x(function(b,c){function d(h,k){try{if(k&&("object"===typeof k||"function"===typeof k)){var l=k.then;if("function"===typeof l){l.call(k,function(m){d(h,m);},c);return}}e[h]=k;0===--f&&b(e);}catch(m){c(m);}}if(!a||"undefined"===typeof a.length)return c(new TypeError("Promise.all accepts an array"));var e=Array.prototype.slice.call(a);if(0===e.length)return b([]);for(var f=e.length,g=0;g<e.length;g++)d(g,e[g]);})}
	function $a(a){return a&&"object"===typeof a&&a.constructor===x?a:new x(function(b){b(a);})}function ab(a){return new x(function(b,c){c(a);})}function bb(a){return new x(function(b,c){if(!a||"undefined"===typeof a.length)return c(new TypeError("Promise.race accepts an array"));for(var d=0,e=a.length;d<e;d++)$a(a[d]).then(b,c);})}var Ua="function"===typeof setImmediate&&function(a){setImmediate(a);}||function(a){Oa(a,0);};/*

	Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	This code may only be used under the BSD style license found at
	http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
	http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
	found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
	part of the polymer project is also subject to an additional IP rights grant
	found at http://polymer.github.io/PATENTS.txt
	*/
	if(!window.Promise){window.Promise=x;x.prototype.then=x.prototype.then;x.all=Za;x.race=bb;x.resolve=$a;x.reject=ab;var cb=document.createTextNode(""),db=[];(new MutationObserver(function(){for(var a=db.length,b=0;b<a;b++)db[b]();db.splice(0,a);})).observe(cb,{characterData:!0});Ua=function(a){db.push(a);cb.textContent=0<cb.textContent.length?"":"a";};}(function(a,b){if(!(b in a)){var c=typeof commonjsGlobal===typeof c?window:commonjsGlobal,d=0,e=""+Math.random(),f="__\u0001symbol@@"+e,g=a.getOwnPropertyNames,h=a.getOwnPropertyDescriptor,k=a.create,l=a.keys,m=a.freeze||a,q=a.defineProperty,H=a.defineProperties,C=h(a,"getOwnPropertyNames"),t=a.prototype,F=t.hasOwnProperty,E=t.propertyIsEnumerable,M=t.toString,y=function(J,u,G){F.call(J,f)||q(J,f,{enumerable:!1,configurable:!1,writable:!1,value:{}});J[f]["@@"+u]=G;},W=function(J,u){var G=k(J);g(u).forEach(function(p){va.call(u,
	p)&&Sa(G,p,u[p]);});return G},v=function(){},ua=function(J){return J!=f&&!F.call(ka,J)},ea=function(J){return J!=f&&F.call(ka,J)},va=function(J){var u=""+J;return ea(u)?F.call(this,u)&&this[f]["@@"+u]:E.call(this,J)},n=function(J){q(t,J,{enumerable:!1,configurable:!0,get:v,set:function(u){xa(this,J,{enumerable:!1,configurable:!0,writable:!0,value:u});y(this,J,!0);}});return m(ka[J]=q(a(J),"constructor",bc))},I=function G(u){if(this instanceof G)throw new TypeError("Symbol is not a constructor");return n("__\u0001symbol:".concat(u||
	"",e,++d))},ka=k(null),bc={value:I},gb=function(u){return ka[u]},Sa=function(u,G,p){var r=""+G;if(ea(r)){G=xa;if(p.enumerable){var B=k(p);B.enumerable=!1;}else B=p;G(u,r,B);y(u,r,!!p.enumerable);}else q(u,G,p);return u},hb=function(u){return g(u).filter(ea).map(gb)};C.value=Sa;q(a,"defineProperty",C);C.value=hb;q(a,b,C);C.value=function(u){return g(u).filter(ua)};q(a,"getOwnPropertyNames",C);C.value=function(u,G){var p=hb(G);p.length?l(G).concat(p).forEach(function(r){va.call(G,r)&&Sa(u,r,G[r]);}):H(u,
	G);return u};q(a,"defineProperties",C);C.value=va;q(t,"propertyIsEnumerable",C);C.value=I;q(c,"Symbol",C);C.value=function(u){u="__\u0001symbol:".concat("__\u0001symbol:",u,e);return u in t?ka[u]:n(u)};q(I,"for",C);C.value=function(u){if(ua(u))throw new TypeError(u+" is not a symbol");if(F.call(ka,u)&&(u=u.slice(10),"__\u0001symbol:"===u.slice(0,10)&&(u=u.slice(10),u!==e)))return u=u.slice(0,u.length-e.length),0<u.length?u:void 0};q(I,"keyFor",C);C.value=function(u,G){var p=h(u,G);p&&ea(G)&&(p.enumerable=
	va.call(u,G));return p};q(a,"getOwnPropertyDescriptor",C);C.value=function(u,G){return 1===arguments.length||"undefined"===typeof G?k(u):W(u,G)};q(a,"create",C);C.value=function(){var u=M.call(this);return "[object String]"===u&&ea(this)?"[object Symbol]":u};q(t,"toString",C);try{if(!0===k(q({},"__\u0001symbol:",{get:function(){return q(this,"__\u0001symbol:",{value:!0})["__\u0001symbol:"]}}))["__\u0001symbol:"])var xa=q;else throw "IE11";}catch(u){xa=function(G,p,r){var B=h(t,p);delete t[p];q(G,p,
	r);q(t,p,B);};}}})(Object,"getOwnPropertySymbols");
	(function(a,b){var c=a.defineProperty,d=a.prototype,e=d.toString,f;"iterator match replace search split hasInstance isConcatSpreadable unscopables species toPrimitive toStringTag".split(" ").forEach(function(g){if(!(g in b))switch(c(b,g,{value:b(g)}),g){case "toStringTag":f=a.getOwnPropertyDescriptor(d,"toString"),f.value=function(){var h=e.call(this),k=null!=this?this[b.toStringTag]:this;return null==k?h:"[object "+k+"]"},c(d,"toString",f);}});})(Object,Symbol);
	(function(a,b,c){function d(){return this}b[a]||(b[a]=function(){var e=0,f=this,g={next:function(){var h=f.length<=e;return h?{done:h}:{done:h,value:f[e++]}}};g[a]=d;return g});c[a]||(c[a]=function(){var e=String.fromCodePoint,f=this,g=0,h=f.length,k={next:function(){var l=h<=g,m=l?"":e(f.codePointAt(g));g+=m.length;return l?{done:l}:{done:l,value:m}}};k[a]=d;return k});})(Symbol.iterator,Array.prototype,String.prototype);/*

	Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
	This code may only be used under the BSD style license found at
	http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
	http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
	found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
	part of the polymer project is also subject to an additional IP rights grant
	found at http://polymer.github.io/PATENTS.txt
	*/
	var eb=Object.prototype.toString;Object.prototype.toString=function(){return void 0===this?"[object Undefined]":null===this?"[object Null]":eb.call(this)};Object.keys=function(a){return Object.getOwnPropertyNames(a).filter(function(b){return (b=Object.getOwnPropertyDescriptor(a,b))&&b.enumerable})};da();ia();
	String.prototype[Symbol.iterator]&&String.prototype.codePointAt||(da(),ia(),String.prototype[Symbol.iterator]=function b(){var c,d=this;return Ga(b,function(e){1==e.a&&(c=0);if(3!=e.a)return c<d.length?e=Aa(e,d[c]):(e.a=0,e=void 0),e;c++;e.a=2;})});da();ia();
	Set.prototype[Symbol.iterator]||(da(),ia(),Set.prototype[Symbol.iterator]=function b(){var c,d=this,e;return Ga(b,function(f){1==f.a&&(c=[],d.forEach(function(g){c.push(g);}),e=0);if(3!=f.a)return e<c.length?f=Aa(f,c[e]):(f.a=0,f=void 0),f;e++;f.a=2;})});da();ia();
	Map.prototype[Symbol.iterator]||(da(),ia(),Map.prototype[Symbol.iterator]=function b(){var c,d=this,e;return Ga(b,function(f){1==f.a&&(c=[],d.forEach(function(g,h){c.push([h,g]);}),e=0);if(3!=f.a)return e<c.length?f=Aa(f,c[e]):(f.a=0,f=void 0),f;e++;f.a=2;})});/*

	 Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
	 This code may only be used under the BSD style license found at
	 http://polymer.github.io/LICENSE.txt The complete set of authors may be found
	 at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
	 be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
	 Google as part of the polymer project is also subject to an additional IP
	 rights grant found at http://polymer.github.io/PATENTS.txt
	*/
	var jb=window;jb.WebComponents=jb.WebComponents||{flags:{}};var kb=document.querySelector('script[src*="webcomponents-bundle"]'),lb=/wc-(.+)/,mb={};if(!mb.noOpts){location.search.slice(1).split("&").forEach(function(a){a=a.split("=");var b;a[0]&&(b=a[0].match(lb))&&(mb[b[1]]=a[1]||!0);});if(kb)for(var nb=0,ob=void 0;ob=kb.attributes[nb];nb++)"src"!==ob.name&&(mb[ob.name]=ob.value||!0);var pb={};mb.log&&mb.log.split&&mb.log.split(",").forEach(function(a){pb[a]=!0;});mb.log=pb;}
	jb.WebComponents.flags=mb;var qb=mb.shadydom;if(qb){jb.ShadyDOM=jb.ShadyDOM||{};jb.ShadyDOM.force=qb;var rb=mb.noPatch;jb.ShadyDOM.noPatch="true"===rb?!0:rb;}var sb=mb.register||mb.ce;sb&&window.customElements&&(jb.customElements.forcePolyfill=sb);/*

	Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
	This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	Code distributed by Google as part of the polymer project is also
	subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	*/
	function tb(){}tb.prototype.toJSON=function(){return {}};function A(a){a.__shady||(a.__shady=new tb);return a.__shady}function D(a){return a&&a.__shady}var L=window.ShadyDOM||{};L.Ua=!(!Element.prototype.attachShadow||!Node.prototype.getRootNode);var ub=Object.getOwnPropertyDescriptor(Node.prototype,"firstChild");L.B=!!(ub&&ub.configurable&&ub.get);L.sa=L.force||!L.Ua;L.D=L.noPatch||!1;L.aa=L.preferPerformance;L.ua="on-demand"===L.D;L.Ia=navigator.userAgent.match("Trident");function vb(a){return (a=D(a))&&void 0!==a.firstChild}function N(a){return a instanceof ShadowRoot}function wb(a){return (a=(a=D(a))&&a.root)&&xb(a)}
	var yb=Element.prototype,zb=yb.matches||yb.matchesSelector||yb.mozMatchesSelector||yb.msMatchesSelector||yb.oMatchesSelector||yb.webkitMatchesSelector,Ab=document.createTextNode(""),Bb=0,Cb=[];(new MutationObserver(function(){for(;Cb.length;)try{Cb.shift()();}catch(a){throw Ab.textContent=Bb++,a;}})).observe(Ab,{characterData:!0});function Db(a){Cb.push(a);Ab.textContent=Bb++;}
	var Eb=document.contains?function(a,b){return a.__shady_native_contains(b)}:function(a,b){return a===b||a.documentElement&&a.documentElement.__shady_native_contains(b)};function Fb(a,b){for(;b;){if(b==a)return !0;b=b.__shady_parentNode;}return !1}
	function Gb(a){for(var b=a.length-1;0<=b;b--){var c=a[b],d=c.getAttribute("id")||c.getAttribute("name");d&&"length"!==d&&isNaN(d)&&(a[d]=c);}a.item=function(e){return a[e]};a.namedItem=function(e){if("length"!==e&&isNaN(e)&&a[e])return a[e];for(var f=ma(a),g=f.next();!g.done;g=f.next())if(g=g.value,(g.getAttribute("id")||g.getAttribute("name"))==e)return g;return null};return a}function Hb(a){var b=[];for(a=a.__shady_native_firstChild;a;a=a.__shady_native_nextSibling)b.push(a);return b}
	function Ib(a){var b=[];for(a=a.__shady_firstChild;a;a=a.__shady_nextSibling)b.push(a);return b}function Jb(a,b,c){c.configurable=!0;if(c.value)a[b]=c.value;else try{Object.defineProperty(a,b,c);}catch(d){}}function O(a,b,c,d){c=void 0===c?"":c;for(var e in b)d&&0<=d.indexOf(e)||Jb(a,c+e,b[e]);}function Kb(a,b){for(var c in b)c in a&&Jb(a,c,b[c]);}function P(a){var b={};Object.getOwnPropertyNames(a).forEach(function(c){b[c]=Object.getOwnPropertyDescriptor(a,c);});return b}
	function Lb(a,b){for(var c=Object.getOwnPropertyNames(b),d=0,e;d<c.length;d++)e=c[d],a[e]=b[e];}var Mb=[],Nb;function Ob(a){Nb||(Nb=!0,Db(Pb));Mb.push(a);}function Pb(){Nb=!1;for(var a=!!Mb.length;Mb.length;)Mb.shift()();return a}Pb.list=Mb;function Qb(){this.a=!1;this.addedNodes=[];this.removedNodes=[];this.ja=new Set;}function Rb(a){a.a||(a.a=!0,Db(function(){a.flush();}));}Qb.prototype.flush=function(){if(this.a){this.a=!1;var a=this.takeRecords();a.length&&this.ja.forEach(function(b){b(a);});}};Qb.prototype.takeRecords=function(){if(this.addedNodes.length||this.removedNodes.length){var a=[{addedNodes:this.addedNodes,removedNodes:this.removedNodes}];this.addedNodes=[];this.removedNodes=[];return a}return []};
	function Sb(a,b){var c=A(a);c.Z||(c.Z=new Qb);c.Z.ja.add(b);var d=c.Z;return {Ma:b,S:d,Na:a,takeRecords:function(){return d.takeRecords()}}}function Tb(a){var b=a&&a.S;b&&(b.ja.delete(a.Ma),b.ja.size||(A(a.Na).Z=null));}
	function Ub(a,b){var c=b.getRootNode();return a.map(function(d){var e=c===d.target.getRootNode();if(e&&d.addedNodes){if(e=[].slice.call(d.addedNodes).filter(function(f){return c===f.getRootNode()}),e.length)return d=Object.create(d),Object.defineProperty(d,"addedNodes",{value:e,configurable:!0}),d}else if(e)return d}).filter(function(d){return d})}var Vb=/[&\u00A0"]/g,Wb=/[&\u00A0<>]/g;function Xb(a){switch(a){case "&":return "&amp;";case "<":return "&lt;";case ">":return "&gt;";case '"':return "&quot;";case "\u00a0":return "&nbsp;"}}function Yb(a){for(var b={},c=0;c<a.length;c++)b[a[c]]=!0;return b}var Zb=Yb("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),$b=Yb("style script xmp iframe noembed noframes plaintext noscript".split(" "));
	function ac(a,b){"template"===a.localName&&(a=a.content);for(var c="",d=b?b(a):a.childNodes,e=0,f=d.length,g=void 0;e<f&&(g=d[e]);e++){a:{var h=g;var k=a,l=b;switch(h.nodeType){case Node.ELEMENT_NODE:k=h.localName;for(var m="<"+k,q=h.attributes,H=0,C;C=q[H];H++)m+=" "+C.name+'="'+C.value.replace(Vb,Xb)+'"';m+=">";h=Zb[k]?m:m+ac(h,l)+"</"+k+">";break a;case Node.TEXT_NODE:h=h.data;h=k&&$b[k.localName]?h:h.replace(Wb,Xb);break a;case Node.COMMENT_NODE:h="\x3c!--"+h.data+"--\x3e";break a;default:throw window.console.error(h),
	Error("not implemented");}}c+=h;}return c}var dc=L.B,ec={querySelector:function(a){return this.__shady_native_querySelector(a)},querySelectorAll:function(a){return this.__shady_native_querySelectorAll(a)}},fc={};function gc(a){fc[a]=function(b){return b["__shady_native_"+a]};}function hc(a,b){O(a,b,"__shady_native_");for(var c in b)gc(c);}function Q(a,b){b=void 0===b?[]:b;for(var c=0;c<b.length;c++){var d=b[c],e=Object.getOwnPropertyDescriptor(a,d);e&&(Object.defineProperty(a,"__shady_native_"+d,e),e.value?ec[d]||(ec[d]=e.value):gc(d));}}
	var ic=document.createTreeWalker(document,NodeFilter.SHOW_ALL,null,!1),jc=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT,null,!1),kc=document.implementation.createHTMLDocument("inert");function lc(a){for(var b;b=a.__shady_native_firstChild;)a.__shady_native_removeChild(b);}var mc=["firstElementChild","lastElementChild","children","childElementCount"],nc=["querySelector","querySelectorAll"];
	function oc(){var a=["dispatchEvent","addEventListener","removeEventListener"];window.EventTarget?Q(window.EventTarget.prototype,a):(Q(Node.prototype,a),Q(Window.prototype,a));dc?Q(Node.prototype,"parentNode firstChild lastChild previousSibling nextSibling childNodes parentElement textContent".split(" ")):hc(Node.prototype,{parentNode:{get:function(){ic.currentNode=this;return ic.parentNode()}},firstChild:{get:function(){ic.currentNode=this;return ic.firstChild()}},lastChild:{get:function(){ic.currentNode=
	this;return ic.lastChild()}},previousSibling:{get:function(){ic.currentNode=this;return ic.previousSibling()}},nextSibling:{get:function(){ic.currentNode=this;return ic.nextSibling()}},childNodes:{get:function(){var b=[];ic.currentNode=this;for(var c=ic.firstChild();c;)b.push(c),c=ic.nextSibling();return b}},parentElement:{get:function(){jc.currentNode=this;return jc.parentNode()}},textContent:{get:function(){switch(this.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:for(var b=
	document.createTreeWalker(this,NodeFilter.SHOW_TEXT,null,!1),c="",d;d=b.nextNode();)c+=d.nodeValue;return c;default:return this.nodeValue}},set:function(b){if("undefined"===typeof b||null===b)b="";switch(this.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:lc(this);(0<b.length||this.nodeType===Node.ELEMENT_NODE)&&this.__shady_native_insertBefore(document.createTextNode(b),void 0);break;default:this.nodeValue=b;}}}});Q(Node.prototype,"appendChild insertBefore removeChild replaceChild cloneNode contains".split(" "));
	Q(HTMLElement.prototype,["parentElement","contains"]);a={firstElementChild:{get:function(){jc.currentNode=this;return jc.firstChild()}},lastElementChild:{get:function(){jc.currentNode=this;return jc.lastChild()}},children:{get:function(){var b=[];jc.currentNode=this;for(var c=jc.firstChild();c;)b.push(c),c=jc.nextSibling();return Gb(b)}},childElementCount:{get:function(){return this.children?this.children.length:0}}};dc?(Q(Element.prototype,mc),Q(Element.prototype,["previousElementSibling","nextElementSibling",
	"innerHTML","className"]),Q(HTMLElement.prototype,["children","innerHTML","className"])):(hc(Element.prototype,a),hc(Element.prototype,{previousElementSibling:{get:function(){jc.currentNode=this;return jc.previousSibling()}},nextElementSibling:{get:function(){jc.currentNode=this;return jc.nextSibling()}},innerHTML:{get:function(){return ac(this,Hb)},set:function(b){var c="template"===this.localName?this.content:this;lc(c);var d=this.localName||"div";d=this.namespaceURI&&this.namespaceURI!==kc.namespaceURI?
	kc.createElementNS(this.namespaceURI,d):kc.createElement(d);d.innerHTML=b;for(b="template"===this.localName?d.content:d;d=b.__shady_native_firstChild;)c.__shady_native_insertBefore(d,void 0);}},className:{get:function(){return this.getAttribute("class")||""},set:function(b){this.setAttribute("class",b);}}}));Q(Element.prototype,"setAttribute getAttribute hasAttribute removeAttribute focus blur".split(" "));Q(Element.prototype,nc);Q(HTMLElement.prototype,["focus","blur"]);window.HTMLTemplateElement&&
	Q(window.HTMLTemplateElement.prototype,["innerHTML"]);dc?Q(DocumentFragment.prototype,mc):hc(DocumentFragment.prototype,a);Q(DocumentFragment.prototype,nc);dc?(Q(Document.prototype,mc),Q(Document.prototype,["activeElement"])):hc(Document.prototype,a);Q(Document.prototype,["importNode","getElementById"]);Q(Document.prototype,nc);}var pc=P({get childNodes(){return this.__shady_childNodes},get firstChild(){return this.__shady_firstChild},get lastChild(){return this.__shady_lastChild},get childElementCount(){return this.__shady_childElementCount},get children(){return this.__shady_children},get firstElementChild(){return this.__shady_firstElementChild},get lastElementChild(){return this.__shady_lastElementChild},get shadowRoot(){return this.__shady_shadowRoot}}),qc=P({get textContent(){return this.__shady_textContent},set textContent(a){this.__shady_textContent=
	a;},get innerHTML(){return this.__shady_innerHTML},set innerHTML(a){return this.__shady_innerHTML=a}}),rc=P({get parentElement(){return this.__shady_parentElement},get parentNode(){return this.__shady_parentNode},get nextSibling(){return this.__shady_nextSibling},get previousSibling(){return this.__shady_previousSibling},get nextElementSibling(){return this.__shady_nextElementSibling},get previousElementSibling(){return this.__shady_previousElementSibling},get className(){return this.__shady_className},
	set className(a){return this.__shady_className=a}});function sc(a){for(var b in a){var c=a[b];c&&(c.enumerable=!1);}}sc(pc);sc(qc);sc(rc);var tc=L.B||!0===L.D,uc=tc?function(){}:function(a){var b=A(a);b.Ka||(b.Ka=!0,Kb(a,rc));},vc=tc?function(){}:function(a){var b=A(a);b.Ja||(b.Ja=!0,Kb(a,pc),window.customElements&&window.customElements.polyfillWrapFlushCallback&&!L.D||Kb(a,qc));};var wc="__eventWrappers"+Date.now(),xc=function(){var a=Object.getOwnPropertyDescriptor(Event.prototype,"composed");return a?function(b){return a.get.call(b)}:null}(),yc=function(){function a(){}var b=!1,c={get capture(){b=!0;return !1}};window.addEventListener("test",a,c);window.removeEventListener("test",a,c);return b}();function zc(a){if(a&&"object"===typeof a){var b=!!a.capture;var c=!!a.once;var d=!!a.passive;var e=a.O;}else b=!!a,d=c=!1;return {Ga:e,capture:b,once:c,passive:d,Fa:yc?a:b}}
	var Ac={blur:!0,focus:!0,focusin:!0,focusout:!0,click:!0,dblclick:!0,mousedown:!0,mouseenter:!0,mouseleave:!0,mousemove:!0,mouseout:!0,mouseover:!0,mouseup:!0,wheel:!0,beforeinput:!0,input:!0,keydown:!0,keyup:!0,compositionstart:!0,compositionupdate:!0,compositionend:!0,touchstart:!0,touchend:!0,touchmove:!0,touchcancel:!0,pointerover:!0,pointerenter:!0,pointerdown:!0,pointermove:!0,pointerup:!0,pointercancel:!0,pointerout:!0,pointerleave:!0,gotpointercapture:!0,lostpointercapture:!0,dragstart:!0,
	drag:!0,dragenter:!0,dragleave:!0,dragover:!0,drop:!0,dragend:!0,DOMActivate:!0,DOMFocusIn:!0,DOMFocusOut:!0,keypress:!0},Bc={DOMAttrModified:!0,DOMAttributeNameChanged:!0,DOMCharacterDataModified:!0,DOMElementNameChanged:!0,DOMNodeInserted:!0,DOMNodeInsertedIntoDocument:!0,DOMNodeRemoved:!0,DOMNodeRemovedFromDocument:!0,DOMSubtreeModified:!0};function Cc(a){return a instanceof Node?a.__shady_getRootNode():a}
	function Dc(a,b){var c=[],d=a;for(a=Cc(a);d;)c.push(d),d.__shady_assignedSlot?d=d.__shady_assignedSlot:d.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&d.host&&(b||d!==a)?d=d.host:d=d.__shady_parentNode;c[c.length-1]===document&&c.push(window);return c}function Ec(a){a.__composedPath||(a.__composedPath=Dc(a.target,!0));return a.__composedPath}function Fc(a,b){if(!N)return a;a=Dc(a,!0);for(var c=0,d,e=void 0,f,g=void 0;c<b.length;c++)if(d=b[c],f=Cc(d),f!==e&&(g=a.indexOf(f),e=f),!N(f)||-1<g)return d}
	function Gc(a){function b(c,d){c=new a(c,d);c.__composed=d&&!!d.composed;return c}b.__proto__=a;b.prototype=a.prototype;return b}var Hc={focus:!0,blur:!0};function Ic(a){return a.__target!==a.target||a.__relatedTarget!==a.relatedTarget}function Jc(a,b,c){if(c=b.__handlers&&b.__handlers[a.type]&&b.__handlers[a.type][c])for(var d=0,e;(e=c[d])&&(!Ic(a)||a.target!==a.relatedTarget)&&(e.call(b,a),!a.__immediatePropagationStopped);d++);}
	function Kc(a){var b=a.composedPath(),c=b.map(function(k){return Fc(k,b)}),d=a.bubbles;Object.defineProperty(a,"currentTarget",{configurable:!0,enumerable:!0,get:function(){return g}});var e=Event.CAPTURING_PHASE;Object.defineProperty(a,"eventPhase",{configurable:!0,enumerable:!0,get:function(){return e}});for(var f=b.length-1;0<=f;f--){var g=b[f];e=g===c[f]?Event.AT_TARGET:Event.CAPTURING_PHASE;Jc(a,g,"capture");if(a.ma)return}for(f=0;f<b.length;f++){g=b[f];var h=g===c[f];if(h||d)if(e=h?Event.AT_TARGET:
	Event.BUBBLING_PHASE,Jc(a,g,"bubble"),a.ma)return}e=0;g=null;}function Lc(a,b,c,d,e,f){for(var g=0;g<a.length;g++){var h=a[g],k=h.type,l=h.capture,m=h.once,q=h.passive;if(b===h.node&&c===k&&d===l&&e===m&&f===q)return g}return -1}function Mc(a){Pb();return !L.aa&&this instanceof Node&&!Eb(document,this)?(a.__target||Nc(a,this),Kc(a)):this.__shady_native_dispatchEvent(a)}
	function Oc(a,b,c){var d=zc(c),e=d.capture,f=d.once,g=d.passive,h=d.Ga;d=d.Fa;if(b){var k=typeof b;if("function"===k||"object"===k)if("object"!==k||b.handleEvent&&"function"===typeof b.handleEvent){if(Bc[a])return this.__shady_native_addEventListener(a,b,d);var l=h||this;if(h=b[wc]){if(-1<Lc(h,l,a,e,f,g))return}else b[wc]=[];h=function(m){f&&this.__shady_removeEventListener(a,b,c);m.__target||Nc(m);if(l!==this){var q=Object.getOwnPropertyDescriptor(m,"currentTarget");Object.defineProperty(m,"currentTarget",
	{get:function(){return l},configurable:!0});var H=Object.getOwnPropertyDescriptor(m,"eventPhase");Object.defineProperty(m,"eventPhase",{configurable:!0,enumerable:!0,get:function(){return e?Event.CAPTURING_PHASE:Event.BUBBLING_PHASE}});}m.__previousCurrentTarget=m.currentTarget;if(!N(l)&&"slot"!==l.localName||-1!=m.composedPath().indexOf(l))if(m.composed||-1<m.composedPath().indexOf(l))if(Ic(m)&&m.target===m.relatedTarget)m.eventPhase===Event.BUBBLING_PHASE&&m.stopImmediatePropagation();else if(m.eventPhase===
	Event.CAPTURING_PHASE||m.bubbles||m.target===l||l instanceof Window){var C="function"===k?b.call(l,m):b.handleEvent&&b.handleEvent(m);l!==this&&(q?(Object.defineProperty(m,"currentTarget",q),q=null):delete m.currentTarget,H?(Object.defineProperty(m,"eventPhase",H),H=null):delete m.eventPhase);return C}};b[wc].push({node:l,type:a,capture:e,once:f,passive:g,lb:h});this.__handlers=this.__handlers||{};this.__handlers[a]=this.__handlers[a]||{capture:[],bubble:[]};this.__handlers[a][e?"capture":"bubble"].push(h);
	Hc[a]||this.__shady_native_addEventListener(a,h,d);}}}
	function Pc(a,b,c){if(b){var d=zc(c);c=d.capture;var e=d.once,f=d.passive,g=d.Ga;d=d.Fa;if(Bc[a])return this.__shady_native_removeEventListener(a,b,d);var h=g||this;g=void 0;var k=null;try{k=b[wc];}catch(l){}k&&(e=Lc(k,h,a,c,e,f),-1<e&&(g=k.splice(e,1)[0].lb,k.length||(b[wc]=void 0)));this.__shady_native_removeEventListener(a,g||b,d);g&&this.__handlers&&this.__handlers[a]&&(a=this.__handlers[a][c?"capture":"bubble"],b=a.indexOf(g),-1<b&&a.splice(b,1));}}
	function Qc(){for(var a in Hc)window.__shady_native_addEventListener(a,function(b){b.__target||(Nc(b),Kc(b));},!0);}
	var Rc=P({get composed(){void 0===this.__composed&&(xc?this.__composed="focusin"===this.type||"focusout"===this.type||xc(this):!1!==this.isTrusted&&(this.__composed=Ac[this.type]));return this.__composed||!1},composedPath:function(){this.__composedPath||(this.__composedPath=Dc(this.__target,this.composed));return this.__composedPath},get target(){return Fc(this.currentTarget||this.__previousCurrentTarget,this.composedPath())},get relatedTarget(){if(!this.__relatedTarget)return null;this.__relatedTargetComposedPath||
	(this.__relatedTargetComposedPath=Dc(this.__relatedTarget,!0));return Fc(this.currentTarget||this.__previousCurrentTarget,this.__relatedTargetComposedPath)},stopPropagation:function(){Event.prototype.stopPropagation.call(this);this.ma=!0;},stopImmediatePropagation:function(){Event.prototype.stopImmediatePropagation.call(this);this.ma=this.__immediatePropagationStopped=!0;}});
	function Nc(a,b){b=void 0===b?a.target:b;a.__target=b;a.__relatedTarget=a.relatedTarget;if(L.B){b=Object.getPrototypeOf(a);if(!b.hasOwnProperty("__shady_patchedProto")){var c=Object.create(b);c.__shady_sourceProto=b;O(c,Rc);b.__shady_patchedProto=c;}a.__proto__=b.__shady_patchedProto;}else O(a,Rc);}var Sc=Gc(Event),Tc=Gc(CustomEvent),Uc=Gc(MouseEvent);
	function Vc(){if(!xc&&Object.getOwnPropertyDescriptor(Event.prototype,"isTrusted")){var a=function(){var b=new MouseEvent("click",{bubbles:!0,cancelable:!0,composed:!0});this.__shady_dispatchEvent(b);};Element.prototype.click?Element.prototype.click=a:HTMLElement.prototype.click&&(HTMLElement.prototype.click=a);}}
	var Wc=Object.getOwnPropertyNames(Element.prototype).filter(function(a){return "on"===a.substring(0,2)}),Xc=Object.getOwnPropertyNames(HTMLElement.prototype).filter(function(a){return "on"===a.substring(0,2)});function Yc(a){return {set:function(b){var c=A(this),d=a.substring(2);c.N||(c.N={});c.N[a]&&this.removeEventListener(d,c.N[a]);this.__shady_addEventListener(d,b);c.N[a]=b;},get:function(){var b=D(this);return b&&b.N&&b.N[a]},configurable:!0}}function Zc(a,b){return {index:a,ba:[],ia:b}}
	function $c(a,b,c,d){var e=0,f=0,g=0,h=0,k=Math.min(b-e,d-f);if(0==e&&0==f)a:{for(g=0;g<k;g++)if(a[g]!==c[g])break a;g=k;}if(b==a.length&&d==c.length){h=a.length;for(var l=c.length,m=0;m<k-g&&ad(a[--h],c[--l]);)m++;h=m;}e+=g;f+=g;b-=h;d-=h;if(0==b-e&&0==d-f)return [];if(e==b){for(b=Zc(e,0);f<d;)b.ba.push(c[f++]);return [b]}if(f==d)return [Zc(e,b-e)];k=e;g=f;d=d-g+1;h=b-k+1;b=Array(d);for(l=0;l<d;l++)b[l]=Array(h),b[l][0]=l;for(l=0;l<h;l++)b[0][l]=l;for(l=1;l<d;l++)for(m=1;m<h;m++)if(a[k+m-1]===c[g+l-1])b[l][m]=
	b[l-1][m-1];else {var q=b[l-1][m]+1,H=b[l][m-1]+1;b[l][m]=q<H?q:H;}k=b.length-1;g=b[0].length-1;d=b[k][g];for(a=[];0<k||0<g;)0==k?(a.push(2),g--):0==g?(a.push(3),k--):(h=b[k-1][g-1],l=b[k-1][g],m=b[k][g-1],q=l<m?l<h?l:h:m<h?m:h,q==h?(h==d?a.push(0):(a.push(1),d=h),k--,g--):q==l?(a.push(3),k--,d=l):(a.push(2),g--,d=m));a.reverse();b=void 0;k=[];for(g=0;g<a.length;g++)switch(a[g]){case 0:b&&(k.push(b),b=void 0);e++;f++;break;case 1:b||(b=Zc(e,0));b.ia++;e++;b.ba.push(c[f]);f++;break;case 2:b||(b=Zc(e,
	0));b.ia++;e++;break;case 3:b||(b=Zc(e,0)),b.ba.push(c[f]),f++;}b&&k.push(b);return k}function ad(a,b){return a===b}var bd=P({dispatchEvent:Mc,addEventListener:Oc,removeEventListener:Pc});var cd=null;function dd(){cd||(cd=window.ShadyCSS&&window.ShadyCSS.ScopingShim);return cd||null}function ed(a,b,c){var d=dd();return d&&"class"===b?(d.setElementClass(a,c),!0):!1}function fd(a,b){var c=dd();c&&c.unscopeNode(a,b);}function gd(a,b){var c=dd();if(!c)return !0;if(a.nodeType===Node.DOCUMENT_FRAGMENT_NODE){c=!0;for(a=a.__shady_firstChild;a;a=a.__shady_nextSibling)c=c&&gd(a,b);return c}return a.nodeType!==Node.ELEMENT_NODE?!0:c.currentScopeForNode(a)===b}
	function hd(a){if(a.nodeType!==Node.ELEMENT_NODE)return "";var b=dd();return b?b.currentScopeForNode(a):""}function id(a,b){if(a)for(a.nodeType===Node.ELEMENT_NODE&&b(a),a=a.__shady_firstChild;a;a=a.__shady_nextSibling)a.nodeType===Node.ELEMENT_NODE&&id(a,b);}var jd=window.document,kd=L.aa,ld=Object.getOwnPropertyDescriptor(Node.prototype,"isConnected"),md=ld&&ld.get;function nd(a){for(var b;b=a.__shady_firstChild;)a.__shady_removeChild(b);}function od(a){var b=D(a);if(b&&void 0!==b.la)for(b=a.__shady_firstChild;b;b=b.__shady_nextSibling)od(b);if(a=D(a))a.la=void 0;}function pd(a){var b=a;if(a&&"slot"===a.localName){var c=D(a);(c=c&&c.V)&&(b=c.length?c[0]:pd(a.__shady_nextSibling));}return b}
	function qd(a,b,c){if(a=(a=D(a))&&a.Z){if(b)if(b.nodeType===Node.DOCUMENT_FRAGMENT_NODE)for(var d=0,e=b.childNodes.length;d<e;d++)a.addedNodes.push(b.childNodes[d]);else a.addedNodes.push(b);c&&a.removedNodes.push(c);Rb(a);}}
	var xd=P({get parentNode(){var a=D(this);a=a&&a.parentNode;return void 0!==a?a:this.__shady_native_parentNode},get firstChild(){var a=D(this);a=a&&a.firstChild;return void 0!==a?a:this.__shady_native_firstChild},get lastChild(){var a=D(this);a=a&&a.lastChild;return void 0!==a?a:this.__shady_native_lastChild},get nextSibling(){var a=D(this);a=a&&a.nextSibling;return void 0!==a?a:this.__shady_native_nextSibling},get previousSibling(){var a=D(this);a=a&&a.previousSibling;return void 0!==a?a:this.__shady_native_previousSibling},
	get childNodes(){if(vb(this)){var a=D(this);if(!a.childNodes){a.childNodes=[];for(var b=this.__shady_firstChild;b;b=b.__shady_nextSibling)a.childNodes.push(b);}var c=a.childNodes;}else c=this.__shady_native_childNodes;c.item=function(d){return c[d]};return c},get parentElement(){var a=D(this);(a=a&&a.parentNode)&&a.nodeType!==Node.ELEMENT_NODE&&(a=null);return void 0!==a?a:this.__shady_native_parentElement},get isConnected(){if(md&&md.call(this))return !0;if(this.nodeType==Node.DOCUMENT_FRAGMENT_NODE)return !1;
	var a=this.ownerDocument;if(null===a||Eb(a,this))return !0;for(a=this;a&&!(a instanceof Document);)a=a.__shady_parentNode||(N(a)?a.host:void 0);return !!(a&&a instanceof Document)},get textContent(){if(vb(this)){for(var a=[],b=this.__shady_firstChild;b;b=b.__shady_nextSibling)b.nodeType!==Node.COMMENT_NODE&&a.push(b.__shady_textContent);return a.join("")}return this.__shady_native_textContent},set textContent(a){if("undefined"===typeof a||null===a)a="";switch(this.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:if(!vb(this)&&
	L.B){var b=this.__shady_firstChild;(b!=this.__shady_lastChild||b&&b.nodeType!=Node.TEXT_NODE)&&nd(this);this.__shady_native_textContent=a;}else nd(this),(0<a.length||this.nodeType===Node.ELEMENT_NODE)&&this.__shady_insertBefore(document.createTextNode(a));break;default:this.nodeValue=a;}},insertBefore:function(a,b){if(this.ownerDocument!==jd&&a.ownerDocument!==jd)return this.__shady_native_insertBefore(a,b),a;if(a===this)throw Error("Failed to execute 'appendChild' on 'Node': The new child element contains the parent.");
	if(b){var c=D(b);c=c&&c.parentNode;if(void 0!==c&&c!==this||void 0===c&&b.__shady_native_parentNode!==this)throw Error("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.");}if(b===a)return a;qd(this,a);var d=[],e=(c=rd(this))?c.host.localName:hd(this),f=a.__shady_parentNode;if(f){var g=hd(a);var h=!!c||!rd(a)||kd&&void 0!==this.__noInsertionPoint;f.__shady_removeChild(a,h);}f=!0;var k=(!kd||void 0===a.__noInsertionPoint&&void 0===
	this.__noInsertionPoint)&&!gd(a,e),l=c&&!a.__noInsertionPoint&&(!kd||a.nodeType===Node.DOCUMENT_FRAGMENT_NODE);if(l||k)k&&(g=g||hd(a)),id(a,function(m){l&&"slot"===m.localName&&d.push(m);if(k){var q=g;dd()&&(q&&fd(m,q),(q=dd())&&q.scopeNode(m,e));}});d.length&&(sd(c),c.c.push.apply(c.c,d instanceof Array?d:na(ma(d))),td(c));vb(this)&&(ud(a,this,b),h=D(this),h.root?(f=!1,wb(this)&&td(h.root)):c&&"slot"===this.localName&&(f=!1,td(c)));f?(c=N(this)?this.host:this,b?(b=pd(b),c.__shady_native_insertBefore(a,
	b)):c.__shady_native_appendChild(a)):a.ownerDocument!==this.ownerDocument&&this.ownerDocument.adoptNode(a);return a},appendChild:function(a){if(this!=a||!N(a))return this.__shady_insertBefore(a)},removeChild:function(a,b){b=void 0===b?!1:b;if(this.ownerDocument!==jd)return this.__shady_native_removeChild(a);if(a.__shady_parentNode!==this)throw Error("The node to be removed is not a child of this node: "+a);qd(this,null,a);var c=rd(a),d=c&&vd(c,a),e=D(this);if(vb(this)&&(wd(a,this),wb(this))){td(e.root);
	var f=!0;}if(dd()&&!b&&c&&a.nodeType!==Node.TEXT_NODE){var g=hd(a);id(a,function(h){fd(h,g);});}od(a);c&&((b="slot"===this.localName)&&(f=!0),(d||b)&&td(c));f||(f=N(this)?this.host:this,(!e.root&&"slot"!==a.localName||f===a.__shady_native_parentNode)&&f.__shady_native_removeChild(a));return a},replaceChild:function(a,b){this.__shady_insertBefore(a,b);this.__shady_removeChild(b);return a},cloneNode:function(a){if("template"==this.localName)return this.__shady_native_cloneNode(a);var b=this.__shady_native_cloneNode(!1);
	if(a&&b.nodeType!==Node.ATTRIBUTE_NODE){a=this.__shady_firstChild;for(var c;a;a=a.__shady_nextSibling)c=a.__shady_cloneNode(!0),b.__shady_appendChild(c);}return b},getRootNode:function(a){if(this&&this.nodeType){var b=A(this),c=b.la;void 0===c&&(N(this)?(c=this,b.la=c):(c=(c=this.__shady_parentNode)?c.__shady_getRootNode(a):this,document.documentElement.__shady_native_contains(this)&&(b.la=c)));return c}},contains:function(a){return Fb(this,a)}});var zd=P({get assignedSlot(){var a=this.__shady_parentNode;(a=a&&a.__shady_shadowRoot)&&yd(a);return (a=D(this))&&a.assignedSlot||null}});function Ad(a,b,c){var d=[];Cd(a,b,c,d);return d}function Cd(a,b,c,d){for(a=a.__shady_firstChild;a;a=a.__shady_nextSibling){var e;if(e=a.nodeType===Node.ELEMENT_NODE){e=a;var f=b,g=c,h=d,k=f(e);k&&h.push(e);g&&g(k)?e=k:(Cd(e,f,g,h),e=void 0);}if(e)break}}
	var Dd=P({get firstElementChild(){var a=D(this);if(a&&void 0!==a.firstChild){for(a=this.__shady_firstChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.__shady_nextSibling;return a}return this.__shady_native_firstElementChild},get lastElementChild(){var a=D(this);if(a&&void 0!==a.lastChild){for(a=this.__shady_lastChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.__shady_previousSibling;return a}return this.__shady_native_lastElementChild},get children(){return vb(this)?Gb(Array.prototype.filter.call(Ib(this),
	function(a){return a.nodeType===Node.ELEMENT_NODE})):this.__shady_native_children},get childElementCount(){var a=this.__shady_children;return a?a.length:0}}),Ed=P({querySelector:function(a){return Ad(this,function(b){return zb.call(b,a)},function(b){return !!b})[0]||null},querySelectorAll:function(a,b){if(b){b=Array.prototype.slice.call(this.__shady_native_querySelectorAll(a));var c=this.__shady_getRootNode();return Gb(b.filter(function(d){return d.__shady_getRootNode()==c}))}return Gb(Ad(this,function(d){return zb.call(d,
	a)}))}}),Fd=L.aa&&!L.D?Lb({},Dd):Dd;Lb(Dd,Ed);var Gd=window.document;function Hd(a,b){if("slot"===b)a=a.__shady_parentNode,wb(a)&&td(D(a).root);else if("slot"===a.localName&&"name"===b&&(b=rd(a))){if(b.a){Id(b);var c=a.La,d=Jd(a);if(d!==c){c=b.b[c];var e=c.indexOf(a);0<=e&&c.splice(e,1);c=b.b[d]||(b.b[d]=[]);c.push(a);1<c.length&&(b.b[d]=Kd(c));}}td(b);}}
	var Ld=P({get previousElementSibling(){var a=D(this);if(a&&void 0!==a.previousSibling){for(a=this.__shady_previousSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.__shady_previousSibling;return a}return this.__shady_native_previousElementSibling},get nextElementSibling(){var a=D(this);if(a&&void 0!==a.nextSibling){for(a=this.__shady_nextSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.__shady_nextSibling;return a}return this.__shady_native_nextElementSibling},get slot(){return this.getAttribute("slot")},
	set slot(a){this.__shady_setAttribute("slot",a);},get className(){return this.getAttribute("class")||""},set className(a){this.__shady_setAttribute("class",a);},setAttribute:function(a,b){this.ownerDocument!==Gd?this.__shady_native_setAttribute(a,b):ed(this,a,b)||(this.__shady_native_setAttribute(a,b),Hd(this,a));},removeAttribute:function(a){this.ownerDocument!==Gd?this.__shady_native_removeAttribute(a):ed(this,a,"")?""===this.getAttribute(a)&&this.__shady_native_removeAttribute(a):(this.__shady_native_removeAttribute(a),
	Hd(this,a));}});L.aa||Wc.forEach(function(a){Ld[a]=Yc(a);});
	var Qd=P({attachShadow:function(a){if(!this)throw Error("Must provide a host.");if(!a)throw Error("Not enough arguments.");if(a.shadyUpgradeFragment&&!L.Ia){var b=a.shadyUpgradeFragment;b.__proto__=ShadowRoot.prototype;Md(b,this,a);Nd(b,b);a=b.__noInsertionPoint?null:b.querySelectorAll("slot");b.__noInsertionPoint=void 0;if(a&&a.length){var c=b;sd(c);c.c.push.apply(c.c,a instanceof Array?a:na(ma(a)));td(b);}b.host.__shady_native_appendChild(b);}else b=new Od(Pd,this,a);return this.__CE_shadowRoot=b},
	get shadowRoot(){var a=D(this);return a&&a.bb||null}});Lb(Ld,Qd);var Rd=document.implementation.createHTMLDocument("inert"),Sd=P({get innerHTML(){return vb(this)?ac("template"===this.localName?this.content:this,Ib):this.__shady_native_innerHTML},set innerHTML(a){if("template"===this.localName)this.__shady_native_innerHTML=a;else {nd(this);var b=this.localName||"div";b=this.namespaceURI&&this.namespaceURI!==Rd.namespaceURI?Rd.createElementNS(this.namespaceURI,b):Rd.createElement(b);for(L.B?b.__shady_native_innerHTML=a:b.innerHTML=a;a=b.__shady_firstChild;)this.__shady_insertBefore(a);}}});var Td=P({blur:function(){var a=D(this);(a=(a=a&&a.root)&&a.activeElement)?a.__shady_blur():this.__shady_native_blur();}});L.aa||Xc.forEach(function(a){Td[a]=Yc(a);});var Ud=P({assignedNodes:function(a){if("slot"===this.localName){var b=this.__shady_getRootNode();b&&N(b)&&yd(b);return (b=D(this))?(a&&a.flatten?b.V:b.assignedNodes)||[]:[]}},addEventListener:function(a,b,c){if("slot"!==this.localName||"slotchange"===a)Oc.call(this,a,b,c);else {"object"!==typeof c&&(c={capture:!!c});var d=this.__shady_parentNode;if(!d)throw Error("ShadyDOM cannot attach event to slot unless it has a `parentNode`");c.O=this;d.__shady_addEventListener(a,b,c);}},removeEventListener:function(a,
	b,c){if("slot"!==this.localName||"slotchange"===a)Pc.call(this,a,b,c);else {"object"!==typeof c&&(c={capture:!!c});var d=this.__shady_parentNode;if(!d)throw Error("ShadyDOM cannot attach event to slot unless it has a `parentNode`");c.O=this;d.__shady_removeEventListener(a,b,c);}}});var Vd=P({getElementById:function(a){return ""===a?null:Ad(this,function(b){return b.id==a},function(b){return !!b})[0]||null}});var Wd=P({get activeElement(){var a=L.B?document.__shady_native_activeElement:document.activeElement;if(!a||!a.nodeType)return null;var b=!!N(this);if(!(this===document||b&&this.host!==a&&this.host.__shady_native_contains(a)))return null;for(b=rd(a);b&&b!==this;)a=b.host,b=rd(a);return this===document?b?null:a:b===this?a:null}});var Xd=window.document,Yd=P({importNode:function(a,b){if(a.ownerDocument!==Xd||"template"===a.localName)return this.__shady_native_importNode(a,b);var c=this.__shady_native_importNode(a,!1);if(b)for(a=a.__shady_firstChild;a;a=a.__shady_nextSibling)b=this.__shady_importNode(a,!0),c.__shady_appendChild(b);return c}});var Zd=P({dispatchEvent:Mc,addEventListener:Oc.bind(window),removeEventListener:Pc.bind(window)});var $d={};Object.getOwnPropertyDescriptor(HTMLElement.prototype,"parentElement")&&($d.parentElement=xd.parentElement);Object.getOwnPropertyDescriptor(HTMLElement.prototype,"contains")&&($d.contains=xd.contains);Object.getOwnPropertyDescriptor(HTMLElement.prototype,"children")&&($d.children=Dd.children);Object.getOwnPropertyDescriptor(HTMLElement.prototype,"innerHTML")&&($d.innerHTML=Sd.innerHTML);Object.getOwnPropertyDescriptor(HTMLElement.prototype,"className")&&($d.className=Ld.className);
	var ae={EventTarget:[bd],Node:[xd,window.EventTarget?null:bd],Text:[zd],Comment:[zd],CDATASection:[zd],ProcessingInstruction:[zd],Element:[Ld,Dd,zd,!L.B||"innerHTML"in Element.prototype?Sd:null,window.HTMLSlotElement?null:Ud],HTMLElement:[Td,$d],HTMLSlotElement:[Ud],DocumentFragment:[Fd,Vd],Document:[Yd,Fd,Vd,Wd],Window:[Zd]},be=L.B?null:["innerHTML","textContent"];function ce(a,b,c,d){b.forEach(function(e){return a&&e&&O(a,e,c,d)});}
	function de(a){var b=a?null:be,c;for(c in ae)ce(window[c]&&window[c].prototype,ae[c],a,b);}["Text","Comment","CDATASection","ProcessingInstruction"].forEach(function(a){var b=window[a],c=Object.create(b.prototype);c.__shady_protoIsPatched=!0;ce(c,ae.EventTarget);ce(c,ae.Node);ae[a]&&ce(c,ae[a]);b.prototype.__shady_patchedProto=c;});function ee(a){a.__shady_protoIsPatched=!0;ce(a,ae.EventTarget);ce(a,ae.Node);ce(a,ae.Element);ce(a,ae.HTMLElement);ce(a,ae.HTMLSlotElement);return a}var fe=L.ua,ge=L.B;function he(a,b){if(fe&&!a.__shady_protoIsPatched&&!N(a)){var c=Object.getPrototypeOf(a),d=c.hasOwnProperty("__shady_patchedProto")&&c.__shady_patchedProto;d||(d=Object.create(c),ee(d),c.__shady_patchedProto=d);Object.setPrototypeOf(a,d);}ge||(1===b?uc(a):2===b&&vc(a));}
	function ie(a,b,c,d){he(a,1);d=d||null;var e=A(a),f=d?A(d):null;e.previousSibling=d?f.previousSibling:b.__shady_lastChild;if(f=D(e.previousSibling))f.nextSibling=a;if(f=D(e.nextSibling=d))f.previousSibling=a;e.parentNode=b;d?d===c.firstChild&&(c.firstChild=a):(c.lastChild=a,c.firstChild||(c.firstChild=a));c.childNodes=null;}
	function ud(a,b,c){he(b,2);var d=A(b);void 0!==d.firstChild&&(d.childNodes=null);if(a.nodeType===Node.DOCUMENT_FRAGMENT_NODE)for(a=a.__shady_native_firstChild;a;a=a.__shady_native_nextSibling)ie(a,b,d,c);else ie(a,b,d,c);}
	function wd(a,b){var c=A(a);b=A(b);a===b.firstChild&&(b.firstChild=c.nextSibling);a===b.lastChild&&(b.lastChild=c.previousSibling);a=c.previousSibling;var d=c.nextSibling;a&&(A(a).nextSibling=d);d&&(A(d).previousSibling=a);c.parentNode=c.previousSibling=c.nextSibling=void 0;void 0!==b.childNodes&&(b.childNodes=null);}
	function Nd(a,b){var c=A(a);if(b||void 0===c.firstChild){c.childNodes=null;var d=c.firstChild=a.__shady_native_firstChild;c.lastChild=a.__shady_native_lastChild;he(a,2);c=d;for(d=void 0;c;c=c.__shady_native_nextSibling){var e=A(c);e.parentNode=b||a;e.nextSibling=c.__shady_native_nextSibling;e.previousSibling=d||null;d=c;he(c,1);}}}var je=P({addEventListener:function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.O=c.O||this;this.host.__shady_addEventListener(a,b,c);},removeEventListener:function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.O=c.O||this;this.host.__shady_removeEventListener(a,b,c);}});function ke(a,b){O(a,je,b);O(a,Wd,b);O(a,Sd,b);O(a,Dd,b);L.D&&!b?(O(a,xd,b),O(a,Vd,b)):L.B||(O(a,rc),O(a,pc),O(a,qc));}var Pd={},le=L.deferConnectionCallbacks&&"loading"===document.readyState,me;function ne(a){var b=[];do b.unshift(a);while(a=a.__shady_parentNode);return b}function Od(a,b,c){if(a!==Pd)throw new TypeError("Illegal constructor");this.a=null;Md(this,b,c);}
	function Md(a,b,c){a.host=b;a.mode=c&&c.mode;Nd(a.host);b=A(a.host);b.root=a;b.bb="closed"!==a.mode?a:null;b=A(a);b.firstChild=b.lastChild=b.parentNode=b.nextSibling=b.previousSibling=null;if(L.preferPerformance)for(;b=a.host.__shady_native_firstChild;)a.host.__shady_native_removeChild(b);else td(a);}function td(a){a.T||(a.T=!0,Ob(function(){return yd(a)}));}
	function yd(a){var b;if(b=a.T){for(var c;a;)a:{a.T&&(c=a),b=a;a=b.host.__shady_getRootNode();if(N(a)&&(b=D(b.host))&&0<b.da)break a;a=void 0;}b=c;}(c=b)&&c._renderSelf();}
	Od.prototype._renderSelf=function(){var a=le;le=!0;this.T=!1;if(this.a){Id(this);for(var b=0,c;b<this.a.length;b++){c=this.a[b];var d=D(c),e=d.assignedNodes;d.assignedNodes=[];d.V=[];if(d.Ba=e)for(d=0;d<e.length;d++){var f=D(e[d]);f.oa=f.assignedSlot;f.assignedSlot===c&&(f.assignedSlot=null);}}for(b=this.host.__shady_firstChild;b;b=b.__shady_nextSibling)oe(this,b);for(b=0;b<this.a.length;b++){c=this.a[b];e=D(c);if(!e.assignedNodes.length)for(d=c.__shady_firstChild;d;d=d.__shady_nextSibling)oe(this,
	d,c);(d=(d=D(c.__shady_parentNode))&&d.root)&&(xb(d)||d.T)&&d._renderSelf();pe(this,e.V,e.assignedNodes);if(d=e.Ba){for(f=0;f<d.length;f++)D(d[f]).oa=null;e.Ba=null;d.length>e.assignedNodes.length&&(e.ra=!0);}e.ra&&(e.ra=!1,qe(this,c));}c=this.a;b=[];for(e=0;e<c.length;e++)d=c[e].__shady_parentNode,(f=D(d))&&f.root||!(0>b.indexOf(d))||b.push(d);for(c=0;c<b.length;c++){f=b[c];e=f===this?this.host:f;d=[];for(f=f.__shady_firstChild;f;f=f.__shady_nextSibling)if("slot"==f.localName)for(var g=D(f).V,h=0;h<
	g.length;h++)d.push(g[h]);else d.push(f);f=Hb(e);g=$c(d,d.length,f,f.length);for(var k=h=0,l=void 0;h<g.length&&(l=g[h]);h++){for(var m=0,q=void 0;m<l.ba.length&&(q=l.ba[m]);m++)q.__shady_native_parentNode===e&&e.__shady_native_removeChild(q),f.splice(l.index+k,1);k-=l.ia;}k=0;for(l=void 0;k<g.length&&(l=g[k]);k++)for(h=f[l.index],m=l.index;m<l.index+l.ia;m++)q=d[m],e.__shady_native_insertBefore(q,h),f.splice(m,0,q);}}if(!L.preferPerformance&&!this.Aa)for(b=this.host.__shady_firstChild;b;b=b.__shady_nextSibling)c=
	D(b),b.__shady_native_parentNode!==this.host||"slot"!==b.localName&&c.assignedSlot||this.host.__shady_native_removeChild(b);this.Aa=!0;le=a;me&&me();};function oe(a,b,c){var d=A(b),e=d.oa;d.oa=null;c||(c=(a=a.b[b.__shady_slot||"__catchall"])&&a[0]);c?(A(c).assignedNodes.push(b),d.assignedSlot=c):d.assignedSlot=void 0;e!==d.assignedSlot&&d.assignedSlot&&(A(d.assignedSlot).ra=!0);}
	function pe(a,b,c){for(var d=0,e=void 0;d<c.length&&(e=c[d]);d++)if("slot"==e.localName){var f=D(e).assignedNodes;f&&f.length&&pe(a,b,f);}else b.push(c[d]);}function qe(a,b){b.__shady_native_dispatchEvent(new Event("slotchange"));b=D(b);b.assignedSlot&&qe(a,b.assignedSlot);}function sd(a){a.c=a.c||[];a.a=a.a||[];a.b=a.b||{};}
	function Id(a){if(a.c&&a.c.length){for(var b=a.c,c,d=0;d<b.length;d++){var e=b[d];Nd(e);var f=e.__shady_parentNode;Nd(f);f=D(f);f.da=(f.da||0)+1;f=Jd(e);a.b[f]?(c=c||{},c[f]=!0,a.b[f].push(e)):a.b[f]=[e];a.a.push(e);}if(c)for(var g in c)a.b[g]=Kd(a.b[g]);a.c=[];}}function Jd(a){var b=a.name||a.getAttribute("name")||"__catchall";return a.La=b}
	function Kd(a){return a.sort(function(b,c){b=ne(b);for(var d=ne(c),e=0;e<b.length;e++){c=b[e];var f=d[e];if(c!==f)return b=Ib(c.__shady_parentNode),b.indexOf(c)-b.indexOf(f)}})}
	function vd(a,b){if(a.a){Id(a);var c=a.b,d;for(d in c)for(var e=c[d],f=0;f<e.length;f++){var g=e[f];if(Fb(b,g)){e.splice(f,1);var h=a.a.indexOf(g);0<=h&&(a.a.splice(h,1),(h=D(g.__shady_parentNode))&&h.da&&h.da--);f--;g=D(g);if(h=g.V)for(var k=0;k<h.length;k++){var l=h[k],m=l.__shady_native_parentNode;m&&m.__shady_native_removeChild(l);}g.V=[];g.assignedNodes=[];h=!0;}}return h}}function xb(a){Id(a);return !(!a.a||!a.a.length)}
	(function(a){a.__proto__=DocumentFragment.prototype;ke(a,"__shady_");ke(a);Object.defineProperties(a,{nodeType:{value:Node.DOCUMENT_FRAGMENT_NODE,configurable:!0},nodeName:{value:"#document-fragment",configurable:!0},nodeValue:{value:null,configurable:!0}});["localName","namespaceURI","prefix"].forEach(function(b){Object.defineProperty(a,b,{value:void 0,configurable:!0});});["ownerDocument","baseURI","isConnected"].forEach(function(b){Object.defineProperty(a,b,{get:function(){return this.host[b]},
	configurable:!0});});})(Od.prototype);
	if(window.customElements&&window.customElements.define&&L.sa&&!L.preferPerformance){var re=new Map;me=function(){var a=[];re.forEach(function(d,e){a.push([e,d]);});re.clear();for(var b=0;b<a.length;b++){var c=a[b][0];a[b][1]?c.__shadydom_connectedCallback():c.__shadydom_disconnectedCallback();}};le&&document.addEventListener("readystatechange",function(){le=!1;me();},{once:!0});var se=function(a,b,c){var d=0,e="__isConnected"+d++;if(b||c)a.prototype.connectedCallback=a.prototype.__shadydom_connectedCallback=
	function(){le?re.set(this,!0):this[e]||(this[e]=!0,b&&b.call(this));},a.prototype.disconnectedCallback=a.prototype.__shadydom_disconnectedCallback=function(){le?this.isConnected||re.set(this,!1):this[e]&&(this[e]=!1,c&&c.call(this));};return a},te=window.customElements.define,ue=function(a,b){var c=b.prototype.connectedCallback,d=b.prototype.disconnectedCallback;te.call(window.customElements,a,se(b,c,d));b.prototype.connectedCallback=c;b.prototype.disconnectedCallback=d;};window.customElements.define=
	ue;Object.defineProperty(window.CustomElementRegistry.prototype,"define",{value:ue,configurable:!0});}function rd(a){a=a.__shady_getRootNode();if(N(a))return a}function ve(a){this.node=a;}w=ve.prototype;w.addEventListener=function(a,b,c){return this.node.__shady_addEventListener(a,b,c)};w.removeEventListener=function(a,b,c){return this.node.__shady_removeEventListener(a,b,c)};w.appendChild=function(a){return this.node.__shady_appendChild(a)};w.insertBefore=function(a,b){return this.node.__shady_insertBefore(a,b)};w.removeChild=function(a){return this.node.__shady_removeChild(a)};w.replaceChild=function(a,b){return this.node.__shady_replaceChild(a,b)};
	w.cloneNode=function(a){return this.node.__shady_cloneNode(a)};w.getRootNode=function(a){return this.node.__shady_getRootNode(a)};w.contains=function(a){return this.node.__shady_contains(a)};w.dispatchEvent=function(a){return this.node.__shady_dispatchEvent(a)};w.setAttribute=function(a,b){this.node.__shady_setAttribute(a,b);};w.getAttribute=function(a){return this.node.__shady_native_getAttribute(a)};w.hasAttribute=function(a){return this.node.__shady_native_hasAttribute(a)};w.removeAttribute=function(a){this.node.__shady_removeAttribute(a);};
	w.attachShadow=function(a){return this.node.__shady_attachShadow(a)};w.focus=function(){this.node.__shady_native_focus();};w.blur=function(){this.node.__shady_blur();};w.importNode=function(a,b){if(this.node.nodeType===Node.DOCUMENT_NODE)return this.node.__shady_importNode(a,b)};w.getElementById=function(a){if(this.node.nodeType===Node.DOCUMENT_NODE)return this.node.__shady_getElementById(a)};w.querySelector=function(a){return this.node.__shady_querySelector(a)};
	w.querySelectorAll=function(a,b){return this.node.__shady_querySelectorAll(a,b)};w.assignedNodes=function(a){if("slot"===this.node.localName)return this.node.__shady_assignedNodes(a)};
	ca.Object.defineProperties(ve.prototype,{activeElement:{configurable:!0,enumerable:!0,get:function(){if(N(this.node)||this.node.nodeType===Node.DOCUMENT_NODE)return this.node.__shady_activeElement}},_activeElement:{configurable:!0,enumerable:!0,get:function(){return this.activeElement}},host:{configurable:!0,enumerable:!0,get:function(){if(N(this.node))return this.node.host}},parentNode:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_parentNode}},firstChild:{configurable:!0,
	enumerable:!0,get:function(){return this.node.__shady_firstChild}},lastChild:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_lastChild}},nextSibling:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_nextSibling}},previousSibling:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_previousSibling}},childNodes:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_childNodes}},parentElement:{configurable:!0,enumerable:!0,
	get:function(){return this.node.__shady_parentElement}},firstElementChild:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_firstElementChild}},lastElementChild:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_lastElementChild}},nextElementSibling:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_nextElementSibling}},previousElementSibling:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_previousElementSibling}},
	children:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_children}},childElementCount:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_childElementCount}},shadowRoot:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_shadowRoot}},assignedSlot:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_assignedSlot}},isConnected:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_isConnected}},innerHTML:{configurable:!0,
	enumerable:!0,get:function(){return this.node.__shady_innerHTML},set:function(a){this.node.__shady_innerHTML=a;}},textContent:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_textContent},set:function(a){this.node.__shady_textContent=a;}},slot:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_slot},set:function(a){this.node.__shady_slot=a;}},className:{configurable:!0,enumerable:!0,get:function(){return this.node.__shady_className},set:function(a){return this.node.__shady_className=
	a}}});function we(a){Object.defineProperty(ve.prototype,a,{get:function(){return this.node["__shady_"+a]},set:function(b){this.node["__shady_"+a]=b;},configurable:!0});}Wc.forEach(function(a){return we(a)});Xc.forEach(function(a){return we(a)});var xe=new WeakMap;function ye(a){if(N(a)||a instanceof ve)return a;var b=xe.get(a);b||(b=new ve(a),xe.set(a,b));return b}if(L.sa){var ze=L.B?function(a){return a}:function(a){vc(a);uc(a);return a},ShadyDOM={inUse:L.sa,patch:ze,isShadyRoot:N,enqueue:Ob,flush:Pb,flushInitial:function(a){!a.Aa&&a.T&&yd(a);},settings:L,filterMutations:Ub,observeChildren:Sb,unobserveChildren:Tb,deferConnectionCallbacks:L.deferConnectionCallbacks,preferPerformance:L.preferPerformance,handlesDynamicScoping:!0,wrap:L.D?ye:ze,wrapIfNeeded:!0===L.D?ye:function(a){return a},Wrapper:ve,composedPath:Ec,noPatch:L.D,patchOnDemand:L.ua,nativeMethods:ec,
	nativeTree:fc,patchElementProto:ee};window.ShadyDOM=ShadyDOM;oc();de("__shady_");Object.defineProperty(document,"_activeElement",Wd.activeElement);O(Window.prototype,Zd,"__shady_");L.D?L.ua&&O(Element.prototype,Qd):(de(),Vc());Qc();window.Event=Sc;window.CustomEvent=Tc;window.MouseEvent=Uc;window.ShadowRoot=Od;}var Ae=window.Document.prototype.createElement,Be=window.Document.prototype.createElementNS,Ce=window.Document.prototype.importNode,De=window.Document.prototype.prepend,Ee=window.Document.prototype.append,Fe=window.DocumentFragment.prototype.prepend,Ge=window.DocumentFragment.prototype.append,He=window.Node.prototype.cloneNode,Ie=window.Node.prototype.appendChild,Je=window.Node.prototype.insertBefore,Ke=window.Node.prototype.removeChild,Le=window.Node.prototype.replaceChild,Me=Object.getOwnPropertyDescriptor(window.Node.prototype,
	"textContent"),Ne=window.Element.prototype.attachShadow,Oe=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),Pe=window.Element.prototype.getAttribute,Qe=window.Element.prototype.setAttribute,Re=window.Element.prototype.removeAttribute,Se=window.Element.prototype.getAttributeNS,Te=window.Element.prototype.setAttributeNS,Ue=window.Element.prototype.removeAttributeNS,Ve=window.Element.prototype.insertAdjacentElement,We=window.Element.prototype.insertAdjacentHTML,Xe=window.Element.prototype.prepend,
	Ye=window.Element.prototype.append,Ze=window.Element.prototype.before,$e=window.Element.prototype.after,af=window.Element.prototype.replaceWith,bf=window.Element.prototype.remove,cf=window.HTMLElement,df=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),ef=window.HTMLElement.prototype.insertAdjacentElement,ff=window.HTMLElement.prototype.insertAdjacentHTML;var gf=new Set;"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" ").forEach(function(a){return gf.add(a)});function hf(a){var b=gf.has(a);a=/^[a-z][.0-9_a-z]*-[-.0-9_a-z]*$/.test(a);return !b&&a}var jf=document.contains?document.contains.bind(document):document.documentElement.contains.bind(document.documentElement);
	function S(a){var b=a.isConnected;if(void 0!==b)return b;if(jf(a))return !0;for(;a&&!(a.__CE_isImportDocument||a instanceof Document);)a=a.parentNode||(window.ShadowRoot&&a instanceof ShadowRoot?a.host:void 0);return !(!a||!(a.__CE_isImportDocument||a instanceof Document))}function kf(a){var b=a.children;if(b)return Array.prototype.slice.call(b);b=[];for(a=a.firstChild;a;a=a.nextSibling)a.nodeType===Node.ELEMENT_NODE&&b.push(a);return b}
	function lf(a,b){for(;b&&b!==a&&!b.nextSibling;)b=b.parentNode;return b&&b!==a?b.nextSibling:null}
	function mf(a,b,c){for(var d=a;d;){if(d.nodeType===Node.ELEMENT_NODE){var e=d;b(e);var f=e.localName;if("link"===f&&"import"===e.getAttribute("rel")){d=e.import;void 0===c&&(c=new Set);if(d instanceof Node&&!c.has(d))for(c.add(d),d=d.firstChild;d;d=d.nextSibling)mf(d,b,c);d=lf(a,e);continue}else if("template"===f){d=lf(a,e);continue}if(e=e.__CE_shadowRoot)for(e=e.firstChild;e;e=e.nextSibling)mf(e,b,c);}d=d.firstChild?d.firstChild:lf(a,d);}}function nf(){var a=!(null===of||void 0===of||!of.noDocumentConstructionObserver),b=!(null===of||void 0===of||!of.shadyDomFastWalk);this.X=[];this.a=[];this.R=!1;this.shadyDomFastWalk=b;this.jb=!a;}function pf(a,b,c,d){var e=window.ShadyDom;if(a.shadyDomFastWalk&&e&&e.inUse){if(b.nodeType===Node.ELEMENT_NODE&&c(b),b.querySelectorAll)for(a=e.nativeMethods.querySelectorAll.call(b,"*"),b=0;b<a.length;b++)c(a[b]);}else mf(b,c,d);}function qf(a,b){a.R=!0;a.X.push(b);}function rf(a,b){a.R=!0;a.a.push(b);}
	function sf(a,b){a.R&&pf(a,b,function(c){return tf(a,c)});}function tf(a,b){if(a.R&&!b.__CE_patched){b.__CE_patched=!0;for(var c=0;c<a.X.length;c++)a.X[c](b);for(c=0;c<a.a.length;c++)a.a[c](b);}}function uf(a,b){var c=[];pf(a,b,function(e){return c.push(e)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state?a.connectedCallback(d):vf(a,d);}}function wf(a,b){var c=[];pf(a,b,function(e){return c.push(e)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state&&a.disconnectedCallback(d);}}
	function xf(a,b,c){c=void 0===c?{}:c;var d=c.kb,e=c.upgrade||function(g){return vf(a,g)},f=[];pf(a,b,function(g){a.R&&tf(a,g);if("link"===g.localName&&"import"===g.getAttribute("rel")){var h=g.import;h instanceof Node&&(h.__CE_isImportDocument=!0,h.__CE_registry=document.__CE_registry);h&&"complete"===h.readyState?h.__CE_documentLoadHandled=!0:g.addEventListener("load",function(){var k=g.import;if(!k.__CE_documentLoadHandled){k.__CE_documentLoadHandled=!0;var l=new Set;d&&(d.forEach(function(m){return l.add(m)}),
	l.delete(k));xf(a,k,{kb:l,upgrade:e});}});}else f.push(g);},d);for(b=0;b<f.length;b++)e(f[b]);}
	function vf(a,b){try{var c=b.ownerDocument,d=c.__CE_registry;var e=d&&(c.defaultView||c.__CE_isImportDocument)?yf(d,b.localName):void 0;if(e&&void 0===b.__CE_state){e.constructionStack.push(b);try{try{if(new e.constructorFunction!==b)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{e.constructionStack.pop();}}catch(k){throw b.__CE_state=2,k;}b.__CE_state=1;b.__CE_definition=e;if(e.attributeChangedCallback&&b.hasAttributes()){var f=e.observedAttributes;
	for(e=0;e<f.length;e++){var g=f[e],h=b.getAttribute(g);null!==h&&a.attributeChangedCallback(b,g,null,h,null);}}S(b)&&a.connectedCallback(b);}}catch(k){zf(k);}}nf.prototype.connectedCallback=function(a){var b=a.__CE_definition;if(b.connectedCallback)try{b.connectedCallback.call(a);}catch(c){zf(c);}};nf.prototype.disconnectedCallback=function(a){var b=a.__CE_definition;if(b.disconnectedCallback)try{b.disconnectedCallback.call(a);}catch(c){zf(c);}};
	nf.prototype.attributeChangedCallback=function(a,b,c,d,e){var f=a.__CE_definition;if(f.attributeChangedCallback&&-1<f.observedAttributes.indexOf(b))try{f.attributeChangedCallback.call(a,b,c,d,e);}catch(g){zf(g);}};
	function Af(a,b,c,d){var e=b.__CE_registry;if(e&&(null===d||"http://www.w3.org/1999/xhtml"===d)&&(e=yf(e,c)))try{var f=new e.constructorFunction;if(void 0===f.__CE_state||void 0===f.__CE_definition)throw Error("Failed to construct '"+c+"': The returned value was not constructed with the HTMLElement constructor.");if("http://www.w3.org/1999/xhtml"!==f.namespaceURI)throw Error("Failed to construct '"+c+"': The constructed element's namespace must be the HTML namespace.");if(f.hasAttributes())throw Error("Failed to construct '"+
	c+"': The constructed element must not have any attributes.");if(null!==f.firstChild)throw Error("Failed to construct '"+c+"': The constructed element must not have any children.");if(null!==f.parentNode)throw Error("Failed to construct '"+c+"': The constructed element must not have a parent node.");if(f.ownerDocument!==b)throw Error("Failed to construct '"+c+"': The constructed element's owner document is incorrect.");if(f.localName!==c)throw Error("Failed to construct '"+c+"': The constructed element's local name is incorrect.");
	return f}catch(g){return zf(g),b=null===d?Ae.call(b,c):Be.call(b,d,c),Object.setPrototypeOf(b,HTMLUnknownElement.prototype),b.__CE_state=2,b.__CE_definition=void 0,tf(a,b),b}b=null===d?Ae.call(b,c):Be.call(b,d,c);tf(a,b);return b}
	function zf(a){var b=a.message,c=a.sourceURL||a.fileName||"",d=a.line||a.lineNumber||0,e=a.column||a.columnNumber||0,f=void 0;void 0===ErrorEvent.prototype.initErrorEvent?f=new ErrorEvent("error",{cancelable:!0,message:b,filename:c,lineno:d,colno:e,error:a}):(f=document.createEvent("ErrorEvent"),f.initErrorEvent("error",!1,!0,b,c,d),f.preventDefault=function(){Object.defineProperty(this,"defaultPrevented",{configurable:!0,get:function(){return !0}});});void 0===f.error&&Object.defineProperty(f,"error",
	{configurable:!0,enumerable:!0,get:function(){return a}});window.dispatchEvent(f);f.defaultPrevented||console.error(a);}function Bf(){var a=this;this.C=void 0;this.Ca=new Promise(function(b){a.a=b;});}Bf.prototype.resolve=function(a){if(this.C)throw Error("Already resolved.");this.C=a;this.a(a);};function Cf(a){var b=document;this.S=void 0;this.M=a;this.a=b;xf(this.M,this.a);"loading"===this.a.readyState&&(this.S=new MutationObserver(this.b.bind(this)),this.S.observe(this.a,{childList:!0,subtree:!0}));}function Df(a){a.S&&a.S.disconnect();}Cf.prototype.b=function(a){var b=this.a.readyState;"interactive"!==b&&"complete"!==b||Df(this);for(b=0;b<a.length;b++)for(var c=a[b].addedNodes,d=0;d<c.length;d++)xf(this.M,c[d]);};function T(a){this.fa=new Map;this.ga=new Map;this.xa=new Map;this.na=!1;this.qa=new Map;this.ea=function(b){return b()};this.P=!1;this.ha=[];this.M=a;this.ya=a.jb?new Cf(a):void 0;}w=T.prototype;w.$a=function(a,b){var c=this;if(!(b instanceof Function))throw new TypeError("Custom element constructor getters must be functions.");Ef(this,a);this.fa.set(a,b);this.ha.push(a);this.P||(this.P=!0,this.ea(function(){return Ff(c)}));};
	w.define=function(a,b){var c=this;if(!(b instanceof Function))throw new TypeError("Custom element constructors must be functions.");Ef(this,a);Gf(this,a,b);this.ha.push(a);this.P||(this.P=!0,this.ea(function(){return Ff(c)}));};function Ef(a,b){if(!hf(b))throw new SyntaxError("The element name '"+b+"' is not valid.");if(yf(a,b))throw Error("A custom element with name '"+(b+"' has already been defined."));if(a.na)throw Error("A custom element is already being defined.");}
	function Gf(a,b,c){a.na=!0;var d;try{var e=c.prototype;if(!(e instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");var f=function(m){var q=e[m];if(void 0!==q&&!(q instanceof Function))throw Error("The '"+m+"' callback must be a function.");return q};var g=f("connectedCallback");var h=f("disconnectedCallback");var k=f("adoptedCallback");var l=(d=f("attributeChangedCallback"))&&c.observedAttributes||[];}catch(m){throw m;}finally{a.na=!1;}c={localName:b,
	constructorFunction:c,connectedCallback:g,disconnectedCallback:h,adoptedCallback:k,attributeChangedCallback:d,observedAttributes:l,constructionStack:[]};a.ga.set(b,c);a.xa.set(c.constructorFunction,c);return c}w.upgrade=function(a){xf(this.M,a);};
	function Ff(a){if(!1!==a.P){a.P=!1;for(var b=[],c=a.ha,d=new Map,e=0;e<c.length;e++)d.set(c[e],[]);xf(a.M,document,{upgrade:function(k){if(void 0===k.__CE_state){var l=k.localName,m=d.get(l);m?m.push(k):a.ga.has(l)&&b.push(k);}}});for(e=0;e<b.length;e++)vf(a.M,b[e]);for(e=0;e<c.length;e++){for(var f=c[e],g=d.get(f),h=0;h<g.length;h++)vf(a.M,g[h]);(f=a.qa.get(f))&&f.resolve(void 0);}c.length=0;}}w.get=function(a){if(a=yf(this,a))return a.constructorFunction};
	w.whenDefined=function(a){if(!hf(a))return Promise.reject(new SyntaxError("'"+a+"' is not a valid custom element name."));var b=this.qa.get(a);if(b)return b.Ca;b=new Bf;this.qa.set(a,b);var c=this.ga.has(a)||this.fa.has(a);a=-1===this.ha.indexOf(a);c&&a&&b.resolve(void 0);return b.Ca};w.polyfillWrapFlushCallback=function(a){this.ya&&Df(this.ya);var b=this.ea;this.ea=function(c){return a(function(){return b(c)})};};
	function yf(a,b){var c=a.ga.get(b);if(c)return c;if(c=a.fa.get(b)){a.fa.delete(b);try{return Gf(a,b,c())}catch(d){zf(d);}}}window.CustomElementRegistry=T;T.prototype.define=T.prototype.define;T.prototype.upgrade=T.prototype.upgrade;T.prototype.get=T.prototype.get;T.prototype.whenDefined=T.prototype.whenDefined;T.prototype.polyfillDefineLazy=T.prototype.$a;T.prototype.polyfillWrapFlushCallback=T.prototype.polyfillWrapFlushCallback;function Hf(a,b,c){function d(e){return function(f){for(var g=[],h=0;h<arguments.length;++h)g[h]=arguments[h];h=[];for(var k=[],l=0;l<g.length;l++){var m=g[l];m instanceof Element&&S(m)&&k.push(m);if(m instanceof DocumentFragment)for(m=m.firstChild;m;m=m.nextSibling)h.push(m);else h.push(m);}e.apply(this,g);for(g=0;g<k.length;g++)wf(a,k[g]);if(S(this))for(g=0;g<h.length;g++)k=h[g],k instanceof Element&&uf(a,k);}}void 0!==c.prepend&&(b.prepend=d(c.prepend));void 0!==c.append&&(b.append=d(c.append));}
	function If(a){Document.prototype.createElement=function(b){return Af(a,this,b,null)};Document.prototype.importNode=function(b,c){b=Ce.call(this,b,!!c);this.__CE_registry?xf(a,b):sf(a,b);return b};Document.prototype.createElementNS=function(b,c){return Af(a,this,c,b)};Hf(a,Document.prototype,{prepend:De,append:Ee});}function Jf(a){function b(d){return function(e){for(var f=[],g=0;g<arguments.length;++g)f[g]=arguments[g];g=[];for(var h=[],k=0;k<f.length;k++){var l=f[k];l instanceof Element&&S(l)&&h.push(l);if(l instanceof DocumentFragment)for(l=l.firstChild;l;l=l.nextSibling)g.push(l);else g.push(l);}d.apply(this,f);for(f=0;f<h.length;f++)wf(a,h[f]);if(S(this))for(f=0;f<g.length;f++)h=g[f],h instanceof Element&&uf(a,h);}}var c=Element.prototype;void 0!==Ze&&(c.before=b(Ze));void 0!==$e&&(c.after=b($e));void 0!==
	af&&(c.replaceWith=function(d){for(var e=[],f=0;f<arguments.length;++f)e[f]=arguments[f];f=[];for(var g=[],h=0;h<e.length;h++){var k=e[h];k instanceof Element&&S(k)&&g.push(k);if(k instanceof DocumentFragment)for(k=k.firstChild;k;k=k.nextSibling)f.push(k);else f.push(k);}h=S(this);af.apply(this,e);for(e=0;e<g.length;e++)wf(a,g[e]);if(h)for(wf(a,this),e=0;e<f.length;e++)g=f[e],g instanceof Element&&uf(a,g);});void 0!==bf&&(c.remove=function(){var d=S(this);bf.call(this);d&&wf(a,this);});}function Kf(a){function b(e,f){Object.defineProperty(e,"innerHTML",{enumerable:f.enumerable,configurable:!0,get:f.get,set:function(g){var h=this,k=void 0;S(this)&&(k=[],pf(a,this,function(q){q!==h&&k.push(q);}));f.set.call(this,g);if(k)for(var l=0;l<k.length;l++){var m=k[l];1===m.__CE_state&&a.disconnectedCallback(m);}this.ownerDocument.__CE_registry?xf(a,this):sf(a,this);return g}});}function c(e,f){e.insertAdjacentElement=function(g,h){var k=S(h);g=f.call(this,g,h);k&&wf(a,h);S(g)&&uf(a,h);return g};}
	function d(e,f){function g(h,k){for(var l=[];h!==k;h=h.nextSibling)l.push(h);for(k=0;k<l.length;k++)xf(a,l[k]);}e.insertAdjacentHTML=function(h,k){h=h.toLowerCase();if("beforebegin"===h){var l=this.previousSibling;f.call(this,h,k);g(l||this.parentNode.firstChild,this);}else if("afterbegin"===h)l=this.firstChild,f.call(this,h,k),g(this.firstChild,l);else if("beforeend"===h)l=this.lastChild,f.call(this,h,k),g(l||this.firstChild,null);else if("afterend"===h)l=this.nextSibling,f.call(this,h,k),g(this.nextSibling,
	l);else throw new SyntaxError("The value provided ("+String(h)+") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");};}Ne&&(Element.prototype.attachShadow=function(e){e=Ne.call(this,e);if(a.R&&!e.__CE_patched){e.__CE_patched=!0;for(var f=0;f<a.X.length;f++)a.X[f](e);}return this.__CE_shadowRoot=e});Oe&&Oe.get?b(Element.prototype,Oe):df&&df.get?b(HTMLElement.prototype,df):rf(a,function(e){b(e,{enumerable:!0,configurable:!0,get:function(){return He.call(this,!0).innerHTML},set:function(f){var g=
	"template"===this.localName,h=g?this.content:this,k=Be.call(document,this.namespaceURI,this.localName);for(k.innerHTML=f;0<h.childNodes.length;)Ke.call(h,h.childNodes[0]);for(f=g?k.content:k;0<f.childNodes.length;)Ie.call(h,f.childNodes[0]);}});});Element.prototype.setAttribute=function(e,f){if(1!==this.__CE_state)return Qe.call(this,e,f);var g=Pe.call(this,e);Qe.call(this,e,f);f=Pe.call(this,e);a.attributeChangedCallback(this,e,g,f,null);};Element.prototype.setAttributeNS=function(e,f,g){if(1!==this.__CE_state)return Te.call(this,
	e,f,g);var h=Se.call(this,e,f);Te.call(this,e,f,g);g=Se.call(this,e,f);a.attributeChangedCallback(this,f,h,g,e);};Element.prototype.removeAttribute=function(e){if(1!==this.__CE_state)return Re.call(this,e);var f=Pe.call(this,e);Re.call(this,e);null!==f&&a.attributeChangedCallback(this,e,f,null,null);};Element.prototype.removeAttributeNS=function(e,f){if(1!==this.__CE_state)return Ue.call(this,e,f);var g=Se.call(this,e,f);Ue.call(this,e,f);var h=Se.call(this,e,f);g!==h&&a.attributeChangedCallback(this,
	f,g,h,e);};ef?c(HTMLElement.prototype,ef):Ve&&c(Element.prototype,Ve);ff?d(HTMLElement.prototype,ff):We&&d(Element.prototype,We);Hf(a,Element.prototype,{prepend:Xe,append:Ye});Jf(a);}var Lf={};function Mf(a){function b(){var c=this.constructor;var d=document.__CE_registry.xa.get(c);if(!d)throw Error("Failed to construct a custom element: The constructor was not registered with `customElements`.");var e=d.constructionStack;if(0===e.length)return e=Ae.call(document,d.localName),Object.setPrototypeOf(e,c.prototype),e.__CE_state=1,e.__CE_definition=d,tf(a,e),e;var f=e.length-1,g=e[f];if(g===Lf)throw Error("Failed to construct '"+d.localName+"': This element was already constructed.");e[f]=
	Lf;Object.setPrototypeOf(g,c.prototype);tf(a,g);return g}b.prototype=cf.prototype;Object.defineProperty(HTMLElement.prototype,"constructor",{writable:!0,configurable:!0,enumerable:!1,value:b});window.HTMLElement=b;}function Nf(a){function b(c,d){Object.defineProperty(c,"textContent",{enumerable:d.enumerable,configurable:!0,get:d.get,set:function(e){if(this.nodeType===Node.TEXT_NODE)d.set.call(this,e);else {var f=void 0;if(this.firstChild){var g=this.childNodes,h=g.length;if(0<h&&S(this)){f=Array(h);for(var k=0;k<h;k++)f[k]=g[k];}}d.set.call(this,e);if(f)for(e=0;e<f.length;e++)wf(a,f[e]);}}});}Node.prototype.insertBefore=function(c,d){if(c instanceof DocumentFragment){var e=kf(c);c=Je.call(this,c,d);if(S(this))for(d=
	0;d<e.length;d++)uf(a,e[d]);return c}e=c instanceof Element&&S(c);d=Je.call(this,c,d);e&&wf(a,c);S(this)&&uf(a,c);return d};Node.prototype.appendChild=function(c){if(c instanceof DocumentFragment){var d=kf(c);c=Ie.call(this,c);if(S(this))for(var e=0;e<d.length;e++)uf(a,d[e]);return c}d=c instanceof Element&&S(c);e=Ie.call(this,c);d&&wf(a,c);S(this)&&uf(a,c);return e};Node.prototype.cloneNode=function(c){c=He.call(this,!!c);this.ownerDocument.__CE_registry?xf(a,c):sf(a,c);return c};Node.prototype.removeChild=
	function(c){var d=c instanceof Element&&S(c),e=Ke.call(this,c);d&&wf(a,c);return e};Node.prototype.replaceChild=function(c,d){if(c instanceof DocumentFragment){var e=kf(c);c=Le.call(this,c,d);if(S(this))for(wf(a,d),d=0;d<e.length;d++)uf(a,e[d]);return c}e=c instanceof Element&&S(c);var f=Le.call(this,c,d),g=S(this);g&&wf(a,d);e&&wf(a,c);g&&uf(a,c);return f};Me&&Me.get?b(Node.prototype,Me):qf(a,function(c){b(c,{enumerable:!0,configurable:!0,get:function(){for(var d=[],e=this.firstChild;e;e=e.nextSibling)e.nodeType!==
	Node.COMMENT_NODE&&d.push(e.textContent);return d.join("")},set:function(d){for(;this.firstChild;)Ke.call(this,this.firstChild);null!=d&&""!==d&&Ie.call(this,document.createTextNode(d));}});});}var of=window.customElements;function Of(){var a=new nf;Mf(a);If(a);Hf(a,DocumentFragment.prototype,{prepend:Fe,append:Ge});Nf(a);Kf(a);a=new T(a);document.__CE_registry=a;Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:a});}of&&!of.forcePolyfill&&"function"==typeof of.define&&"function"==typeof of.get||Of();window.__CE_installPolyfill=Of;/*

	Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	Code distributed by Google as part of the polymer project is also
	subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	*/
	function Pf(){this.end=this.start=0;this.rules=this.parent=this.previous=null;this.cssText=this.parsedCssText="";this.atRule=!1;this.type=0;this.parsedSelector=this.selector=this.keyframesName="";}
	function Qf(a){var b=a=a.replace(Rf,"").replace(Sf,""),c=new Pf;c.start=0;c.end=b.length;for(var d=c,e=0,f=b.length;e<f;e++)if("{"===b[e]){d.rules||(d.rules=[]);var g=d,h=g.rules[g.rules.length-1]||null;d=new Pf;d.start=e+1;d.parent=g;d.previous=h;g.rules.push(d);}else "}"===b[e]&&(d.end=e+1,d=d.parent||c);return Tf(c,a)}
	function Tf(a,b){var c=b.substring(a.start,a.end-1);a.parsedCssText=a.cssText=c.trim();a.parent&&(c=b.substring(a.previous?a.previous.end:a.parent.start,a.start-1),c=Uf(c),c=c.replace(Vf," "),c=c.substring(c.lastIndexOf(";")+1),c=a.parsedSelector=a.selector=c.trim(),a.atRule=0===c.indexOf("@"),a.atRule?0===c.indexOf("@media")?a.type=Wf:c.match(Xf)&&(a.type=Yf,a.keyframesName=a.selector.split(Vf).pop()):a.type=0===c.indexOf("--")?Zf:$f);if(c=a.rules)for(var d=0,e=c.length,f=void 0;d<e&&(f=c[d]);d++)Tf(f,
	b);return a}function Uf(a){return a.replace(/\\([0-9a-f]{1,6})\s/gi,function(b,c){b=c;for(c=6-b.length;c--;)b="0"+b;return "\\"+b})}
	function ag(a,b,c){c=void 0===c?"":c;var d="";if(a.cssText||a.rules){var e=a.rules,f;if(f=e)f=e[0],f=!(f&&f.selector&&0===f.selector.indexOf("--"));if(f){f=0;for(var g=e.length,h=void 0;f<g&&(h=e[f]);f++)d=ag(h,b,d);}else b?b=a.cssText:(b=a.cssText,b=b.replace(bg,"").replace(cg,""),b=b.replace(dg,"").replace(eg,"")),(d=b.trim())&&(d="  "+d+"\n");}d&&(a.selector&&(c+=a.selector+" {\n"),c+=d,a.selector&&(c+="}\n\n"));return c}
	var $f=1,Yf=7,Wf=4,Zf=1E3,Rf=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,Sf=/@import[^;]*;/gim,bg=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,cg=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,dg=/@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,eg=/[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,Xf=/^@[^\s]*keyframes/,Vf=/\s+/g;var U=!(window.ShadyDOM&&window.ShadyDOM.inUse),fg;function gg(a){fg=a&&a.shimcssproperties?!1:U||!(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/)||!window.CSS||!CSS.supports||!CSS.supports("box-shadow","0 0 0 var(--foo)"));}var hg;window.ShadyCSS&&void 0!==window.ShadyCSS.cssBuild&&(hg=window.ShadyCSS.cssBuild);var ig=!(!window.ShadyCSS||!window.ShadyCSS.disableRuntime);
	window.ShadyCSS&&void 0!==window.ShadyCSS.nativeCss?fg=window.ShadyCSS.nativeCss:window.ShadyCSS?(gg(window.ShadyCSS),window.ShadyCSS=void 0):gg(window.WebComponents&&window.WebComponents.flags);var V=fg;var jg=/(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,kg=/(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,lg=/(--[\w-]+)\s*([:,;)]|$)/gi,mg=/(animation\s*:)|(animation-name\s*:)/,ng=/@media\s(.*)/,og=/\{[^}]*\}/g;var pg=new Set;function qg(a,b){if(!a)return "";"string"===typeof a&&(a=Qf(a));b&&sg(a,b);return ag(a,V)}function tg(a){!a.__cssRules&&a.textContent&&(a.__cssRules=Qf(a.textContent));return a.__cssRules||null}function ug(a){return !!a.parent&&a.parent.type===Yf}function sg(a,b,c,d){if(a){var e=!1,f=a.type;if(d&&f===Wf){var g=a.selector.match(ng);g&&(window.matchMedia(g[1]).matches||(e=!0));}f===$f?b(a):c&&f===Yf?c(a):f===Zf&&(e=!0);if((a=a.rules)&&!e)for(e=0,f=a.length,g=void 0;e<f&&(g=a[e]);e++)sg(g,b,c,d);}}
	function vg(a,b,c,d){var e=document.createElement("style");b&&e.setAttribute("scope",b);e.textContent=a;wg(e,c,d);return e}var xg=null;function yg(a){a=document.createComment(" Shady DOM styles for "+a+" ");var b=document.head;b.insertBefore(a,(xg?xg.nextSibling:null)||b.firstChild);return xg=a}function wg(a,b,c){b=b||document.head;b.insertBefore(a,c&&c.nextSibling||b.firstChild);xg?a.compareDocumentPosition(xg)===Node.DOCUMENT_POSITION_PRECEDING&&(xg=a):xg=a;}
	function zg(a,b){for(var c=0,d=a.length;b<d;b++)if("("===a[b])c++;else if(")"===a[b]&&0===--c)return b;return -1}function Ag(a,b){var c=a.indexOf("var(");if(-1===c)return b(a,"","","");var d=zg(a,c+3),e=a.substring(c+4,d);c=a.substring(0,c);a=Ag(a.substring(d+1),b);d=e.indexOf(",");return -1===d?b(c,e.trim(),"",a):b(c,e.substring(0,d).trim(),e.substring(d+1).trim(),a)}function Bg(a,b){U?a.setAttribute("class",b):window.ShadyDOM.nativeMethods.setAttribute.call(a,"class",b);}
	var Cg=window.ShadyDOM&&window.ShadyDOM.wrap||function(a){return a};function Dg(a){var b=a.localName,c="";b?-1<b.indexOf("-")||(c=b,b=a.getAttribute&&a.getAttribute("is")||""):(b=a.is,c=a.extends);return {is:b,ca:c}}function Eg(a){for(var b=[],c="",d=0;0<=d&&d<a.length;d++)if("("===a[d]){var e=zg(a,d);c+=a.slice(d,e+1);d=e;}else ","===a[d]?(b.push(c),c=""):c+=a[d];c&&b.push(c);return b}
	function Fg(a){if(void 0!==hg)return hg;if(void 0===a.__cssBuild){var b=a.getAttribute("css-build");if(b)a.__cssBuild=b;else {a:{b="template"===a.localName?a.content.firstChild:a.firstChild;if(b instanceof Comment&&(b=b.textContent.trim().split(":"),"css-build"===b[0])){b=b[1];break a}b="";}if(""!==b){var c="template"===a.localName?a.content.firstChild:a.firstChild;c.parentNode.removeChild(c);}a.__cssBuild=b;}}return a.__cssBuild||""}
	function Gg(a){a=void 0===a?"":a;return ""!==a&&V?U?"shadow"===a:"shady"===a:!1}function Hg(){}function Ig(a,b){Jg(Kg,a,function(c){Lg(c,b||"");});}function Jg(a,b,c){b.nodeType===Node.ELEMENT_NODE&&c(b);var d;"template"===b.localName?d=(b.content||b._content||b).childNodes:d=b.children||b.childNodes;if(d)for(b=0;b<d.length;b++)Jg(a,d[b],c);}
	function Lg(a,b,c){if(b)if(a.classList)c?(a.classList.remove("style-scope"),a.classList.remove(b)):(a.classList.add("style-scope"),a.classList.add(b));else if(a.getAttribute){var d=a.getAttribute("class");c?d&&(b=d.replace("style-scope","").replace(b,""),Bg(a,b)):Bg(a,(d?d+" ":"")+"style-scope "+b);}}function Mg(a,b,c){Jg(Kg,a,function(d){Lg(d,b,!0);Lg(d,c);});}function Ng(a,b){Jg(Kg,a,function(c){Lg(c,b||"",!0);});}
	function Og(a,b,c,d,e){var f=Kg;e=void 0===e?"":e;""===e&&(U||"shady"===(void 0===d?"":d)?e=qg(b,c):(a=Dg(a),e=Pg(f,b,a.is,a.ca,c)+"\n\n"));return e.trim()}function Pg(a,b,c,d,e){var f=Qg(c,d);c=c?"."+c:"";return qg(b,function(g){g.c||(g.selector=g.w=Rg(a,g,a.b,c,f),g.c=!0);e&&e(g,c,f);})}function Qg(a,b){return b?"[is="+a+"]":a}
	function Rg(a,b,c,d,e){var f=Eg(b.selector);if(!ug(b)){b=0;for(var g=f.length,h=void 0;b<g&&(h=f[b]);b++)f[b]=c.call(a,h,d,e);}return f.filter(function(k){return !!k}).join(",")}function Sg(a){return a.replace(Tg,function(b,c,d){-1<d.indexOf("+")?d=d.replace(/\+/g,"___"):-1<d.indexOf("___")&&(d=d.replace(/___/g,"+"));return ":"+c+"("+d+")"})}
	function Ug(a){for(var b=[],c;c=a.match(Vg);){var d=c.index,e=zg(a,d);if(-1===e)throw Error(c.input+" selector missing ')'");c=a.slice(d,e+1);a=a.replace(c,"\ue000");b.push(c);}return {wa:a,matches:b}}function Wg(a,b){var c=a.split("\ue000");return b.reduce(function(d,e,f){return d+e+c[f+1]},c[0])}
	Hg.prototype.b=function(a,b,c){var d=!1;a=a.trim();var e=Tg.test(a);e&&(a=a.replace(Tg,function(h,k,l){return ":"+k+"("+l.replace(/\s/g,"")+")"}),a=Sg(a));var f=Vg.test(a);if(f){var g=Ug(a);a=g.wa;g=g.matches;}a=a.replace(Xg,":host $1");a=a.replace(Yg,function(h,k,l){d||(h=Zg(l,k,b,c),d=d||h.stop,k=h.Qa,l=h.value);return k+l});f&&(a=Wg(a,g));e&&(a=Sg(a));return a=a.replace($g,function(h,k,l,m){return '[dir="'+l+'"] '+k+m+", "+k+'[dir="'+l+'"]'+m})};
	function Zg(a,b,c,d){var e=a.indexOf("::slotted");0<=a.indexOf(":host")?a=ah(a,d):0!==e&&(a=c?bh(a,c):a);c=!1;0<=e&&(b="",c=!0);if(c){var f=!0;c&&(a=a.replace(ch,function(g,h){return " > "+h}));}return {value:a,Qa:b,stop:f}}function bh(a,b){a=a.split(/(\[.+?\])/);for(var c=[],d=0;d<a.length;d++)if(1===d%2)c.push(a[d]);else {var e=a[d];if(""!==e||d!==a.length-1)e=e.split(":"),e[0]+=b,c.push(e.join(":"));}return c.join("")}
	function ah(a,b){var c=a.match(dh);return (c=c&&c[2].trim()||"")?c[0].match(eh)?a.replace(dh,function(d,e,f){return b+f}):c.split(eh)[0]===b?c:"should_not_match":a.replace(":host",b)}function fh(a){":root"===a.selector&&(a.selector="html");}Hg.prototype.c=function(a){return a.match(":host")?"":a.match("::slotted")?this.b(a,":not(.style-scope)"):bh(a.trim(),":not(.style-scope)")};ca.Object.defineProperties(Hg.prototype,{a:{configurable:!0,enumerable:!0,get:function(){return "style-scope"}}});
	var Tg=/:(nth[-\w]+)\(([^)]+)\)/,Yg=/(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=[])+)/g,eh=/[[.:#*]/,Xg=/^(::slotted)/,dh=/(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,ch=/(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,$g=/(.*):dir\((?:(ltr|rtl))\)(.*)/,Vg=/:(?:matches|any|-(?:webkit|moz)-any)/,Kg=new Hg;function gh(a,b,c,d,e){this.H=a||null;this.b=b||null;this.ta=c||[];this.F=null;this.cssBuild=e||"";this.ca=d||"";this.a=this.G=this.L=null;}function hh(a){return a?a.__styleInfo:null}function ih(a,b){return a.__styleInfo=b}gh.prototype.c=function(){return this.H};gh.prototype._getStyleRules=gh.prototype.c;function jh(a){var b=this.matches||this.matchesSelector||this.mozMatchesSelector||this.msMatchesSelector||this.oMatchesSelector||this.webkitMatchesSelector;return b&&b.call(this,a)}var kh=/:host\s*>\s*/,lh=navigator.userAgent.match("Trident");function mh(){}function nh(a){var b={},c=[],d=0;sg(a,function(f){oh(f);f.index=d++;f=f.v.cssText;for(var g;g=lg.exec(f);){var h=g[1];":"!==g[2]&&(b[h]=!0);}},function(f){c.push(f);});a.b=c;a=[];for(var e in b)a.push(e);return a}
	function oh(a){if(!a.v){var b={},c={};ph(a,c)&&(b.K=c,a.rules=null);b.cssText=a.parsedCssText.replace(og,"").replace(jg,"");a.v=b;}}function ph(a,b){var c=a.v;if(c){if(c.K)return Object.assign(b,c.K),!0}else {c=a.parsedCssText;for(var d;a=jg.exec(c);){d=(a[2]||a[3]).trim();if("inherit"!==d||"unset"!==d)b[a[1].trim()]=d;d=!0;}return d}}
	function qh(a,b,c){b&&(b=0<=b.indexOf(";")?rh(a,b,c):Ag(b,function(d,e,f,g){if(!e)return d+g;(e=qh(a,c[e],c))&&"initial"!==e?"apply-shim-inherit"===e&&(e="inherit"):e=qh(a,c[f]||f,c)||f;return d+(e||"")+g}));return b&&b.trim()||""}
	function rh(a,b,c){b=b.split(";");for(var d=0,e,f;d<b.length;d++)if(e=b[d]){kg.lastIndex=0;if(f=kg.exec(e))e=qh(a,c[f[1]],c);else if(f=e.indexOf(":"),-1!==f){var g=e.substring(f);g=g.trim();g=qh(a,g,c)||g;e=e.substring(0,f)+g;}b[d]=e&&e.lastIndexOf(";")===e.length-1?e.slice(0,-1):e||"";}return b.join(";")}
	function sh(a,b){var c={},d=[];sg(a,function(e){e.v||oh(e);var f=e.w||e.parsedSelector;b&&e.v.K&&f&&jh.call(b,f)&&(ph(e,c),e=e.index,f=parseInt(e/32,10),d[f]=(d[f]||0)|1<<e%32);},null,!0);return {K:c,key:d}}
	function th(a,b,c,d){b.v||oh(b);if(b.v.K){var e=Dg(a);a=e.is;e=e.ca;e=a?Qg(a,e):"html";var f=b.parsedSelector;var g=!!f.match(kh)||"html"===e&&-1<f.indexOf("html");var h=0===f.indexOf(":host")&&!g;"shady"===c&&(g=f===e+" > *."+e||-1!==f.indexOf("html"),h=!g&&0===f.indexOf(e));if(g||h)c=e,h&&(b.w||(b.w=Rg(Kg,b,Kg.b,a?"."+a:"",e)),c=b.w||e),g&&"html"===e&&(c=b.w||b.J),d({wa:c,Xa:h,mb:g});}}
	function uh(a,b,c){var d={},e={};sg(b,function(f){th(a,f,c,function(g){jh.call(a._element||a,g.wa)&&(g.Xa?ph(f,d):ph(f,e));});},null,!0);return {cb:e,Va:d}}
	function vh(a,b,c,d){var e=Dg(b),f=Qg(e.is,e.ca),g=new RegExp("(?:^|[^.#[:])"+(b.extends?"\\"+f.slice(0,-1)+"\\]":f)+"($|[.:[\\s>+~])"),h=hh(b);e=h.H;h=h.cssBuild;var k=wh(e,d);return Og(b,e,function(l){var m="";l.v||oh(l);l.v.cssText&&(m=rh(a,l.v.cssText,c));l.cssText=m;if(!U&&!ug(l)&&l.cssText){var q=m=l.cssText;null==l.Da&&(l.Da=mg.test(m));if(l.Da)if(null==l.ka){l.ka=[];for(var H in k)q=k[H],q=q(m),m!==q&&(m=q,l.ka.push(H));}else {for(H=0;H<l.ka.length;++H)q=k[l.ka[H]],m=q(m);q=m;}l.cssText=q;l.w=
	l.w||l.selector;m="."+d;H=Eg(l.w);q=0;for(var C=H.length,t=void 0;q<C&&(t=H[q]);q++)H[q]=t.match(g)?t.replace(f,m):m+" "+t;l.selector=H.join(",");}},h)}function wh(a,b){a=a.b;var c={};if(!U&&a)for(var d=0,e=a[d];d<a.length;e=a[++d]){var f=e,g=b;f.l=new RegExp("\\b"+f.keyframesName+"(?!\\B|-)","g");f.a=f.keyframesName+"-"+g;f.w=f.w||f.selector;f.selector=f.w.replace(f.keyframesName,f.a);c[e.keyframesName]=xh(e);}return c}function xh(a){return function(b){return b.replace(a.l,a.a)}}
	function yh(a,b){var c=zh,d=tg(a);a.textContent=qg(d,function(e){var f=e.cssText=e.parsedCssText;e.v&&e.v.cssText&&(f=f.replace(bg,"").replace(cg,""),e.cssText=rh(c,f,b));});}ca.Object.defineProperties(mh.prototype,{a:{configurable:!0,enumerable:!0,get:function(){return "x-scope"}}});var zh=new mh;var Ah={},Bh=window.customElements;if(Bh&&!U&&!ig){var Ch=Bh.define;Bh.define=function(a,b,c){Ah[a]||(Ah[a]=yg(a));Ch.call(Bh,a,b,c);};}function Dh(){this.cache={};}Dh.prototype.store=function(a,b,c,d){var e=this.cache[a]||[];e.push({K:b,styleElement:c,G:d});100<e.length&&e.shift();this.cache[a]=e;};function Eh(){}var Fh=new RegExp(Kg.a+"\\s*([^\\s]*)");function Gh(a){return (a=(a.classList&&a.classList.value?a.classList.value:a.getAttribute("class")||"").match(Fh))?a[1]:""}function Hh(a){var b=Cg(a).getRootNode();return b===a||b===a.ownerDocument?"":(a=b.host)?Dg(a).is:""}
	function Ih(a){for(var b=0;b<a.length;b++){var c=a[b];if(c.target!==document.documentElement&&c.target!==document.head)for(var d=0;d<c.addedNodes.length;d++){var e=c.addedNodes[d];if(e.nodeType===Node.ELEMENT_NODE){var f=e.getRootNode(),g=Gh(e);if(g&&f===e.ownerDocument&&("style"!==e.localName&&"template"!==e.localName||""===Fg(e)))Ng(e,g);else if(f instanceof ShadowRoot)for(f=Hh(e),f!==g&&Mg(e,g,f),e=window.ShadyDOM.nativeMethods.querySelectorAll.call(e,":not(."+Kg.a+")"),g=0;g<e.length;g++){f=e[g];
	var h=Hh(f);h&&Lg(f,h);}}}}}
	if(!(U||window.ShadyDOM&&window.ShadyDOM.handlesDynamicScoping)){var Jh=new MutationObserver(Ih),Kh=function(a){Jh.observe(a,{childList:!0,subtree:!0});};if(window.customElements&&!window.customElements.polyfillWrapFlushCallback)Kh(document);else {var Lh=function(){Kh(document.body);};window.HTMLImports?window.HTMLImports.whenReady(Lh):requestAnimationFrame(function(){if("loading"===document.readyState){var a=function(){Lh();document.removeEventListener("readystatechange",a);};document.addEventListener("readystatechange",
	a);}else Lh();});}Eh=function(){Ih(Jh.takeRecords());};}var Mh={};var Nh=Promise.resolve();function Oh(a){if(a=Mh[a])a._applyShimCurrentVersion=a._applyShimCurrentVersion||0,a._applyShimValidatingVersion=a._applyShimValidatingVersion||0,a._applyShimNextVersion=(a._applyShimNextVersion||0)+1;}function Ph(a){return a._applyShimCurrentVersion===a._applyShimNextVersion}function Qh(a){a._applyShimValidatingVersion=a._applyShimNextVersion;a._validating||(a._validating=!0,Nh.then(function(){a._applyShimCurrentVersion=a._applyShimNextVersion;a._validating=!1;}));}var Rh={},Sh=new Dh;function X(){this.Y={};this.c=document.documentElement;var a=new Pf;a.rules=[];this.l=ih(this.c,new gh(a));this.J=!1;this.a=this.b=null;}w=X.prototype;w.flush=function(){Eh();};w.Ta=function(a){return tg(a)};w.hb=function(a){return qg(a)};w.prepareTemplate=function(a,b,c){this.prepareTemplateDom(a,b);this.prepareTemplateStyles(a,b,c);};
	w.prepareTemplateStyles=function(a,b,c){if(!a._prepared&&!ig){U||Ah[b]||(Ah[b]=yg(b));a._prepared=!0;a.name=b;a.extends=c;Mh[b]=a;var d=Fg(a),e=Gg(d);c={is:b,extends:c};for(var f=[],g=a.content.querySelectorAll("style"),h=0;h<g.length;h++){var k=g[h];if(k.hasAttribute("shady-unscoped")){if(!U){var l=k.textContent;if(!pg.has(l)){pg.add(l);var m=document.createElement("style");m.setAttribute("shady-unscoped","");m.textContent=l;document.head.appendChild(m);}k.parentNode.removeChild(k);}}else f.push(k.textContent),
	k.parentNode.removeChild(k);}f=f.join("").trim()+(Rh[b]||"");Th(this);if(!e){if(g=!d)g=kg.test(f)||jg.test(f),kg.lastIndex=0,jg.lastIndex=0;h=Qf(f);g&&V&&this.b&&this.b.transformRules(h,b);a._styleAst=h;}g=[];V||(g=nh(a._styleAst));if(!g.length||V)h=U?a.content:null,b=Ah[b]||null,d=Og(c,a._styleAst,null,d,e?f:""),d=d.length?vg(d,c.is,h,b):null,a._style=d;a.a=g;}};w.ab=function(a,b){Rh[b]=a.join(" ");};
	w.prepareTemplateDom=function(a,b){if(!ig){var c=Fg(a);U||"shady"===c||a._domPrepared||(a._domPrepared=!0,Ig(a.content,b));}};function Uh(a){var b=Dg(a),c=b.is;b=b.ca;var d=Ah[c]||null,e=Mh[c];if(e){c=e._styleAst;var f=e.a;e=Fg(e);b=new gh(c,d,f,b,e);ih(a,b);return b}}
	function Vh(a){!a.a&&window.ShadyCSS&&window.ShadyCSS.CustomStyleInterface&&(a.a=window.ShadyCSS.CustomStyleInterface,a.a.transformCallback=function(b){a.Ha(b);},a.a.validateCallback=function(){requestAnimationFrame(function(){(a.a.enqueued||a.J)&&a.flushCustomStyles();});});}function Th(a){if(!a.b&&window.ShadyCSS&&window.ShadyCSS.ApplyShim){a.b=window.ShadyCSS.ApplyShim;a.b.invalidCallback=Oh;var b=!0;}else b=!1;Vh(a);return b}
	w.flushCustomStyles=function(){if(!ig){var a=Th(this);if(this.a){var b=this.a.processStyles();if((a||this.a.enqueued)&&!Gg(this.l.cssBuild)){if(V){if(!this.l.cssBuild)for(a=0;a<b.length;a++){var c=this.a.getStyleForCustomStyle(b[a]);if(c&&V&&this.b){var d=tg(c);Th(this);this.b.transformRules(d);c.textContent=qg(d);}}}else {Wh(this,b);Xh(this,this.c,this.l);for(a=0;a<b.length;a++)(c=this.a.getStyleForCustomStyle(b[a]))&&yh(c,this.l.L);this.J&&this.styleDocument();}this.a.enqueued=!1;}}}};
	function Wh(a,b){b=b.map(function(c){return a.a.getStyleForCustomStyle(c)}).filter(function(c){return !!c});b.sort(function(c,d){c=d.compareDocumentPosition(c);return c&Node.DOCUMENT_POSITION_FOLLOWING?1:c&Node.DOCUMENT_POSITION_PRECEDING?-1:0});a.l.H.rules=b.map(function(c){return tg(c)});}
	w.styleElement=function(a,b){if(ig){if(b){hh(a)||ih(a,new gh(null));var c=hh(a);c.F=c.F||{};Object.assign(c.F,b);Yh(this,a,c);}}else if(c=hh(a)||Uh(a))if(a!==this.c&&(this.J=!0),b&&(c.F=c.F||{},Object.assign(c.F,b)),V)Yh(this,a,c);else if(this.flush(),Xh(this,a,c),c.ta&&c.ta.length){b=Dg(a).is;var d;a:{if(d=Sh.cache[b])for(var e=d.length-1;0<=e;e--){var f=d[e];b:{var g=c.ta;for(var h=0;h<g.length;h++){var k=g[h];if(f.K[k]!==c.L[k]){g=!1;break b}}g=!0;}if(g){d=f;break a}}d=void 0;}g=d?d.styleElement:
	null;e=c.G;(f=d&&d.G)||(f=this.Y[b]=(this.Y[b]||0)+1,f=b+"-"+f);c.G=f;f=c.G;h=zh;h=g?g.textContent||"":vh(h,a,c.L,f);k=hh(a);var l=k.a;l&&!U&&l!==g&&(l._useCount--,0>=l._useCount&&l.parentNode&&l.parentNode.removeChild(l));U?k.a?(k.a.textContent=h,g=k.a):h&&(g=vg(h,f,a.shadowRoot,k.b)):g?g.parentNode||(lh&&-1<h.indexOf("@media")&&(g.textContent=h),wg(g,null,k.b)):h&&(g=vg(h,f,null,k.b));g&&(g._useCount=g._useCount||0,k.a!=g&&g._useCount++,k.a=g);f=g;U||(g=c.G,k=h=a.getAttribute("class")||"",e&&(k=
	h.replace(new RegExp("\\s*x-scope\\s*"+e+"\\s*","g")," ")),k+=(k?" ":"")+"x-scope "+g,h!==k&&Bg(a,k));d||Sh.store(b,c.L,f,c.G);}};
	function Yh(a,b,c){var d=Dg(b).is;if(c.F){var e=c.F,f;for(f in e)null===f?b.style.removeProperty(f):b.style.setProperty(f,e[f]);}e=Mh[d];if(!(!e&&b!==a.c||e&&""!==Fg(e))&&e&&e._style&&!Ph(e)){if(Ph(e)||e._applyShimValidatingVersion!==e._applyShimNextVersion)Th(a),a.b&&a.b.transformRules(e._styleAst,d),e._style.textContent=Og(b,c.H),Qh(e);U&&(a=b.shadowRoot)&&(a=a.querySelector("style"))&&(a.textContent=Og(b,c.H));c.H=e._styleAst;}}
	function Zh(a,b){return (b=Cg(b).getRootNode().host)?hh(b)||Uh(b)?b:Zh(a,b):a.c}function Xh(a,b,c){var d=Zh(a,b),e=hh(d),f=e.L;d===a.c||f||(Xh(a,d,e),f=e.L);a=Object.create(f||null);d=uh(b,c.H,c.cssBuild);b=sh(e.H,b).K;Object.assign(a,d.Va,b,d.cb);b=c.F;for(var g in b)if((e=b[g])||0===e)a[g]=e;g=zh;b=Object.getOwnPropertyNames(a);for(e=0;e<b.length;e++)d=b[e],a[d]=qh(g,a[d],a);c.L=a;}w.styleDocument=function(a){this.styleSubtree(this.c,a);};
	w.styleSubtree=function(a,b){var c=Cg(a),d=c.shadowRoot,e=a===this.c;(d||e)&&this.styleElement(a,b);if(a=e?c:d)for(a=Array.from(a.querySelectorAll("*")).filter(function(f){return Cg(f).shadowRoot}),b=0;b<a.length;b++)this.styleSubtree(a[b]);};
	w.Ha=function(a){var b=this,c=Fg(a);c!==this.l.cssBuild&&(this.l.cssBuild=c);if(!Gg(c)){var d=tg(a);sg(d,function(e){if(U)fh(e);else {var f=Kg;e.selector=e.parsedSelector;fh(e);e.selector=e.w=Rg(f,e,f.c,void 0,void 0);}V&&""===c&&(Th(b),b.b&&b.b.transformRule(e));});V?a.textContent=qg(d):this.l.H.rules.push(d);}};w.getComputedStyleValue=function(a,b){var c;V||(c=(hh(a)||hh(Zh(this,a))).L[b]);return (c=c||window.getComputedStyle(a).getPropertyValue(b))?c.trim():""};
	w.gb=function(a,b){var c=Cg(a).getRootNode(),d;b?d=("string"===typeof b?b:String(b)).split(/\s/):d=[];b=c.host&&c.host.localName;if(!b&&(c=a.getAttribute("class"))){c=c.split(/\s/);for(var e=0;e<c.length;e++)if(c[e]===Kg.a){b=c[e+1];break}}b&&d.push(Kg.a,b);V||(b=hh(a))&&b.G&&d.push(zh.a,b.G);Bg(a,d.join(" "));};w.Oa=function(a){return hh(a)};w.fb=function(a,b){Lg(a,b);};w.ib=function(a,b){Lg(a,b,!0);};w.eb=function(a){return Hh(a)};w.Ra=function(a){return Gh(a)};X.prototype.flush=X.prototype.flush;
	X.prototype.prepareTemplate=X.prototype.prepareTemplate;X.prototype.styleElement=X.prototype.styleElement;X.prototype.styleDocument=X.prototype.styleDocument;X.prototype.styleSubtree=X.prototype.styleSubtree;X.prototype.getComputedStyleValue=X.prototype.getComputedStyleValue;X.prototype.setElementClass=X.prototype.gb;X.prototype._styleInfoForNode=X.prototype.Oa;X.prototype.transformCustomStyleForDocument=X.prototype.Ha;X.prototype.getStyleAst=X.prototype.Ta;X.prototype.styleAstToString=X.prototype.hb;
	X.prototype.flushCustomStyles=X.prototype.flushCustomStyles;X.prototype.scopeNode=X.prototype.fb;X.prototype.unscopeNode=X.prototype.ib;X.prototype.scopeForNode=X.prototype.eb;X.prototype.currentScopeForNode=X.prototype.Ra;X.prototype.prepareAdoptedCssText=X.prototype.ab;Object.defineProperties(X.prototype,{nativeShadow:{get:function(){return U}},nativeCss:{get:function(){return V}}});var Y=new X,$h,ai;window.ShadyCSS&&($h=window.ShadyCSS.ApplyShim,ai=window.ShadyCSS.CustomStyleInterface);
	window.ShadyCSS={ScopingShim:Y,prepareTemplate:function(a,b,c){Y.flushCustomStyles();Y.prepareTemplate(a,b,c);},prepareTemplateDom:function(a,b){Y.prepareTemplateDom(a,b);},prepareTemplateStyles:function(a,b,c){Y.flushCustomStyles();Y.prepareTemplateStyles(a,b,c);},styleSubtree:function(a,b){Y.flushCustomStyles();Y.styleSubtree(a,b);},styleElement:function(a){Y.flushCustomStyles();Y.styleElement(a);},styleDocument:function(a){Y.flushCustomStyles();Y.styleDocument(a);},flushCustomStyles:function(){Y.flushCustomStyles();},
	getComputedStyleValue:function(a,b){return Y.getComputedStyleValue(a,b)},nativeCss:V,nativeShadow:U,cssBuild:hg,disableRuntime:ig};$h&&(window.ShadyCSS.ApplyShim=$h);ai&&(window.ShadyCSS.CustomStyleInterface=ai);(function(a){function b(t){""==t&&(f.call(this),this.h=!0);return t.toLowerCase()}function c(t){var F=t.charCodeAt(0);return 32<F&&127>F&&-1==[34,35,60,62,63,96].indexOf(F)?t:encodeURIComponent(t)}function d(t){var F=t.charCodeAt(0);return 32<F&&127>F&&-1==[34,35,60,62,96].indexOf(F)?t:encodeURIComponent(t)}function e(t,F,E){function M(ka){}var y=F||"scheme start",W=0,v="",ua=!1,ea=!1;a:for(;(void 0!=t[W-1]||0==W)&&!this.h;){var n=t[W];switch(y){case "scheme start":if(n&&q.test(n))v+=
	n.toLowerCase(),y="scheme";else if(F){break a}else {v="";y="no scheme";continue}break;case "scheme":if(n&&H.test(n))v+=n.toLowerCase();else if(":"==n){this.g=v;v="";if(F)break a;void 0!==l[this.g]&&(this.A=!0);y="file"==this.g?"relative":this.A&&E&&E.g==this.g?"relative or authority":this.A?"authority first slash":"scheme data";}else if(F){break a}else {v="";W=0;y="no scheme";continue}break;case "scheme data":"?"==n?(this.o="?",
	y="query"):"#"==n?(this.u="#",y="fragment"):void 0!=n&&"\t"!=n&&"\n"!=n&&"\r"!=n&&(this.pa+=c(n));break;case "no scheme":if(E&&void 0!==l[E.g]){y="relative";continue}else f.call(this),this.h=!0;break;case "relative or authority":if("/"==n&&"/"==t[W+1])y="authority ignore slashes";else {y="relative";continue}break;case "relative":this.A=!0;"file"!=this.g&&(this.g=E.g);if(void 0==n){this.i=E.i;this.m=E.m;this.j=E.j.slice();this.o=E.o;this.s=E.s;this.f=E.f;
	break a}else if("/"==n||"\\"==n)y="relative slash";else if("?"==n)this.i=E.i,this.m=E.m,this.j=E.j.slice(),this.o="?",this.s=E.s,this.f=E.f,y="query";else if("#"==n)this.i=E.i,this.m=E.m,this.j=E.j.slice(),this.o=E.o,this.u="#",this.s=E.s,this.f=E.f,y="fragment";else {y=t[W+1];var I=t[W+2];if("file"!=this.g||!q.test(n)||":"!=y&&"|"!=y||void 0!=I&&"/"!=I&&"\\"!=I&&"?"!=I&&"#"!=I)this.i=E.i,this.m=E.m,this.s=E.s,this.f=E.f,this.j=E.j.slice(),this.j.pop();y=
	"relative path";continue}break;case "relative slash":if("/"==n||"\\"==n)y="file"==this.g?"file host":"authority ignore slashes";else {"file"!=this.g&&(this.i=E.i,this.m=E.m,this.s=E.s,this.f=E.f);y="relative path";continue}break;case "authority first slash":if("/"==n)y="authority second slash";else {y="authority ignore slashes";continue}break;case "authority second slash":y="authority ignore slashes";if("/"!=n){continue}break;case "authority ignore slashes":if("/"!=n&&"\\"!=n){y="authority";continue}break;case "authority":if("@"==n){ua&&(v+="%40");ua=!0;for(n=0;n<v.length;n++)I=v[n],"\t"==I||"\n"==I||"\r"==I?M():":"==I&&null===this.f?this.f="":(I=c(I),null!==this.f?this.f+=I:this.s+=I);v="";}else if(void 0==n||"/"==n||"\\"==n||"?"==n||"#"==n){W-=v.length;v="";y="host";continue}else v+=n;break;case "file host":if(void 0==
	n||"/"==n||"\\"==n||"?"==n||"#"==n){2!=v.length||!q.test(v[0])||":"!=v[1]&&"|"!=v[1]?(0!=v.length&&(this.i=b.call(this,v),v=""),y="relative path start"):y="relative path";continue}else "\t"==n||"\n"==n||"\r"==n?M():v+=n;break;case "host":case "hostname":if(":"!=n||ea)if(void 0==n||"/"==n||"\\"==n||"?"==n||"#"==n){this.i=b.call(this,v);v="";y="relative path start";if(F)break a;continue}else "\t"!=n&&"\n"!=n&&"\r"!=n?("["==n?ea=!0:"]"==n&&(ea=!1),v+=n):M();else if(this.i=b.call(this,v),v="",y="port","hostname"==F)break a;break;case "port":if(/[0-9]/.test(n))v+=n;else if(void 0==n||"/"==n||"\\"==n||"?"==n||"#"==n||F){""!=v&&(v=parseInt(v,10),v!=l[this.g]&&(this.m=v+""),v="");if(F)break a;y="relative path start";continue}else "\t"==n||"\n"==n||"\r"==n?M():(f.call(this),this.h=!0);break;case "relative path start":y="relative path";if("/"!=n&&"\\"!=n)continue;break;case "relative path":if(void 0!=
	n&&"/"!=n&&"\\"!=n&&(F||"?"!=n&&"#"!=n))"\t"!=n&&"\n"!=n&&"\r"!=n&&(v+=c(n));else {if(I=m[v.toLowerCase()])v=I;".."==v?(this.j.pop(),"/"!=n&&"\\"!=n&&this.j.push("")):"."==v&&"/"!=n&&"\\"!=n?this.j.push(""):"."!=v&&("file"==this.g&&0==this.j.length&&2==v.length&&q.test(v[0])&&"|"==v[1]&&(v=v[0]+":"),this.j.push(v));v="";"?"==n?(this.o="?",y="query"):"#"==n&&(this.u="#",y="fragment");}break;case "query":F||"#"!=n?void 0!=n&&"\t"!=n&&"\n"!=n&&"\r"!=n&&(this.o+=
	d(n)):(this.u="#",y="fragment");break;case "fragment":void 0!=n&&"\t"!=n&&"\n"!=n&&"\r"!=n&&(this.u+=n);}W++;}}function f(){this.s=this.pa=this.g="";this.f=null;this.m=this.i="";this.j=[];this.u=this.o="";this.A=this.h=!1;}function g(t,F){void 0===F||F instanceof g||(F=new g(String(F)));this.a=t;f.call(this);e.call(this,this.a.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g,""),null,F);}var h=!1;try{var k=new URL("b","http://a");k.pathname="c%20d";h="http://a/c%20d"===k.href;}catch(t){}if(!h){var l=Object.create(null);
	l.ftp=21;l.file=0;l.gopher=70;l.http=80;l.https=443;l.ws=80;l.wss=443;var m=Object.create(null);m["%2e"]=".";m[".%2e"]="..";m["%2e."]="..";m["%2e%2e"]="..";var q=/[a-zA-Z]/,H=/[a-zA-Z0-9\+\-\.]/;g.prototype={toString:function(){return this.href},get href(){if(this.h)return this.a;var t="";if(""!=this.s||null!=this.f)t=this.s+(null!=this.f?":"+this.f:"")+"@";return this.protocol+(this.A?"//"+t+this.host:"")+this.pathname+this.o+this.u},set href(t){f.call(this);e.call(this,t);},get protocol(){return this.g+
	":"},set protocol(t){this.h||e.call(this,t+":","scheme start");},get host(){return this.h?"":this.m?this.i+":"+this.m:this.i},set host(t){!this.h&&this.A&&e.call(this,t,"host");},get hostname(){return this.i},set hostname(t){!this.h&&this.A&&e.call(this,t,"hostname");},get port(){return this.m},set port(t){!this.h&&this.A&&e.call(this,t,"port");},get pathname(){return this.h?"":this.A?"/"+this.j.join("/"):this.pa},set pathname(t){!this.h&&this.A&&(this.j=[],e.call(this,t,"relative path start"));},get search(){return this.h||
	!this.o||"?"==this.o?"":this.o},set search(t){!this.h&&this.A&&(this.o="?","?"==t[0]&&(t=t.slice(1)),e.call(this,t,"query"));},get hash(){return this.h||!this.u||"#"==this.u?"":this.u},set hash(t){this.h||(t?(this.u="#","#"==t[0]&&(t=t.slice(1)),e.call(this,t,"fragment")):this.u="");},get origin(){var t;if(this.h||!this.g)return "";switch(this.g){case "data":case "file":case "javascript":case "mailto":return "null"}return (t=this.host)?this.g+"://"+t:""}};var C=a.URL;C&&(g.createObjectURL=function(t){return C.createObjectURL.apply(C,
	arguments)},g.revokeObjectURL=function(t){C.revokeObjectURL(t);});a.URL=g;}})(window);Object.getOwnPropertyDescriptor(Node.prototype,"baseURI")||Object.defineProperty(Node.prototype,"baseURI",{get:function(){var a=(this.ownerDocument||this).querySelector("base[href]");return a&&a.href||window.location.href},configurable:!0,enumerable:!0});var bi=document.createElement("style");bi.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";var ci=document.querySelector("head");ci.insertBefore(bi,ci.firstChild);/*

	Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
	This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
	The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
	The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
	Code distributed by Google as part of the polymer project is also
	subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
	*/
	var di=window.customElements,ei=!1,fi=null;di.polyfillWrapFlushCallback&&di.polyfillWrapFlushCallback(function(a){fi=a;ei&&a();});function gi(){window.HTMLTemplateElement.bootstrap&&window.HTMLTemplateElement.bootstrap(window.document);fi&&fi();ei=!0;window.WebComponents.ready=!0;document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}));}
	"complete"!==document.readyState?(window.addEventListener("load",gi),window.addEventListener("DOMContentLoaded",function(){window.removeEventListener("load",gi);gi();})):gi();}).call(commonjsGlobal);

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	function _isNativeFunction(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}

	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;

	  _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !_isNativeFunction(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
	    }

	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return _setPrototypeOf(Wrapper, Class);
	  };

	  return _wrapNativeSuper(Class);
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();

	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	function _superPropBase(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = _getPrototypeOf(object);
	    if (object === null) break;
	  }

	  return object;
	}

	function _get(target, property, receiver) {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    _get = Reflect.get;
	  } else {
	    _get = function _get(target, property, receiver) {
	      var base = _superPropBase(target, property);

	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);

	      if (desc.get) {
	        return desc.get.call(receiver);
	      }

	      return desc.value;
	    };
	  }

	  return _get(target, property, receiver || target);
	}

	function _taggedTemplateLiteral(strings, raw) {
	  if (!raw) {
	    raw = strings.slice(0);
	  }

	  return Object.freeze(Object.defineProperties(strings, {
	    raw: {
	      value: Object.freeze(raw)
	    }
	  }));
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it;

	  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;

	      var F = function () {};

	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  var normalCompletion = true,
	      didErr = false,
	      err;
	  return {
	    s: function () {
	      it = o[Symbol.iterator]();
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}

	function _initializerDefineProperty(target, property, descriptor, context) {
	  if (!descriptor) return;
	  Object.defineProperty(target, property, {
	    enumerable: descriptor.enumerable,
	    configurable: descriptor.configurable,
	    writable: descriptor.writable,
	    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
	  });
	}

	function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
	  var desc = {};
	  Object.keys(descriptor).forEach(function (key) {
	    desc[key] = descriptor[key];
	  });
	  desc.enumerable = !!desc.enumerable;
	  desc.configurable = !!desc.configurable;

	  if ('value' in desc || desc.initializer) {
	    desc.writable = true;
	  }

	  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
	    return decorator(target, property, desc) || desc;
	  }, desc);

	  if (context && desc.initializer !== void 0) {
	    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
	    desc.initializer = undefined;
	  }

	  if (desc.initializer === void 0) {
	    Object.defineProperty(target, property, desc);
	    desc = null;
	  }

	  return desc;
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	function __decorate(decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */

	/**
	 * True if the custom elements polyfill is in use.
	 */
	var isCEPolyfill = typeof window !== 'undefined' && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== undefined;
	/**
	 * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
	 * into another container (could be the same container), before `before`. If
	 * `before` is null, it appends the nodes to the container.
	 */

	var reparentNodes = function reparentNodes(container, start) {
	  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	  var before = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	  while (start !== end) {
	    var n = start.nextSibling;
	    container.insertBefore(start, before);
	    start = n;
	  }
	};
	/**
	 * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
	 * `container`.
	 */

	var removeNodes = function removeNodes(container, start) {
	  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  while (start !== end) {
	    var n = start.nextSibling;
	    container.removeChild(start);
	    start = n;
	  }
	};

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */

	/**
	 * An expression marker with embedded unique key to avoid collision with
	 * possible text in templates.
	 */
	var marker = "{{lit-".concat(String(Math.random()).slice(2), "}}");
	/**
	 * An expression marker used text-positions, multi-binding attributes, and
	 * attributes with markup-like text values.
	 */

	var nodeMarker = "<!--".concat(marker, "-->");
	var markerRegex = new RegExp("".concat(marker, "|").concat(nodeMarker));
	/**
	 * Suffix appended to all bound attribute names.
	 */

	var boundAttributeSuffix = '$lit$';
	/**
	 * An updatable Template that tracks the location of dynamic parts.
	 */

	var Template = function Template(result, element) {
	  _classCallCheck(this, Template);

	  this.parts = [];
	  this.element = element;
	  var nodesToRemove = [];
	  var stack = []; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

	  var walker = document.createTreeWalker(element.content, 133
	  /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
	  , null, false); // Keeps track of the last index associated with a part. We try to delete
	  // unnecessary nodes, but we never want to associate two different parts
	  // to the same index. They must have a constant node between.

	  var lastPartIndex = 0;
	  var index = -1;
	  var partIndex = 0;
	  var strings = result.strings,
	      length = result.values.length;

	  while (partIndex < length) {
	    var node = walker.nextNode();

	    if (node === null) {
	      // We've exhausted the content inside a nested template element.
	      // Because we still have parts (the outer for-loop), we know:
	      // - There is a template in the stack
	      // - The walker will find a nextNode outside the template
	      walker.currentNode = stack.pop();
	      continue;
	    }

	    index++;

	    if (node.nodeType === 1
	    /* Node.ELEMENT_NODE */
	    ) {
	        if (node.hasAttributes()) {
	          var attributes = node.attributes;
	          var _length = attributes.length; // Per
	          // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
	          // attributes are not guaranteed to be returned in document order.
	          // In particular, Edge/IE can return them out of order, so we cannot
	          // assume a correspondence between part index and attribute index.

	          var count = 0;

	          for (var i = 0; i < _length; i++) {
	            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
	              count++;
	            }
	          }

	          while (count-- > 0) {
	            // Get the template literal section leading up to the first
	            // expression in this attribute
	            var stringForPart = strings[partIndex]; // Find the attribute name

	            var name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute
	            // All bound attributes have had a suffix added in
	            // TemplateResult#getHTML to opt out of special attribute
	            // handling. To look up the attribute value we also need to add
	            // the suffix.

	            var attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
	            var attributeValue = node.getAttribute(attributeLookupName);
	            node.removeAttribute(attributeLookupName);
	            var statics = attributeValue.split(markerRegex);
	            this.parts.push({
	              type: 'attribute',
	              index: index,
	              name: name,
	              strings: statics
	            });
	            partIndex += statics.length - 1;
	          }
	        }

	        if (node.tagName === 'TEMPLATE') {
	          stack.push(node);
	          walker.currentNode = node.content;
	        }
	      } else if (node.nodeType === 3
	    /* Node.TEXT_NODE */
	    ) {
	        var data = node.data;

	        if (data.indexOf(marker) >= 0) {
	          var parent = node.parentNode;

	          var _strings = data.split(markerRegex);

	          var lastIndex = _strings.length - 1; // Generate a new text node for each literal section
	          // These nodes are also used as the markers for node parts

	          for (var _i = 0; _i < lastIndex; _i++) {
	            var insert = void 0;
	            var s = _strings[_i];

	            if (s === '') {
	              insert = createMarker();
	            } else {
	              var match = lastAttributeNameRegex.exec(s);

	              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
	                s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
	              }

	              insert = document.createTextNode(s);
	            }

	            parent.insertBefore(insert, node);
	            this.parts.push({
	              type: 'node',
	              index: ++index
	            });
	          } // If there's no text, we must insert a comment to mark our place.
	          // Else, we can trust it will stick around after cloning.


	          if (_strings[lastIndex] === '') {
	            parent.insertBefore(createMarker(), node);
	            nodesToRemove.push(node);
	          } else {
	            node.data = _strings[lastIndex];
	          } // We have a part for each match found


	          partIndex += lastIndex;
	        }
	      } else if (node.nodeType === 8
	    /* Node.COMMENT_NODE */
	    ) {
	        if (node.data === marker) {
	          var _parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of
	          // the following are true:
	          //  * We don't have a previousSibling
	          //  * The previousSibling is already the start of a previous part

	          if (node.previousSibling === null || index === lastPartIndex) {
	            index++;

	            _parent.insertBefore(createMarker(), node);
	          }

	          lastPartIndex = index;
	          this.parts.push({
	            type: 'node',
	            index: index
	          }); // If we don't have a nextSibling, keep this node so we have an end.
	          // Else, we can remove it to save future costs.

	          if (node.nextSibling === null) {
	            node.data = '';
	          } else {
	            nodesToRemove.push(node);
	            index--;
	          }

	          partIndex++;
	        } else {
	          var _i2 = -1;

	          while ((_i2 = node.data.indexOf(marker, _i2 + 1)) !== -1) {
	            // Comment node has a binding marker inside, make an inactive part
	            // The binding won't work, but subsequent bindings will
	            // TODO (justinfagnani): consider whether it's even worth it to
	            // make bindings in comments work
	            this.parts.push({
	              type: 'node',
	              index: -1
	            });
	            partIndex++;
	          }
	        }
	      }
	  } // Remove text binding nodes after the walk to not disturb the TreeWalker


	  for (var _i3 = 0, _nodesToRemove = nodesToRemove; _i3 < _nodesToRemove.length; _i3++) {
	    var n = _nodesToRemove[_i3];
	    n.parentNode.removeChild(n);
	  }
	};

	var endsWith = function endsWith(str, suffix) {
	  var index = str.length - suffix.length;
	  return index >= 0 && str.slice(index) === suffix;
	};

	var isTemplatePartActive = function isTemplatePartActive(part) {
	  return part.index !== -1;
	}; // Allows `document.createComment('')` to be renamed for a
	// small manual size-savings.

	var createMarker = function createMarker() {
	  return document.createComment('');
	};
	/**
	 * This regex extracts the attribute name preceding an attribute-position
	 * expression. It does this by matching the syntax allowed for attributes
	 * against the string literal directly preceding the expression, assuming that
	 * the expression is in an attribute-value position.
	 *
	 * See attributes in the HTML spec:
	 * https://www.w3.org/TR/html5/syntax.html#elements-attributes
	 *
	 * " \x09\x0a\x0c\x0d" are HTML space characters:
	 * https://www.w3.org/TR/html5/infrastructure.html#space-characters
	 *
	 * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
	 * space character except " ".
	 *
	 * So an attribute is:
	 *  * The name: any character except a control character, space character, ('),
	 *    ("), ">", "=", or "/"
	 *  * Followed by zero or more space characters
	 *  * Followed by "="
	 *  * Followed by zero or more space characters
	 *  * Followed by:
	 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
	 *    * (") then any non-("), or
	 *    * (') then any non-(')
	 */

	var lastAttributeNameRegex = // eslint-disable-next-line no-control-regex
	/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var walkerNodeFilter = 133
	/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
	;
	/**
	 * Removes the list of nodes from a Template safely. In addition to removing
	 * nodes from the Template, the Template part indices are updated to match
	 * the mutated Template DOM.
	 *
	 * As the template is walked the removal state is tracked and
	 * part indices are adjusted as needed.
	 *
	 * div
	 *   div#1 (remove) <-- start removing (removing node is div#1)
	 *     div
	 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
	 *         div
	 * div <-- stop removing since previous sibling is the removing node (div#1,
	 * removed 4 nodes)
	 */

	function removeNodesFromTemplate(template, nodesToRemove) {
	  var content = template.element.content,
	      parts = template.parts;
	  var walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
	  var partIndex = nextActiveIndexInTemplateParts(parts);
	  var part = parts[partIndex];
	  var nodeIndex = -1;
	  var removeCount = 0;
	  var nodesToRemoveInTemplate = [];
	  var currentRemovingNode = null;

	  while (walker.nextNode()) {
	    nodeIndex++;
	    var node = walker.currentNode; // End removal if stepped past the removing node

	    if (node.previousSibling === currentRemovingNode) {
	      currentRemovingNode = null;
	    } // A node to remove was found in the template


	    if (nodesToRemove.has(node)) {
	      nodesToRemoveInTemplate.push(node); // Track node we're removing

	      if (currentRemovingNode === null) {
	        currentRemovingNode = node;
	      }
	    } // When removing, increment count by which to adjust subsequent part indices


	    if (currentRemovingNode !== null) {
	      removeCount++;
	    }

	    while (part !== undefined && part.index === nodeIndex) {
	      // If part is in a removed node deactivate it by setting index to -1 or
	      // adjust the index as needed.
	      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount; // go to the next active part.

	      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
	      part = parts[partIndex];
	    }
	  }

	  nodesToRemoveInTemplate.forEach(function (n) {
	    return n.parentNode.removeChild(n);
	  });
	}

	var countNodes = function countNodes(node) {
	  var count = node.nodeType === 11
	  /* Node.DOCUMENT_FRAGMENT_NODE */
	  ? 0 : 1;
	  var walker = document.createTreeWalker(node, walkerNodeFilter, null, false);

	  while (walker.nextNode()) {
	    count++;
	  }

	  return count;
	};

	var nextActiveIndexInTemplateParts = function nextActiveIndexInTemplateParts(parts) {
	  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

	  for (var i = startIndex + 1; i < parts.length; i++) {
	    var part = parts[i];

	    if (isTemplatePartActive(part)) {
	      return i;
	    }
	  }

	  return -1;
	};
	/**
	 * Inserts the given node into the Template, optionally before the given
	 * refNode. In addition to inserting the node into the Template, the Template
	 * part indices are updated to match the mutated Template DOM.
	 */


	function insertNodeIntoTemplate(template, node) {
	  var refNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	  var content = template.element.content,
	      parts = template.parts; // If there's no refNode, then put node at end of template.
	  // No part indices need to be shifted in this case.

	  if (refNode === null || refNode === undefined) {
	    content.appendChild(node);
	    return;
	  }

	  var walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
	  var partIndex = nextActiveIndexInTemplateParts(parts);
	  var insertCount = 0;
	  var walkerIndex = -1;

	  while (walker.nextNode()) {
	    walkerIndex++;
	    var walkerNode = walker.currentNode;

	    if (walkerNode === refNode) {
	      insertCount = countNodes(node);
	      refNode.parentNode.insertBefore(node, refNode);
	    }

	    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
	      // If we've inserted the node, simply adjust all subsequent parts
	      if (insertCount > 0) {
	        while (partIndex !== -1) {
	          parts[partIndex].index += insertCount;
	          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
	        }

	        return;
	      }

	      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
	    }
	  }
	}

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var directives = new WeakMap();
	/**
	 * Brands a function as a directive factory function so that lit-html will call
	 * the function during template rendering, rather than passing as a value.
	 *
	 * A _directive_ is a function that takes a Part as an argument. It has the
	 * signature: `(part: Part) => void`.
	 *
	 * A directive _factory_ is a function that takes arguments for data and
	 * configuration and returns a directive. Users of directive usually refer to
	 * the directive factory as the directive. For example, "The repeat directive".
	 *
	 * Usually a template author will invoke a directive factory in their template
	 * with relevant arguments, which will then return a directive function.
	 *
	 * Here's an example of using the `repeat()` directive factory that takes an
	 * array and a function to render an item:
	 *
	 * ```js
	 * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
	 * ```
	 *
	 * When `repeat` is invoked, it returns a directive function that closes over
	 * `items` and the template function. When the outer template is rendered, the
	 * return directive function is called with the Part for the expression.
	 * `repeat` then performs it's custom logic to render multiple items.
	 *
	 * @param f The directive factory function. Must be a function that returns a
	 * function of the signature `(part: Part) => void`. The returned function will
	 * be called with the part object.
	 *
	 * @example
	 *
	 * import {directive, html} from 'lit-html';
	 *
	 * const immutable = directive((v) => (part) => {
	 *   if (part.value !== v) {
	 *     part.setValue(v)
	 *   }
	 * });
	 */

	var directive = function directive(f) {
	  return function () {
	    var d = f.apply(void 0, arguments);
	    directives.set(d, true);
	    return d;
	  };
	};
	var isDirective = function isDirective(o) {
	  return typeof o === 'function' && directives.has(o);
	};

	/**
	 * @license
	 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */

	/**
	 * A sentinel value that signals that a value was handled by a directive and
	 * should not be written to the DOM.
	 */
	var noChange = {};
	/**
	 * A sentinel value that signals a NodePart to fully clear its content.
	 */

	var nothing = {};

	/**
	 * An instance of a `Template` that can be attached to the DOM and updated
	 * with new values.
	 */

	var TemplateInstance = /*#__PURE__*/function () {
	  function TemplateInstance(template, processor, options) {
	    _classCallCheck(this, TemplateInstance);

	    this.__parts = [];
	    this.template = template;
	    this.processor = processor;
	    this.options = options;
	  }

	  _createClass(TemplateInstance, [{
	    key: "update",
	    value: function update(values) {
	      var i = 0;

	      var _iterator = _createForOfIteratorHelper(this.__parts),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var part = _step.value;

	          if (part !== undefined) {
	            part.setValue(values[i]);
	          }

	          i++;
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      var _iterator2 = _createForOfIteratorHelper(this.__parts),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _part = _step2.value;

	          if (_part !== undefined) {
	            _part.commit();
	          }
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	    }
	  }, {
	    key: "_clone",
	    value: function _clone() {
	      // There are a number of steps in the lifecycle of a template instance's
	      // DOM fragment:
	      //  1. Clone - create the instance fragment
	      //  2. Adopt - adopt into the main document
	      //  3. Process - find part markers and create parts
	      //  4. Upgrade - upgrade custom elements
	      //  5. Update - set node, attribute, property, etc., values
	      //  6. Connect - connect to the document. Optional and outside of this
	      //     method.
	      //
	      // We have a few constraints on the ordering of these steps:
	      //  * We need to upgrade before updating, so that property values will pass
	      //    through any property setters.
	      //  * We would like to process before upgrading so that we're sure that the
	      //    cloned fragment is inert and not disturbed by self-modifying DOM.
	      //  * We want custom elements to upgrade even in disconnected fragments.
	      //
	      // Given these constraints, with full custom elements support we would
	      // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
	      //
	      // But Safari does not implement CustomElementRegistry#upgrade, so we
	      // can not implement that order and still have upgrade-before-update and
	      // upgrade disconnected fragments. So we instead sacrifice the
	      // process-before-upgrade constraint, since in Custom Elements v1 elements
	      // must not modify their light DOM in the constructor. We still have issues
	      // when co-existing with CEv0 elements like Polymer 1, and with polyfills
	      // that don't strictly adhere to the no-modification rule because shadow
	      // DOM, which may be created in the constructor, is emulated by being placed
	      // in the light DOM.
	      //
	      // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
	      // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
	      // in one step.
	      //
	      // The Custom Elements v1 polyfill supports upgrade(), so the order when
	      // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
	      // Connect.
	      var fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
	      var stack = [];
	      var parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

	      var walker = document.createTreeWalker(fragment, 133
	      /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
	      , null, false);
	      var partIndex = 0;
	      var nodeIndex = 0;
	      var part;
	      var node = walker.nextNode(); // Loop through all the nodes and parts of a template

	      while (partIndex < parts.length) {
	        part = parts[partIndex];

	        if (!isTemplatePartActive(part)) {
	          this.__parts.push(undefined);

	          partIndex++;
	          continue;
	        } // Progress the tree walker until we find our next part's node.
	        // Note that multiple parts may share the same node (attribute parts
	        // on a single element), so this loop may not run at all.


	        while (nodeIndex < part.index) {
	          nodeIndex++;

	          if (node.nodeName === 'TEMPLATE') {
	            stack.push(node);
	            walker.currentNode = node.content;
	          }

	          if ((node = walker.nextNode()) === null) {
	            // We've exhausted the content inside a nested template element.
	            // Because we still have parts (the outer for-loop), we know:
	            // - There is a template in the stack
	            // - The walker will find a nextNode outside the template
	            walker.currentNode = stack.pop();
	            node = walker.nextNode();
	          }
	        } // We've arrived at our part's node.


	        if (part.type === 'node') {
	          var _part2 = this.processor.handleTextExpression(this.options);

	          _part2.insertAfterNode(node.previousSibling);

	          this.__parts.push(_part2);
	        } else {
	          var _this$__parts;

	          (_this$__parts = this.__parts).push.apply(_this$__parts, _toConsumableArray(this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options)));
	        }

	        partIndex++;
	      }

	      if (isCEPolyfill) {
	        document.adoptNode(fragment);
	        customElements.upgrade(fragment);
	      }

	      return fragment;
	    }
	  }]);

	  return TemplateInstance;
	}();

	var commentMarker = " ".concat(marker, " ");
	/**
	 * The return type of `html`, which holds a Template and the values from
	 * interpolated expressions.
	 */

	var TemplateResult = /*#__PURE__*/function () {
	  function TemplateResult(strings, values, type, processor) {
	    _classCallCheck(this, TemplateResult);

	    this.strings = strings;
	    this.values = values;
	    this.type = type;
	    this.processor = processor;
	  }
	  /**
	   * Returns a string of HTML used to create a `<template>` element.
	   */


	  _createClass(TemplateResult, [{
	    key: "getHTML",
	    value: function getHTML() {
	      var l = this.strings.length - 1;
	      var html = '';
	      var isCommentBinding = false;

	      for (var i = 0; i < l; i++) {
	        var s = this.strings[i]; // For each binding we want to determine the kind of marker to insert
	        // into the template source before it's parsed by the browser's HTML
	        // parser. The marker type is based on whether the expression is in an
	        // attribute, text, or comment position.
	        //   * For node-position bindings we insert a comment with the marker
	        //     sentinel as its text content, like <!--{{lit-guid}}-->.
	        //   * For attribute bindings we insert just the marker sentinel for the
	        //     first binding, so that we support unquoted attribute bindings.
	        //     Subsequent bindings can use a comment marker because multi-binding
	        //     attributes must be quoted.
	        //   * For comment bindings we insert just the marker sentinel so we don't
	        //     close the comment.
	        //
	        // The following code scans the template source, but is *not* an HTML
	        // parser. We don't need to track the tree structure of the HTML, only
	        // whether a binding is inside a comment, and if not, if it appears to be
	        // the first binding in an attribute.

	        var commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following
	        // comment close. Because <-- can appear in an attribute value there can
	        // be false positives.

	        isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceding the
	        // expression. This can match "name=value" like structures in text,
	        // comments, and attribute values, so there can be false-positives.

	        var attributeMatch = lastAttributeNameRegex.exec(s);

	        if (attributeMatch === null) {
	          // We're only in this branch if we don't have a attribute-like
	          // preceding sequence. For comments, this guards against unusual
	          // attribute values like <div foo="<!--${'bar'}">. Cases like
	          // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
	          // below.
	          html += s + (isCommentBinding ? commentMarker : nodeMarker);
	        } else {
	          // For attributes we use just a marker sentinel, and also append a
	          // $lit$ suffix to the name to opt-out of attribute-specific parsing
	          // that IE and Edge do for style and certain SVG attributes.
	          html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
	        }
	      }

	      html += this.strings[l];
	      return html;
	    }
	  }, {
	    key: "getTemplateElement",
	    value: function getTemplateElement() {
	      var template = document.createElement('template');
	      template.innerHTML = this.getHTML();
	      return template;
	    }
	  }]);

	  return TemplateResult;
	}();

	var isPrimitive = function isPrimitive(value) {
	  return value === null || !(_typeof(value) === 'object' || typeof value === 'function');
	};
	var isIterable = function isIterable(value) {
	  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  !!(value && value[Symbol.iterator]);
	};
	/**
	 * Writes attribute values to the DOM for a group of AttributeParts bound to a
	 * single attribute. The value is only set once even if there are multiple parts
	 * for an attribute.
	 */

	var AttributeCommitter = /*#__PURE__*/function () {
	  function AttributeCommitter(element, name, strings) {
	    _classCallCheck(this, AttributeCommitter);

	    this.dirty = true;
	    this.element = element;
	    this.name = name;
	    this.strings = strings;
	    this.parts = [];

	    for (var i = 0; i < strings.length - 1; i++) {
	      this.parts[i] = this._createPart();
	    }
	  }
	  /**
	   * Creates a single part. Override this to create a differnt type of part.
	   */


	  _createClass(AttributeCommitter, [{
	    key: "_createPart",
	    value: function _createPart() {
	      return new AttributePart(this);
	    }
	  }, {
	    key: "_getValue",
	    value: function _getValue() {
	      var strings = this.strings;
	      var l = strings.length - 1;
	      var text = '';

	      for (var i = 0; i < l; i++) {
	        text += strings[i];
	        var part = this.parts[i];

	        if (part !== undefined) {
	          var v = part.value;

	          if (isPrimitive(v) || !isIterable(v)) {
	            text += typeof v === 'string' ? v : String(v);
	          } else {
	            var _iterator = _createForOfIteratorHelper(v),
	                _step;

	            try {
	              for (_iterator.s(); !(_step = _iterator.n()).done;) {
	                var t = _step.value;
	                text += typeof t === 'string' ? t : String(t);
	              }
	            } catch (err) {
	              _iterator.e(err);
	            } finally {
	              _iterator.f();
	            }
	          }
	        }
	      }

	      text += strings[l];
	      return text;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      if (this.dirty) {
	        this.dirty = false;
	        this.element.setAttribute(this.name, this._getValue());
	      }
	    }
	  }]);

	  return AttributeCommitter;
	}();
	/**
	 * A Part that controls all or part of an attribute value.
	 */

	var AttributePart = /*#__PURE__*/function () {
	  function AttributePart(committer) {
	    _classCallCheck(this, AttributePart);

	    this.value = undefined;
	    this.committer = committer;
	  }

	  _createClass(AttributePart, [{
	    key: "setValue",
	    value: function setValue(value) {
	      if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
	        this.value = value; // If the value is a not a directive, dirty the committer so that it'll
	        // call setAttribute. If the value is a directive, it'll dirty the
	        // committer if it calls setValue().

	        if (!isDirective(value)) {
	          this.committer.dirty = true;
	        }
	      }
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      while (isDirective(this.value)) {
	        var directive = this.value;
	        this.value = noChange;
	        directive(this);
	      }

	      if (this.value === noChange) {
	        return;
	      }

	      this.committer.commit();
	    }
	  }]);

	  return AttributePart;
	}();
	/**
	 * A Part that controls a location within a Node tree. Like a Range, NodePart
	 * has start and end locations and can set and update the Nodes between those
	 * locations.
	 *
	 * NodeParts support several value types: primitives, Nodes, TemplateResults,
	 * as well as arrays and iterables of those types.
	 */

	var NodePart = /*#__PURE__*/function () {
	  function NodePart(options) {
	    _classCallCheck(this, NodePart);

	    this.value = undefined;
	    this.__pendingValue = undefined;
	    this.options = options;
	  }
	  /**
	   * Appends this part into a container.
	   *
	   * This part must be empty, as its contents are not automatically moved.
	   */


	  _createClass(NodePart, [{
	    key: "appendInto",
	    value: function appendInto(container) {
	      this.startNode = container.appendChild(createMarker());
	      this.endNode = container.appendChild(createMarker());
	    }
	    /**
	     * Inserts this part after the `ref` node (between `ref` and `ref`'s next
	     * sibling). Both `ref` and its next sibling must be static, unchanging nodes
	     * such as those that appear in a literal section of a template.
	     *
	     * This part must be empty, as its contents are not automatically moved.
	     */

	  }, {
	    key: "insertAfterNode",
	    value: function insertAfterNode(ref) {
	      this.startNode = ref;
	      this.endNode = ref.nextSibling;
	    }
	    /**
	     * Appends this part into a parent part.
	     *
	     * This part must be empty, as its contents are not automatically moved.
	     */

	  }, {
	    key: "appendIntoPart",
	    value: function appendIntoPart(part) {
	      part.__insert(this.startNode = createMarker());

	      part.__insert(this.endNode = createMarker());
	    }
	    /**
	     * Inserts this part after the `ref` part.
	     *
	     * This part must be empty, as its contents are not automatically moved.
	     */

	  }, {
	    key: "insertAfterPart",
	    value: function insertAfterPart(ref) {
	      ref.__insert(this.startNode = createMarker());

	      this.endNode = ref.endNode;
	      ref.endNode = this.startNode;
	    }
	  }, {
	    key: "setValue",
	    value: function setValue(value) {
	      this.__pendingValue = value;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      if (this.startNode.parentNode === null) {
	        return;
	      }

	      while (isDirective(this.__pendingValue)) {
	        var directive = this.__pendingValue;
	        this.__pendingValue = noChange;
	        directive(this);
	      }

	      var value = this.__pendingValue;

	      if (value === noChange) {
	        return;
	      }

	      if (isPrimitive(value)) {
	        if (value !== this.value) {
	          this.__commitText(value);
	        }
	      } else if (value instanceof TemplateResult) {
	        this.__commitTemplateResult(value);
	      } else if (value instanceof Node) {
	        this.__commitNode(value);
	      } else if (isIterable(value)) {
	        this.__commitIterable(value);
	      } else if (value === nothing) {
	        this.value = nothing;
	        this.clear();
	      } else {
	        // Fallback, will render the string representation
	        this.__commitText(value);
	      }
	    }
	  }, {
	    key: "__insert",
	    value: function __insert(node) {
	      this.endNode.parentNode.insertBefore(node, this.endNode);
	    }
	  }, {
	    key: "__commitNode",
	    value: function __commitNode(value) {
	      if (this.value === value) {
	        return;
	      }

	      this.clear();

	      this.__insert(value);

	      this.value = value;
	    }
	  }, {
	    key: "__commitText",
	    value: function __commitText(value) {
	      var node = this.startNode.nextSibling;
	      value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case
	      // it can't be implicitly converted - i.e. it's a symbol.

	      var valueAsString = typeof value === 'string' ? value : String(value);

	      if (node === this.endNode.previousSibling && node.nodeType === 3
	      /* Node.TEXT_NODE */
	      ) {
	          // If we only have a single text node between the markers, we can just
	          // set its value, rather than replacing it.
	          // TODO(justinfagnani): Can we just check if this.value is primitive?
	          node.data = valueAsString;
	        } else {
	        this.__commitNode(document.createTextNode(valueAsString));
	      }

	      this.value = value;
	    }
	  }, {
	    key: "__commitTemplateResult",
	    value: function __commitTemplateResult(value) {
	      var template = this.options.templateFactory(value);

	      if (this.value instanceof TemplateInstance && this.value.template === template) {
	        this.value.update(value.values);
	      } else {
	        // Make sure we propagate the template processor from the TemplateResult
	        // so that we use its syntax extension, etc. The template factory comes
	        // from the render function options so that it can control template
	        // caching and preprocessing.
	        var instance = new TemplateInstance(template, value.processor, this.options);

	        var fragment = instance._clone();

	        instance.update(value.values);

	        this.__commitNode(fragment);

	        this.value = instance;
	      }
	    }
	  }, {
	    key: "__commitIterable",
	    value: function __commitIterable(value) {
	      // For an Iterable, we create a new InstancePart per item, then set its
	      // value to the item. This is a little bit of overhead for every item in
	      // an Iterable, but it lets us recurse easily and efficiently update Arrays
	      // of TemplateResults that will be commonly returned from expressions like:
	      // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
	      // If _value is an array, then the previous render was of an
	      // iterable and _value will contain the NodeParts from the previous
	      // render. If _value is not an array, clear this part and make a new
	      // array for NodeParts.
	      if (!Array.isArray(this.value)) {
	        this.value = [];
	        this.clear();
	      } // Lets us keep track of how many items we stamped so we can clear leftover
	      // items from a previous render


	      var itemParts = this.value;
	      var partIndex = 0;
	      var itemPart;

	      var _iterator2 = _createForOfIteratorHelper(value),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var item = _step2.value;
	          // Try to reuse an existing part
	          itemPart = itemParts[partIndex]; // If no existing part, create a new one

	          if (itemPart === undefined) {
	            itemPart = new NodePart(this.options);
	            itemParts.push(itemPart);

	            if (partIndex === 0) {
	              itemPart.appendIntoPart(this);
	            } else {
	              itemPart.insertAfterPart(itemParts[partIndex - 1]);
	            }
	          }

	          itemPart.setValue(item);
	          itemPart.commit();
	          partIndex++;
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }

	      if (partIndex < itemParts.length) {
	        // Truncate the parts array so _value reflects the current state
	        itemParts.length = partIndex;
	        this.clear(itemPart && itemPart.endNode);
	      }
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;
	      removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
	    }
	  }]);

	  return NodePart;
	}();
	/**
	 * Implements a boolean attribute, roughly as defined in the HTML
	 * specification.
	 *
	 * If the value is truthy, then the attribute is present with a value of
	 * ''. If the value is falsey, the attribute is removed.
	 */

	var BooleanAttributePart = /*#__PURE__*/function () {
	  function BooleanAttributePart(element, name, strings) {
	    _classCallCheck(this, BooleanAttributePart);

	    this.value = undefined;
	    this.__pendingValue = undefined;

	    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
	      throw new Error('Boolean attributes can only contain a single expression');
	    }

	    this.element = element;
	    this.name = name;
	    this.strings = strings;
	  }

	  _createClass(BooleanAttributePart, [{
	    key: "setValue",
	    value: function setValue(value) {
	      this.__pendingValue = value;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      while (isDirective(this.__pendingValue)) {
	        var directive = this.__pendingValue;
	        this.__pendingValue = noChange;
	        directive(this);
	      }

	      if (this.__pendingValue === noChange) {
	        return;
	      }

	      var value = !!this.__pendingValue;

	      if (this.value !== value) {
	        if (value) {
	          this.element.setAttribute(this.name, '');
	        } else {
	          this.element.removeAttribute(this.name);
	        }

	        this.value = value;
	      }

	      this.__pendingValue = noChange;
	    }
	  }]);

	  return BooleanAttributePart;
	}();
	/**
	 * Sets attribute values for PropertyParts, so that the value is only set once
	 * even if there are multiple parts for a property.
	 *
	 * If an expression controls the whole property value, then the value is simply
	 * assigned to the property under control. If there are string literals or
	 * multiple expressions, then the strings are expressions are interpolated into
	 * a string first.
	 */

	var PropertyCommitter = /*#__PURE__*/function (_AttributeCommitter) {
	  _inherits(PropertyCommitter, _AttributeCommitter);

	  var _super = _createSuper(PropertyCommitter);

	  function PropertyCommitter(element, name, strings) {
	    var _this;

	    _classCallCheck(this, PropertyCommitter);

	    _this = _super.call(this, element, name, strings);
	    _this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
	    return _this;
	  }

	  _createClass(PropertyCommitter, [{
	    key: "_createPart",
	    value: function _createPart() {
	      return new PropertyPart(this);
	    }
	  }, {
	    key: "_getValue",
	    value: function _getValue() {
	      if (this.single) {
	        return this.parts[0].value;
	      }

	      return _get(_getPrototypeOf(PropertyCommitter.prototype), "_getValue", this).call(this);
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      if (this.dirty) {
	        this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any

	        this.element[this.name] = this._getValue();
	      }
	    }
	  }]);

	  return PropertyCommitter;
	}(AttributeCommitter);
	var PropertyPart = /*#__PURE__*/function (_AttributePart) {
	  _inherits(PropertyPart, _AttributePart);

	  var _super2 = _createSuper(PropertyPart);

	  function PropertyPart() {
	    _classCallCheck(this, PropertyPart);

	    return _super2.apply(this, arguments);
	  }

	  return PropertyPart;
	}(AttributePart); // Detect event listener options support. If the `capture` property is read
	// from the options object, then options are supported. If not, then the third
	// argument to add/removeEventListener is interpreted as the boolean capture
	// value so we should only pass the `capture` property.

	var eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
	// blocks right into the body of a module

	(function () {
	  try {
	    var options = {
	      get capture() {
	        eventOptionsSupported = true;
	        return false;
	      }

	    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

	    window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any

	    window.removeEventListener('test', options, options);
	  } catch (_e) {// event options not supported
	  }
	})();

	var EventPart = /*#__PURE__*/function () {
	  function EventPart(element, eventName, eventContext) {
	    var _this2 = this;

	    _classCallCheck(this, EventPart);

	    this.value = undefined;
	    this.__pendingValue = undefined;
	    this.element = element;
	    this.eventName = eventName;
	    this.eventContext = eventContext;

	    this.__boundHandleEvent = function (e) {
	      return _this2.handleEvent(e);
	    };
	  }

	  _createClass(EventPart, [{
	    key: "setValue",
	    value: function setValue(value) {
	      this.__pendingValue = value;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      while (isDirective(this.__pendingValue)) {
	        var directive = this.__pendingValue;
	        this.__pendingValue = noChange;
	        directive(this);
	      }

	      if (this.__pendingValue === noChange) {
	        return;
	      }

	      var newListener = this.__pendingValue;
	      var oldListener = this.value;
	      var shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
	      var shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);

	      if (shouldRemoveListener) {
	        this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
	      }

	      if (shouldAddListener) {
	        this.__options = getOptions(newListener);
	        this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
	      }

	      this.value = newListener;
	      this.__pendingValue = noChange;
	    }
	  }, {
	    key: "handleEvent",
	    value: function handleEvent(event) {
	      if (typeof this.value === 'function') {
	        this.value.call(this.eventContext || this.element, event);
	      } else {
	        this.value.handleEvent(event);
	      }
	    }
	  }]);

	  return EventPart;
	}(); // We copy options because of the inconsistent behavior of browsers when reading
	// the third argument of add/removeEventListener. IE11 doesn't support options
	// at all. Chrome 41 only reads `capture` if the argument is an object.

	var getOptions = function getOptions(o) {
	  return o && (eventOptionsSupported ? {
	    capture: o.capture,
	    passive: o.passive,
	    once: o.once
	  } : o.capture);
	};

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	/**
	 * The default TemplateFactory which caches Templates keyed on
	 * result.type and result.strings.
	 */

	function templateFactory(result) {
	  var templateCache = templateCaches.get(result.type);

	  if (templateCache === undefined) {
	    templateCache = {
	      stringsArray: new WeakMap(),
	      keyString: new Map()
	    };
	    templateCaches.set(result.type, templateCache);
	  }

	  var template = templateCache.stringsArray.get(result.strings);

	  if (template !== undefined) {
	    return template;
	  } // If the TemplateStringsArray is new, generate a key from the strings
	  // This key is shared between all templates with identical content


	  var key = result.strings.join(marker); // Check if we already have a Template for this key

	  template = templateCache.keyString.get(key);

	  if (template === undefined) {
	    // If we have not seen this key before, create a new Template
	    template = new Template(result, result.getTemplateElement()); // Cache the Template for this key

	    templateCache.keyString.set(key, template);
	  } // Cache all future queries for this TemplateStringsArray


	  templateCache.stringsArray.set(result.strings, template);
	  return template;
	}
	var templateCaches = new Map();

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var parts = new WeakMap();
	/**
	 * Renders a template result or other value to a container.
	 *
	 * To update a container with new values, reevaluate the template literal and
	 * call `render` with the new result.
	 *
	 * @param result Any value renderable by NodePart - typically a TemplateResult
	 *     created by evaluating a template tag like `html` or `svg`.
	 * @param container A DOM parent to render to. The entire contents are either
	 *     replaced, or efficiently updated if the same result type was previous
	 *     rendered there.
	 * @param options RenderOptions for the entire render tree rendered to this
	 *     container. Render options must *not* change between renders to the same
	 *     container, as those changes will not effect previously rendered DOM.
	 */

	var render = function render(result, container, options) {
	  var part = parts.get(container);

	  if (part === undefined) {
	    removeNodes(container, container.firstChild);
	    parts.set(container, part = new NodePart(Object.assign({
	      templateFactory: templateFactory
	    }, options)));
	    part.appendInto(container);
	  }

	  part.setValue(result);
	  part.commit();
	};

	/**
	 * Creates Parts when a template is instantiated.
	 */

	var DefaultTemplateProcessor = /*#__PURE__*/function () {
	  function DefaultTemplateProcessor() {
	    _classCallCheck(this, DefaultTemplateProcessor);
	  }

	  _createClass(DefaultTemplateProcessor, [{
	    key: "handleAttributeExpressions",

	    /**
	     * Create parts for an attribute-position binding, given the event, attribute
	     * name, and string literals.
	     *
	     * @param element The element containing the binding
	     * @param name  The attribute name
	     * @param strings The string literals. There are always at least two strings,
	     *   event for fully-controlled bindings with a single expression.
	     */
	    value: function handleAttributeExpressions(element, name, strings, options) {
	      var prefix = name[0];

	      if (prefix === '.') {
	        var _committer = new PropertyCommitter(element, name.slice(1), strings);

	        return _committer.parts;
	      }

	      if (prefix === '@') {
	        return [new EventPart(element, name.slice(1), options.eventContext)];
	      }

	      if (prefix === '?') {
	        return [new BooleanAttributePart(element, name.slice(1), strings)];
	      }

	      var committer = new AttributeCommitter(element, name, strings);
	      return committer.parts;
	    }
	    /**
	     * Create parts for a text-position binding.
	     * @param templateFactory
	     */

	  }, {
	    key: "handleTextExpression",
	    value: function handleTextExpression(options) {
	      return new NodePart(options);
	    }
	  }]);

	  return DefaultTemplateProcessor;
	}();
	var defaultTemplateProcessor = new DefaultTemplateProcessor();

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	// This line will be used in regexes to search for lit-html usage.
	// TODO(justinfagnani): inject version number at build time

	if (typeof window !== 'undefined') {
	  (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.2.1');
	}
	/**
	 * Interprets a template literal as an HTML template that can efficiently
	 * render to and update a container.
	 */


	var html$1 = function html(strings) {
	  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    values[_key - 1] = arguments[_key];
	  }

	  return new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
	};

	var getTemplateCacheKey = function getTemplateCacheKey(type, scopeName) {
	  return "".concat(type, "--").concat(scopeName);
	};

	var compatibleShadyCSSVersion = true;

	if (typeof window.ShadyCSS === 'undefined') {
	  compatibleShadyCSSVersion = false;
	} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
	  console.warn("Incompatible ShadyCSS version detected. " + "Please update to at least @webcomponents/webcomponentsjs@2.0.2 and " + "@webcomponents/shadycss@1.3.1.");
	  compatibleShadyCSSVersion = false;
	}
	/**
	 * Template factory which scopes template DOM using ShadyCSS.
	 * @param scopeName {string}
	 */


	var shadyTemplateFactory = function shadyTemplateFactory(scopeName) {
	  return function (result) {
	    var cacheKey = getTemplateCacheKey(result.type, scopeName);
	    var templateCache = templateCaches.get(cacheKey);

	    if (templateCache === undefined) {
	      templateCache = {
	        stringsArray: new WeakMap(),
	        keyString: new Map()
	      };
	      templateCaches.set(cacheKey, templateCache);
	    }

	    var template = templateCache.stringsArray.get(result.strings);

	    if (template !== undefined) {
	      return template;
	    }

	    var key = result.strings.join(marker);
	    template = templateCache.keyString.get(key);

	    if (template === undefined) {
	      var element = result.getTemplateElement();

	      if (compatibleShadyCSSVersion) {
	        window.ShadyCSS.prepareTemplateDom(element, scopeName);
	      }

	      template = new Template(result, element);
	      templateCache.keyString.set(key, template);
	    }

	    templateCache.stringsArray.set(result.strings, template);
	    return template;
	  };
	};

	var TEMPLATE_TYPES = ['html', 'svg'];
	/**
	 * Removes all style elements from Templates for the given scopeName.
	 */

	var removeStylesFromLitTemplates = function removeStylesFromLitTemplates(scopeName) {
	  TEMPLATE_TYPES.forEach(function (type) {
	    var templates = templateCaches.get(getTemplateCacheKey(type, scopeName));

	    if (templates !== undefined) {
	      templates.keyString.forEach(function (template) {
	        var content = template.element.content; // IE 11 doesn't support the iterable param Set constructor

	        var styles = new Set();
	        Array.from(content.querySelectorAll('style')).forEach(function (s) {
	          styles.add(s);
	        });
	        removeNodesFromTemplate(template, styles);
	      });
	    }
	  });
	};

	var shadyRenderSet = new Set();
	/**
	 * For the given scope name, ensures that ShadyCSS style scoping is performed.
	 * This is done just once per scope name so the fragment and template cannot
	 * be modified.
	 * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
	 * to be scoped and appended to the document
	 * (2) removes style elements from all lit-html Templates for this scope name.
	 *
	 * Note, <style> elements can only be placed into templates for the
	 * initial rendering of the scope. If <style> elements are included in templates
	 * dynamically rendered to the scope (after the first scope render), they will
	 * not be scoped and the <style> will be left in the template and rendered
	 * output.
	 */

	var prepareTemplateStyles = function prepareTemplateStyles(scopeName, renderedDOM, template) {
	  shadyRenderSet.add(scopeName); // If `renderedDOM` is stamped from a Template, then we need to edit that
	  // Template's underlying template element. Otherwise, we create one here
	  // to give to ShadyCSS, which still requires one while scoping.

	  var templateElement = !!template ? template.element : document.createElement('template'); // Move styles out of rendered DOM and store.

	  var styles = renderedDOM.querySelectorAll('style');
	  var length = styles.length; // If there are no styles, skip unnecessary work

	  if (length === 0) {
	    // Ensure prepareTemplateStyles is called to support adding
	    // styles via `prepareAdoptedCssText` since that requires that
	    // `prepareTemplateStyles` is called.
	    //
	    // ShadyCSS will only update styles containing @apply in the template
	    // given to `prepareTemplateStyles`. If no lit Template was given,
	    // ShadyCSS will not be able to update uses of @apply in any relevant
	    // template. However, this is not a problem because we only create the
	    // template for the purpose of supporting `prepareAdoptedCssText`,
	    // which doesn't support @apply at all.
	    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
	    return;
	  }

	  var condensedStyle = document.createElement('style'); // Collect styles into a single style. This helps us make sure ShadyCSS
	  // manipulations will not prevent us from being able to fix up template
	  // part indices.
	  // NOTE: collecting styles is inefficient for browsers but ShadyCSS
	  // currently does this anyway. When it does not, this should be changed.

	  for (var i = 0; i < length; i++) {
	    var _style = styles[i];

	    _style.parentNode.removeChild(_style);

	    condensedStyle.textContent += _style.textContent;
	  } // Remove styles from nested templates in this scope.


	  removeStylesFromLitTemplates(scopeName); // And then put the condensed style into the "root" template passed in as
	  // `template`.

	  var content = templateElement.content;

	  if (!!template) {
	    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
	  } else {
	    content.insertBefore(condensedStyle, content.firstChild);
	  } // Note, it's important that ShadyCSS gets the template that `lit-html`
	  // will actually render so that it can update the style inside when
	  // needed (e.g. @apply native Shadow DOM case).


	  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
	  var style = content.querySelector('style');

	  if (window.ShadyCSS.nativeShadow && style !== null) {
	    // When in native Shadow DOM, ensure the style created by ShadyCSS is
	    // included in initially rendered output (`renderedDOM`).
	    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
	  } else if (!!template) {
	    // When no style is left in the template, parts will be broken as a
	    // result. To fix this, we put back the style node ShadyCSS removed
	    // and then tell lit to remove that node from the template.
	    // There can be no style in the template in 2 cases (1) when Shady DOM
	    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
	    // is in use ShadyCSS removes the style if it contains no content.
	    // NOTE, ShadyCSS creates its own style so we can safely add/remove
	    // `condensedStyle` here.
	    content.insertBefore(condensedStyle, content.firstChild);
	    var removes = new Set();
	    removes.add(condensedStyle);
	    removeNodesFromTemplate(template, removes);
	  }
	};
	/**
	 * Extension to the standard `render` method which supports rendering
	 * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
	 * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
	 * or when the webcomponentsjs
	 * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
	 *
	 * Adds a `scopeName` option which is used to scope element DOM and stylesheets
	 * when native ShadowDOM is unavailable. The `scopeName` will be added to
	 * the class attribute of all rendered DOM. In addition, any style elements will
	 * be automatically re-written with this `scopeName` selector and moved out
	 * of the rendered DOM and into the document `<head>`.
	 *
	 * It is common to use this render method in conjunction with a custom element
	 * which renders a shadowRoot. When this is done, typically the element's
	 * `localName` should be used as the `scopeName`.
	 *
	 * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
	 * custom properties (needed only on older browsers like IE11) and a shim for
	 * a deprecated feature called `@apply` that supports applying a set of css
	 * custom properties to a given location.
	 *
	 * Usage considerations:
	 *
	 * * Part values in `<style>` elements are only applied the first time a given
	 * `scopeName` renders. Subsequent changes to parts in style elements will have
	 * no effect. Because of this, parts in style elements should only be used for
	 * values that will never change, for example parts that set scope-wide theme
	 * values or parts which render shared style elements.
	 *
	 * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
	 * custom element's `constructor` is not supported. Instead rendering should
	 * either done asynchronously, for example at microtask timing (for example
	 * `Promise.resolve()`), or be deferred until the first time the element's
	 * `connectedCallback` runs.
	 *
	 * Usage considerations when using shimmed custom properties or `@apply`:
	 *
	 * * Whenever any dynamic changes are made which affect
	 * css custom properties, `ShadyCSS.styleElement(element)` must be called
	 * to update the element. There are two cases when this is needed:
	 * (1) the element is connected to a new parent, (2) a class is added to the
	 * element that causes it to match different custom properties.
	 * To address the first case when rendering a custom element, `styleElement`
	 * should be called in the element's `connectedCallback`.
	 *
	 * * Shimmed custom properties may only be defined either for an entire
	 * shadowRoot (for example, in a `:host` rule) or via a rule that directly
	 * matches an element with a shadowRoot. In other words, instead of flowing from
	 * parent to child as do native css custom properties, shimmed custom properties
	 * flow only from shadowRoots to nested shadowRoots.
	 *
	 * * When using `@apply` mixing css shorthand property names with
	 * non-shorthand names (for example `border` and `border-width`) is not
	 * supported.
	 */


	var render$1 = function render$1(result, container, options) {
	  if (!options || _typeof(options) !== 'object' || !options.scopeName) {
	    throw new Error('The `scopeName` option is required.');
	  }

	  var scopeName = options.scopeName;
	  var hasRendered = parts.has(container);
	  var needsScoping = compatibleShadyCSSVersion && container.nodeType === 11
	  /* Node.DOCUMENT_FRAGMENT_NODE */
	  && !!container.host; // Handle first render to a scope specially...

	  var firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName); // On first scope render, render into a fragment; this cannot be a single
	  // fragment that is reused since nested renders can occur synchronously.

	  var renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
	  render(result, renderContainer, Object.assign({
	    templateFactory: shadyTemplateFactory(scopeName)
	  }, options)); // When performing first scope render,
	  // (1) We've rendered into a fragment so that there's a chance to
	  // `prepareTemplateStyles` before sub-elements hit the DOM
	  // (which might cause them to render based on a common pattern of
	  // rendering in a custom element's `connectedCallback`);
	  // (2) Scope the template with ShadyCSS one time only for this scope.
	  // (3) Render the fragment into the container and make sure the
	  // container knows its `part` is the one we just rendered. This ensures
	  // DOM will be re-used on subsequent renders.

	  if (firstScopeRender) {
	    var part = parts.get(renderContainer);
	    parts.delete(renderContainer); // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
	    // that should apply to `renderContainer` even if the rendered value is
	    // not a TemplateInstance. However, it will only insert scoped styles
	    // into the document if `prepareTemplateStyles` has already been called
	    // for the given scope name.

	    var template = part.value instanceof TemplateInstance ? part.value.template : undefined;
	    prepareTemplateStyles(scopeName, renderContainer, template);
	    removeNodes(container, container.firstChild);
	    container.appendChild(renderContainer);
	    parts.set(container, part);
	  } // After elements have hit the DOM, update styling if this is the
	  // initial render to this container.
	  // This is needed whenever dynamic changes are made so it would be
	  // safest to do every render; however, this would regress performance
	  // so we leave it up to the user to call `ShadyCSS.styleElement`
	  // for dynamic changes.


	  if (!hasRendered && needsScoping) {
	    window.ShadyCSS.styleElement(container.host);
	  }
	};

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var _a;
	/**
	 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
	 * replaced at compile time by the munged name for object[property]. We cannot
	 * alias this function, so we have to use a small shim that has the same
	 * behavior when not compiling.
	 */


	window.JSCompiler_renameProperty = function (prop, _obj) {
	  return prop;
	};

	var defaultConverter = {
	  toAttribute: function toAttribute(value, type) {
	    switch (type) {
	      case Boolean:
	        return value ? '' : null;

	      case Object:
	      case Array:
	        // if the value is `null` or `undefined` pass this through
	        // to allow removing/no change behavior.
	        return value == null ? value : JSON.stringify(value);
	    }

	    return value;
	  },
	  fromAttribute: function fromAttribute(value, type) {
	    switch (type) {
	      case Boolean:
	        return value !== null;

	      case Number:
	        return value === null ? null : Number(value);

	      case Object:
	      case Array:
	        return JSON.parse(value);
	    }

	    return value;
	  }
	};
	/**
	 * Change function that returns true if `value` is different from `oldValue`.
	 * This method is used as the default for a property's `hasChanged` function.
	 */

	var notEqual = function notEqual(value, old) {
	  // This ensures (old==NaN, value==NaN) always returns false
	  return old !== value && (old === old || value === value);
	};
	var defaultPropertyDeclaration = {
	  attribute: true,
	  type: String,
	  converter: defaultConverter,
	  reflect: false,
	  hasChanged: notEqual
	};
	var STATE_HAS_UPDATED = 1;
	var STATE_UPDATE_REQUESTED = 1 << 2;
	var STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
	var STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
	/**
	 * The Closure JS Compiler doesn't currently have good support for static
	 * property semantics where "this" is dynamic (e.g.
	 * https://github.com/google/closure-compiler/issues/3177 and others) so we use
	 * this hack to bypass any rewriting by the compiler.
	 */

	var finalized = 'finalized';
	/**
	 * Base element class which manages element properties and attributes. When
	 * properties change, the `update` method is asynchronously called. This method
	 * should be supplied by subclassers to render updates as desired.
	 */

	var UpdatingElement = /*#__PURE__*/function (_HTMLElement) {
	  _inherits(UpdatingElement, _HTMLElement);

	  var _super = _createSuper(UpdatingElement);

	  function UpdatingElement() {
	    var _this;

	    _classCallCheck(this, UpdatingElement);

	    _this = _super.call(this);
	    _this._updateState = 0;
	    _this._instanceProperties = undefined; // Initialize to an unresolved Promise so we can make sure the element has
	    // connected before first update.

	    _this._updatePromise = new Promise(function (res) {
	      return _this._enableUpdatingResolver = res;
	    });
	    /**
	     * Map with keys for any properties that have changed since the last
	     * update cycle with previous values.
	     */

	    _this._changedProperties = new Map();
	    /**
	     * Map with keys of properties that should be reflected when updated.
	     */

	    _this._reflectingProperties = undefined;

	    _this.initialize();

	    return _this;
	  }
	  /**
	   * Returns a list of attributes corresponding to the registered properties.
	   * @nocollapse
	   */


	  _createClass(UpdatingElement, [{
	    key: "initialize",

	    /**
	     * Performs element initialization. By default captures any pre-set values for
	     * registered properties.
	     */
	    value: function initialize() {
	      this._saveInstanceProperties(); // ensures first update will be caught by an early access of
	      // `updateComplete`


	      this._requestUpdate();
	    }
	    /**
	     * Fixes any properties set on the instance before upgrade time.
	     * Otherwise these would shadow the accessor and break these properties.
	     * The properties are stored in a Map which is played back after the
	     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
	     * (<=41), properties created for native platform properties like (`id` or
	     * `name`) may not have default values set in the element constructor. On
	     * these browsers native properties appear on instances and therefore their
	     * default value will overwrite any element default (e.g. if the element sets
	     * this.id = 'id' in the constructor, the 'id' will become '' since this is
	     * the native platform default).
	     */

	  }, {
	    key: "_saveInstanceProperties",
	    value: function _saveInstanceProperties() {
	      var _this2 = this;

	      // Use forEach so this works even if for/of loops are compiled to for loops
	      // expecting arrays
	      this.constructor._classProperties.forEach(function (_v, p) {
	        if (_this2.hasOwnProperty(p)) {
	          var value = _this2[p];
	          delete _this2[p];

	          if (!_this2._instanceProperties) {
	            _this2._instanceProperties = new Map();
	          }

	          _this2._instanceProperties.set(p, value);
	        }
	      });
	    }
	    /**
	     * Applies previously saved instance properties.
	     */

	  }, {
	    key: "_applyInstanceProperties",
	    value: function _applyInstanceProperties() {
	      var _this3 = this;

	      // Use forEach so this works even if for/of loops are compiled to for loops
	      // expecting arrays
	      // tslint:disable-next-line:no-any
	      this._instanceProperties.forEach(function (v, p) {
	        return _this3[p] = v;
	      });

	      this._instanceProperties = undefined;
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      // Ensure first connection completes an update. Updates cannot complete
	      // before connection.
	      this.enableUpdating();
	    }
	  }, {
	    key: "enableUpdating",
	    value: function enableUpdating() {
	      if (this._enableUpdatingResolver !== undefined) {
	        this._enableUpdatingResolver();

	        this._enableUpdatingResolver = undefined;
	      }
	    }
	    /**
	     * Allows for `super.disconnectedCallback()` in extensions while
	     * reserving the possibility of making non-breaking feature additions
	     * when disconnecting at some point in the future.
	     */

	  }, {
	    key: "disconnectedCallback",
	    value: function disconnectedCallback() {}
	    /**
	     * Synchronizes property values when attributes change.
	     */

	  }, {
	    key: "attributeChangedCallback",
	    value: function attributeChangedCallback(name, old, value) {
	      if (old !== value) {
	        this._attributeToProperty(name, value);
	      }
	    }
	  }, {
	    key: "_propertyToAttribute",
	    value: function _propertyToAttribute(name, value) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultPropertyDeclaration;
	      var ctor = this.constructor;

	      var attr = ctor._attributeNameForProperty(name, options);

	      if (attr !== undefined) {
	        var attrValue = ctor._propertyValueToAttribute(value, options); // an undefined value does not change the attribute.


	        if (attrValue === undefined) {
	          return;
	        } // Track if the property is being reflected to avoid
	        // setting the property again via `attributeChangedCallback`. Note:
	        // 1. this takes advantage of the fact that the callback is synchronous.
	        // 2. will behave incorrectly if multiple attributes are in the reaction
	        // stack at time of calling. However, since we process attributes
	        // in `update` this should not be possible (or an extreme corner case
	        // that we'd like to discover).
	        // mark state reflecting


	        this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;

	        if (attrValue == null) {
	          this.removeAttribute(attr);
	        } else {
	          this.setAttribute(attr, attrValue);
	        } // mark state not reflecting


	        this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
	      }
	    }
	  }, {
	    key: "_attributeToProperty",
	    value: function _attributeToProperty(name, value) {
	      // Use tracking info to avoid deserializing attribute value if it was
	      // just set from a property setter.
	      if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
	        return;
	      }

	      var ctor = this.constructor; // Note, hint this as an `AttributeMap` so closure clearly understands
	      // the type; it has issues with tracking types through statics
	      // tslint:disable-next-line:no-unnecessary-type-assertion

	      var propName = ctor._attributeToPropertyMap.get(name);

	      if (propName !== undefined) {
	        var options = ctor.getPropertyOptions(propName); // mark state reflecting

	        this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
	        this[propName] = // tslint:disable-next-line:no-any
	        ctor._propertyValueFromAttribute(value, options); // mark state not reflecting

	        this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
	      }
	    }
	    /**
	     * This private version of `requestUpdate` does not access or return the
	     * `updateComplete` promise. This promise can be overridden and is therefore
	     * not free to access.
	     */

	  }, {
	    key: "_requestUpdate",
	    value: function _requestUpdate(name, oldValue) {
	      var shouldRequestUpdate = true; // If we have a property key, perform property update steps.

	      if (name !== undefined) {
	        var ctor = this.constructor;
	        var options = ctor.getPropertyOptions(name);

	        if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
	          if (!this._changedProperties.has(name)) {
	            this._changedProperties.set(name, oldValue);
	          } // Add to reflecting properties set.
	          // Note, it's important that every change has a chance to add the
	          // property to `_reflectingProperties`. This ensures setting
	          // attribute + property reflects correctly.


	          if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
	            if (this._reflectingProperties === undefined) {
	              this._reflectingProperties = new Map();
	            }

	            this._reflectingProperties.set(name, options);
	          }
	        } else {
	          // Abort the request if the property should not be considered changed.
	          shouldRequestUpdate = false;
	        }
	      }

	      if (!this._hasRequestedUpdate && shouldRequestUpdate) {
	        this._updatePromise = this._enqueueUpdate();
	      }
	    }
	    /**
	     * Requests an update which is processed asynchronously. This should
	     * be called when an element should update based on some state not triggered
	     * by setting a property. In this case, pass no arguments. It should also be
	     * called when manually implementing a property setter. In this case, pass the
	     * property `name` and `oldValue` to ensure that any configured property
	     * options are honored. Returns the `updateComplete` Promise which is resolved
	     * when the update completes.
	     *
	     * @param name {PropertyKey} (optional) name of requesting property
	     * @param oldValue {any} (optional) old value of requesting property
	     * @returns {Promise} A Promise that is resolved when the update completes.
	     */

	  }, {
	    key: "requestUpdate",
	    value: function requestUpdate(name, oldValue) {
	      this._requestUpdate(name, oldValue);

	      return this.updateComplete;
	    }
	    /**
	     * Sets up the element to asynchronously update.
	     */

	  }, {
	    key: "_enqueueUpdate",
	    value: function () {
	      var _enqueueUpdate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var result;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
	                _context.prev = 1;
	                _context.next = 4;
	                return this._updatePromise;

	              case 4:
	                _context.next = 8;
	                break;

	              case 6:
	                _context.prev = 6;
	                _context.t0 = _context["catch"](1);

	              case 8:
	                result = this.performUpdate(); // If `performUpdate` returns a Promise, we await it. This is done to
	                // enable coordinating updates with a scheduler. Note, the result is
	                // checked to avoid delaying an additional microtask unless we need to.

	                if (!(result != null)) {
	                  _context.next = 12;
	                  break;
	                }

	                _context.next = 12;
	                return result;

	              case 12:
	                return _context.abrupt("return", !this._hasRequestedUpdate);

	              case 13:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[1, 6]]);
	      }));

	      function _enqueueUpdate() {
	        return _enqueueUpdate2.apply(this, arguments);
	      }

	      return _enqueueUpdate;
	    }()
	  }, {
	    key: "performUpdate",

	    /**
	     * Performs an element update. Note, if an exception is thrown during the
	     * update, `firstUpdated` and `updated` will not be called.
	     *
	     * You can override this method to change the timing of updates. If this
	     * method is overridden, `super.performUpdate()` must be called.
	     *
	     * For instance, to schedule updates to occur just before the next frame:
	     *
	     * ```
	     * protected async performUpdate(): Promise<unknown> {
	     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
	     *   super.performUpdate();
	     * }
	     * ```
	     */
	    value: function performUpdate() {
	      // Mixin instance properties once, if they exist.
	      if (this._instanceProperties) {
	        this._applyInstanceProperties();
	      }

	      var shouldUpdate = false;
	      var changedProperties = this._changedProperties;

	      try {
	        shouldUpdate = this.shouldUpdate(changedProperties);

	        if (shouldUpdate) {
	          this.update(changedProperties);
	        } else {
	          this._markUpdated();
	        }
	      } catch (e) {
	        // Prevent `firstUpdated` and `updated` from running when there's an
	        // update exception.
	        shouldUpdate = false; // Ensure element can accept additional updates after an exception.

	        this._markUpdated();

	        throw e;
	      }

	      if (shouldUpdate) {
	        if (!(this._updateState & STATE_HAS_UPDATED)) {
	          this._updateState = this._updateState | STATE_HAS_UPDATED;
	          this.firstUpdated(changedProperties);
	        }

	        this.updated(changedProperties);
	      }
	    }
	  }, {
	    key: "_markUpdated",
	    value: function _markUpdated() {
	      this._changedProperties = new Map();
	      this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
	    }
	    /**
	     * Returns a Promise that resolves when the element has completed updating.
	     * The Promise value is a boolean that is `true` if the element completed the
	     * update without triggering another update. The Promise result is `false` if
	     * a property was set inside `updated()`. If the Promise is rejected, an
	     * exception was thrown during the update.
	     *
	     * To await additional asynchronous work, override the `_getUpdateComplete`
	     * method. For example, it is sometimes useful to await a rendered element
	     * before fulfilling this Promise. To do this, first await
	     * `super._getUpdateComplete()`, then any subsequent state.
	     *
	     * @returns {Promise} The Promise returns a boolean that indicates if the
	     * update resolved without triggering another update.
	     */

	  }, {
	    key: "_getUpdateComplete",

	    /**
	     * Override point for the `updateComplete` promise.
	     *
	     * It is not safe to override the `updateComplete` getter directly due to a
	     * limitation in TypeScript which means it is not possible to call a
	     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
	     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
	     * This method should be overridden instead. For example:
	     *
	     *   class MyElement extends LitElement {
	     *     async _getUpdateComplete() {
	     *       await super._getUpdateComplete();
	     *       await this._myChild.updateComplete;
	     *     }
	     *   }
	     */
	    value: function _getUpdateComplete() {
	      return this._updatePromise;
	    }
	    /**
	     * Controls whether or not `update` should be called when the element requests
	     * an update. By default, this method always returns `true`, but this can be
	     * customized to control when to update.
	     *
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "shouldUpdate",
	    value: function shouldUpdate(_changedProperties) {
	      return true;
	    }
	    /**
	     * Updates the element. This method reflects property values to attributes.
	     * It can be overridden to render and keep updated element DOM.
	     * Setting properties inside this method will *not* trigger
	     * another update.
	     *
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "update",
	    value: function update(_changedProperties) {
	      var _this4 = this;

	      if (this._reflectingProperties !== undefined && this._reflectingProperties.size > 0) {
	        // Use forEach so this works even if for/of loops are compiled to for
	        // loops expecting arrays
	        this._reflectingProperties.forEach(function (v, k) {
	          return _this4._propertyToAttribute(k, _this4[k], v);
	        });

	        this._reflectingProperties = undefined;
	      }

	      this._markUpdated();
	    }
	    /**
	     * Invoked whenever the element is updated. Implement to perform
	     * post-updating tasks via DOM APIs, for example, focusing an element.
	     *
	     * Setting properties inside this method will trigger the element to update
	     * again after this update cycle completes.
	     *
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "updated",
	    value: function updated(_changedProperties) {}
	    /**
	     * Invoked when the element is first updated. Implement to perform one time
	     * work on the element after update.
	     *
	     * Setting properties inside this method will trigger the element to update
	     * again after this update cycle completes.
	     *
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "firstUpdated",
	    value: function firstUpdated(_changedProperties) {}
	  }, {
	    key: "_hasRequestedUpdate",
	    get: function get() {
	      return this._updateState & STATE_UPDATE_REQUESTED;
	    }
	  }, {
	    key: "hasUpdated",
	    get: function get() {
	      return this._updateState & STATE_HAS_UPDATED;
	    }
	  }, {
	    key: "updateComplete",
	    get: function get() {
	      return this._getUpdateComplete();
	    }
	  }], [{
	    key: "_ensureClassProperties",

	    /**
	     * Ensures the private `_classProperties` property metadata is created.
	     * In addition to `finalize` this is also called in `createProperty` to
	     * ensure the `@property` decorator can add property metadata.
	     */

	    /** @nocollapse */
	    value: function _ensureClassProperties() {
	      var _this5 = this;

	      // ensure private storage for property declarations.
	      if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
	        this._classProperties = new Map(); // NOTE: Workaround IE11 not supporting Map constructor argument.

	        var superProperties = Object.getPrototypeOf(this)._classProperties;

	        if (superProperties !== undefined) {
	          superProperties.forEach(function (v, k) {
	            return _this5._classProperties.set(k, v);
	          });
	        }
	      }
	    }
	    /**
	     * Creates a property accessor on the element prototype if one does not exist
	     * and stores a PropertyDeclaration for the property with the given options.
	     * The property setter calls the property's `hasChanged` property option
	     * or uses a strict identity check to determine whether or not to request
	     * an update.
	     *
	     * This method may be overridden to customize properties; however,
	     * when doing so, it's important to call `super.createProperty` to ensure
	     * the property is setup correctly. This method calls
	     * `getPropertyDescriptor` internally to get a descriptor to install.
	     * To customize what properties do when they are get or set, override
	     * `getPropertyDescriptor`. To customize the options for a property,
	     * implement `createProperty` like this:
	     *
	     * static createProperty(name, options) {
	     *   options = Object.assign(options, {myOption: true});
	     *   super.createProperty(name, options);
	     * }
	     *
	     * @nocollapse
	     */

	  }, {
	    key: "createProperty",
	    value: function createProperty(name) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultPropertyDeclaration;

	      // Note, since this can be called by the `@property` decorator which
	      // is called before `finalize`, we ensure storage exists for property
	      // metadata.
	      this._ensureClassProperties();

	      this._classProperties.set(name, options); // Do not generate an accessor if the prototype already has one, since
	      // it would be lost otherwise and that would never be the user's intention;
	      // Instead, we expect users to call `requestUpdate` themselves from
	      // user-defined accessors. Note that if the super has an accessor we will
	      // still overwrite it


	      if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
	        return;
	      }

	      var key = _typeof(name) === 'symbol' ? Symbol() : "__".concat(name);
	      var descriptor = this.getPropertyDescriptor(name, key, options);

	      if (descriptor !== undefined) {
	        Object.defineProperty(this.prototype, name, descriptor);
	      }
	    }
	    /**
	     * Returns a property descriptor to be defined on the given named property.
	     * If no descriptor is returned, the property will not become an accessor.
	     * For example,
	     *
	     *   class MyElement extends LitElement {
	     *     static getPropertyDescriptor(name, key, options) {
	     *       const defaultDescriptor =
	     *           super.getPropertyDescriptor(name, key, options);
	     *       const setter = defaultDescriptor.set;
	     *       return {
	     *         get: defaultDescriptor.get,
	     *         set(value) {
	     *           setter.call(this, value);
	     *           // custom action.
	     *         },
	     *         configurable: true,
	     *         enumerable: true
	     *       }
	     *     }
	     *   }
	     *
	     * @nocollapse
	     */

	  }, {
	    key: "getPropertyDescriptor",
	    value: function getPropertyDescriptor(name, key, _options) {
	      return {
	        // tslint:disable-next-line:no-any no symbol in index
	        get: function get() {
	          return this[key];
	        },
	        set: function set(value) {
	          var oldValue = this[name];
	          this[key] = value;

	          this._requestUpdate(name, oldValue);
	        },
	        configurable: true,
	        enumerable: true
	      };
	    }
	    /**
	     * Returns the property options associated with the given property.
	     * These options are defined with a PropertyDeclaration via the `properties`
	     * object or the `@property` decorator and are registered in
	     * `createProperty(...)`.
	     *
	     * Note, this method should be considered "final" and not overridden. To
	     * customize the options for a given property, override `createProperty`.
	     *
	     * @nocollapse
	     * @final
	     */

	  }, {
	    key: "getPropertyOptions",
	    value: function getPropertyOptions(name) {
	      return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
	    }
	    /**
	     * Creates property accessors for registered properties and ensures
	     * any superclasses are also finalized.
	     * @nocollapse
	     */

	  }, {
	    key: "finalize",
	    value: function finalize() {
	      // finalize any superclasses
	      var superCtor = Object.getPrototypeOf(this);

	      if (!superCtor.hasOwnProperty(finalized)) {
	        superCtor.finalize();
	      }

	      this[finalized] = true;

	      this._ensureClassProperties(); // initialize Map populated in observedAttributes


	      this._attributeToPropertyMap = new Map(); // make any properties
	      // Note, only process "own" properties since this element will inherit
	      // any properties defined on the superClass, and finalization ensures
	      // the entire prototype chain is finalized.

	      if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
	        var props = this.properties; // support symbols in properties (IE11 does not support this)

	        var propKeys = [].concat(_toConsumableArray(Object.getOwnPropertyNames(props)), _toConsumableArray(typeof Object.getOwnPropertySymbols === 'function' ? Object.getOwnPropertySymbols(props) : [])); // This for/of is ok because propKeys is an array

	        var _iterator = _createForOfIteratorHelper(propKeys),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var p = _step.value;
	            // note, use of `any` is due to TypeSript lack of support for symbol in
	            // index types
	            // tslint:disable-next-line:no-any no symbol in index
	            this.createProperty(p, props[p]);
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	      }
	    }
	    /**
	     * Returns the property name for the given attribute `name`.
	     * @nocollapse
	     */

	  }, {
	    key: "_attributeNameForProperty",
	    value: function _attributeNameForProperty(name, options) {
	      var attribute = options.attribute;
	      return attribute === false ? undefined : typeof attribute === 'string' ? attribute : typeof name === 'string' ? name.toLowerCase() : undefined;
	    }
	    /**
	     * Returns true if a property should request an update.
	     * Called when a property value is set and uses the `hasChanged`
	     * option for the property if present or a strict identity check.
	     * @nocollapse
	     */

	  }, {
	    key: "_valueHasChanged",
	    value: function _valueHasChanged(value, old) {
	      var hasChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : notEqual;
	      return hasChanged(value, old);
	    }
	    /**
	     * Returns the property value for the given attribute value.
	     * Called via the `attributeChangedCallback` and uses the property's
	     * `converter` or `converter.fromAttribute` property option.
	     * @nocollapse
	     */

	  }, {
	    key: "_propertyValueFromAttribute",
	    value: function _propertyValueFromAttribute(value, options) {
	      var type = options.type;
	      var converter = options.converter || defaultConverter;
	      var fromAttribute = typeof converter === 'function' ? converter : converter.fromAttribute;
	      return fromAttribute ? fromAttribute(value, type) : value;
	    }
	    /**
	     * Returns the attribute value for the given property value. If this
	     * returns undefined, the property will *not* be reflected to an attribute.
	     * If this returns null, the attribute will be removed, otherwise the
	     * attribute will be set to the value.
	     * This uses the property's `reflect` and `type.toAttribute` property options.
	     * @nocollapse
	     */

	  }, {
	    key: "_propertyValueToAttribute",
	    value: function _propertyValueToAttribute(value, options) {
	      if (options.reflect === undefined) {
	        return;
	      }

	      var type = options.type;
	      var converter = options.converter;
	      var toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
	      return toAttribute(value, type);
	    }
	  }, {
	    key: "observedAttributes",
	    get: function get() {
	      var _this6 = this;

	      // note: piggy backing on this to ensure we're finalized.
	      this.finalize();
	      var attributes = []; // Use forEach so this works even if for/of loops are compiled to for loops
	      // expecting arrays

	      this._classProperties.forEach(function (v, p) {
	        var attr = _this6._attributeNameForProperty(p, v);

	        if (attr !== undefined) {
	          _this6._attributeToPropertyMap.set(attr, p);

	          attributes.push(attr);
	        }
	      });

	      return attributes;
	    }
	  }]);

	  return UpdatingElement;
	}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
	_a = finalized;
	/**
	 * Marks class as having finished creating properties.
	 */

	UpdatingElement[_a] = true;

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var legacyCustomElement = function legacyCustomElement(tagName, clazz) {
	  window.customElements.define(tagName, clazz); // Cast as any because TS doesn't recognize the return type as being a
	  // subtype of the decorated class when clazz is typed as
	  // `Constructor<HTMLElement>` for some reason.
	  // `Constructor<HTMLElement>` is helpful to make sure the decorator is
	  // applied to elements however.
	  // tslint:disable-next-line:no-any

	  return clazz;
	};

	var standardCustomElement = function standardCustomElement(tagName, descriptor) {
	  var kind = descriptor.kind,
	      elements = descriptor.elements;
	  return {
	    kind: kind,
	    elements: elements,
	    // This callback is called once the class is otherwise fully defined
	    finisher: function finisher(clazz) {
	      window.customElements.define(tagName, clazz);
	    }
	  };
	};
	/**
	 * Class decorator factory that defines the decorated class as a custom element.
	 *
	 * ```
	 * @customElement('my-element')
	 * class MyElement {
	 *   render() {
	 *     return html``;
	 *   }
	 * }
	 * ```
	 *
	 * @param tagName The name of the custom element to define.
	 */


	var customElement = function customElement(tagName) {
	  return function (classOrDescriptor) {
	    return typeof classOrDescriptor === 'function' ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
	  };
	};

	var standardProperty = function standardProperty(options, element) {
	  // When decorating an accessor, pass it through and add property metadata.
	  // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
	  // stomp over the user's accessor.
	  if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
	    return Object.assign(Object.assign({}, element), {
	      finisher: function finisher(clazz) {
	        clazz.createProperty(element.key, options);
	      }
	    });
	  } else {
	    // createProperty() takes care of defining the property, but we still
	    // must return some kind of descriptor, so return a descriptor for an
	    // unused prototype field. The finisher calls createProperty().
	    return {
	      kind: 'field',
	      key: Symbol(),
	      placement: 'own',
	      descriptor: {},
	      // When @babel/plugin-proposal-decorators implements initializers,
	      // do this instead of the initializer below. See:
	      // https://github.com/babel/babel/issues/9260 extras: [
	      //   {
	      //     kind: 'initializer',
	      //     placement: 'own',
	      //     initializer: descriptor.initializer,
	      //   }
	      // ],
	      initializer: function initializer() {
	        if (typeof element.initializer === 'function') {
	          this[element.key] = element.initializer.call(this);
	        }
	      },
	      finisher: function finisher(clazz) {
	        clazz.createProperty(element.key, options);
	      }
	    };
	  }
	};

	var legacyProperty = function legacyProperty(options, proto, name) {
	  proto.constructor.createProperty(name, options);
	};
	/**
	 * A property decorator which creates a LitElement property which reflects a
	 * corresponding attribute value. A `PropertyDeclaration` may optionally be
	 * supplied to configure property features.
	 *
	 * This decorator should only be used for public fields. Private or protected
	 * fields should use the internalProperty decorator.
	 *
	 * @example
	 *
	 *     class MyElement {
	 *       @property({ type: Boolean })
	 *       clicked = false;
	 *     }
	 *
	 * @ExportDecoratedItems
	 */


	function property(options) {
	  // tslint:disable-next-line:no-any decorator
	  return function (protoOrDescriptor, name) {
	    return name !== undefined ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
	  };
	}

	/**
	@license
	Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
	This code may only be used under the BSD style license found at
	http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
	http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
	found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
	part of the polymer project is also subject to an additional IP rights grant
	found at http://polymer.github.io/PATENTS.txt
	*/
	var supportsAdoptingStyleSheets = 'adoptedStyleSheets' in Document.prototype && 'replace' in CSSStyleSheet.prototype;
	var constructionToken = Symbol();
	var CSSResult = /*#__PURE__*/function () {
	  function CSSResult(cssText, safeToken) {
	    _classCallCheck(this, CSSResult);

	    if (safeToken !== constructionToken) {
	      throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
	    }

	    this.cssText = cssText;
	  } // Note, this is a getter so that it's lazy. In practice, this means
	  // stylesheets are not created until the first element instance is made.


	  _createClass(CSSResult, [{
	    key: "toString",
	    value: function toString() {
	      return this.cssText;
	    }
	  }, {
	    key: "styleSheet",
	    get: function get() {
	      if (this._styleSheet === undefined) {
	        // Note, if `adoptedStyleSheets` is supported then we assume CSSStyleSheet
	        // is constructable.
	        if (supportsAdoptingStyleSheets) {
	          this._styleSheet = new CSSStyleSheet();

	          this._styleSheet.replaceSync(this.cssText);
	        } else {
	          this._styleSheet = null;
	        }
	      }

	      return this._styleSheet;
	    }
	  }]);

	  return CSSResult;
	}();
	/**
	 * Wrap a value for interpolation in a css tagged template literal.
	 *
	 * This is unsafe because untrusted CSS text can be used to phone home
	 * or exfiltrate data to an attacker controlled site. Take care to only use
	 * this with trusted input.
	 */

	var unsafeCSS = function unsafeCSS(value) {
	  return new CSSResult(String(value), constructionToken);
	};

	var textFromCSSResult = function textFromCSSResult(value) {
	  if (value instanceof CSSResult) {
	    return value.cssText;
	  } else if (typeof value === 'number') {
	    return value;
	  } else {
	    throw new Error("Value passed to 'css' function must be a 'css' function result: ".concat(value, ". Use 'unsafeCSS' to pass non-literal values, but\n            take care to ensure page security."));
	  }
	};
	/**
	 * Template tag which which can be used with LitElement's `style` property to
	 * set element styles. For security reasons, only literal string values may be
	 * used. To incorporate non-literal values `unsafeCSS` may be used inside a
	 * template string part.
	 */


	var css = function css(strings) {
	  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    values[_key - 1] = arguments[_key];
	  }

	  var cssText = values.reduce(function (acc, v, idx) {
	    return acc + textFromCSSResult(v) + strings[idx + 1];
	  }, strings[0]);
	  return new CSSResult(cssText, constructionToken);
	};

	// This line will be used in regexes to search for LitElement usage.
	// TODO(justinfagnani): inject version number at build time

	(window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.3.1');
	/**
	 * Sentinal value used to avoid calling lit-html's render function when
	 * subclasses do not implement `render`
	 */

	var renderNotImplemented = {};
	var LitElement = /*#__PURE__*/function (_UpdatingElement) {
	  _inherits(LitElement, _UpdatingElement);

	  var _super = _createSuper(LitElement);

	  function LitElement() {
	    _classCallCheck(this, LitElement);

	    return _super.apply(this, arguments);
	  }

	  _createClass(LitElement, [{
	    key: "initialize",

	    /**
	     * Performs element initialization. By default this calls `createRenderRoot`
	     * to create the element `renderRoot` node and captures any pre-set values for
	     * registered properties.
	     */
	    value: function initialize() {
	      _get(_getPrototypeOf(LitElement.prototype), "initialize", this).call(this);

	      this.constructor._getUniqueStyles();

	      this.renderRoot = this.createRenderRoot(); // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
	      // element's getRootNode(). While this could be done, we're choosing not to
	      // support this now since it would require different logic around de-duping.

	      if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
	        this.adoptStyles();
	      }
	    }
	    /**
	     * Returns the node into which the element should render and by default
	     * creates and returns an open shadowRoot. Implement to customize where the
	     * element's DOM is rendered. For example, to render into the element's
	     * childNodes, return `this`.
	     * @returns {Element|DocumentFragment} Returns a node into which to render.
	     */

	  }, {
	    key: "createRenderRoot",
	    value: function createRenderRoot() {
	      return this.attachShadow({
	        mode: 'open'
	      });
	    }
	    /**
	     * Applies styling to the element shadowRoot using the `static get styles`
	     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
	     * available and will fallback otherwise. When Shadow DOM is polyfilled,
	     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
	     * is available but `adoptedStyleSheets` is not, styles are appended to the
	     * end of the `shadowRoot` to [mimic spec
	     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
	     */

	  }, {
	    key: "adoptStyles",
	    value: function adoptStyles() {
	      var styles = this.constructor._styles;

	      if (styles.length === 0) {
	        return;
	      } // There are three separate cases here based on Shadow DOM support.
	      // (1) shadowRoot polyfilled: use ShadyCSS
	      // (2) shadowRoot.adoptedStyleSheets available: use it.
	      // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
	      // rendering


	      if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
	        window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map(function (s) {
	          return s.cssText;
	        }), this.localName);
	      } else if (supportsAdoptingStyleSheets) {
	        this.renderRoot.adoptedStyleSheets = styles.map(function (s) {
	          return s.styleSheet;
	        });
	      } else {
	        // This must be done after rendering so the actual style insertion is done
	        // in `update`.
	        this._needsShimAdoptedStyleSheets = true;
	      }
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(LitElement.prototype), "connectedCallback", this).call(this); // Note, first update/render handles styleElement so we only call this if
	      // connected after first update.


	      if (this.hasUpdated && window.ShadyCSS !== undefined) {
	        window.ShadyCSS.styleElement(this);
	      }
	    }
	    /**
	     * Updates the element. This method reflects property values to attributes
	     * and calls `render` to render DOM via lit-html. Setting properties inside
	     * this method will *not* trigger another update.
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "update",
	    value: function update(changedProperties) {
	      var _this = this;

	      // Setting properties in `render` should not trigger an update. Since
	      // updates are allowed after super.update, it's important to call `render`
	      // before that.
	      var templateResult = this.render();

	      _get(_getPrototypeOf(LitElement.prototype), "update", this).call(this, changedProperties); // If render is not implemented by the component, don't call lit-html render


	      if (templateResult !== renderNotImplemented) {
	        this.constructor.render(templateResult, this.renderRoot, {
	          scopeName: this.localName,
	          eventContext: this
	        });
	      } // When native Shadow DOM is used but adoptedStyles are not supported,
	      // insert styling after rendering to ensure adoptedStyles have highest
	      // priority.


	      if (this._needsShimAdoptedStyleSheets) {
	        this._needsShimAdoptedStyleSheets = false;

	        this.constructor._styles.forEach(function (s) {
	          var style = document.createElement('style');
	          style.textContent = s.cssText;

	          _this.renderRoot.appendChild(style);
	        });
	      }
	    }
	    /**
	     * Invoked on each update to perform rendering tasks. This method may return
	     * any value renderable by lit-html's NodePart - typically a TemplateResult.
	     * Setting properties inside this method will *not* trigger the element to
	     * update.
	     */

	  }, {
	    key: "render",
	    value: function render() {
	      return renderNotImplemented;
	    }
	  }], [{
	    key: "getStyles",

	    /**
	     * Return the array of styles to apply to the element.
	     * Override this method to integrate into a style management system.
	     *
	     * @nocollapse
	     */
	    value: function getStyles() {
	      return this.styles;
	    }
	    /** @nocollapse */

	  }, {
	    key: "_getUniqueStyles",
	    value: function _getUniqueStyles() {
	      // Only gather styles once per class
	      if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
	        return;
	      } // Take care not to call `this.getStyles()` multiple times since this
	      // generates new CSSResults each time.
	      // TODO(sorvell): Since we do not cache CSSResults by input, any
	      // shared styles will generate new stylesheet objects, which is wasteful.
	      // This should be addressed when a browser ships constructable
	      // stylesheets.


	      var userStyles = this.getStyles();

	      if (userStyles === undefined) {
	        this._styles = [];
	      } else if (Array.isArray(userStyles)) {
	        // De-duplicate styles preserving the _last_ instance in the set.
	        // This is a performance optimization to avoid duplicated styles that can
	        // occur especially when composing via subclassing.
	        // The last item is kept to try to preserve the cascade order with the
	        // assumption that it's most important that last added styles override
	        // previous styles.
	        var addStyles = function addStyles(styles, set) {
	          return styles.reduceRight(function (set, s) {
	            return (// Note: On IE set.add() does not return the set
	              Array.isArray(s) ? addStyles(s, set) : (set.add(s), set)
	            );
	          }, set);
	        }; // Array.from does not work on Set in IE, otherwise return
	        // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()


	        var set = addStyles(userStyles, new Set());
	        var styles = [];
	        set.forEach(function (v) {
	          return styles.unshift(v);
	        });
	        this._styles = styles;
	      } else {
	        this._styles = [userStyles];
	      }
	    }
	  }]);

	  return LitElement;
	}(UpdatingElement);
	/**
	 * Ensure this class is marked as `finalized` as an optimization ensuring
	 * it will not needlessly try to `finalize`.
	 *
	 * Note this property name is a string to prevent breaking Closure JS Compiler
	 * optimizations. See updating-element.ts for more information.
	 */

	LitElement['finalized'] = true;
	/**
	 * Render method used to render the value to the element's DOM.
	 * @param result The value to render.
	 * @param container Node into which to render.
	 * @param options Element name.
	 * @nocollapse
	 */

	LitElement.render = render$1;

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */
	function supportsCSSVariables() {
	  return window.CSS && CSS.supports('color', 'var(--fake-var)');
	}

	var CSSReader = function CSSReader(element) {
	  _classCallCheck(this, CSSReader);

	  this.mElement = element;
	};

	var CSSReaderModern = /*#__PURE__*/function (_CSSReader) {
	  _inherits(CSSReaderModern, _CSSReader);

	  var _super = _createSuper(CSSReaderModern);

	  function CSSReaderModern(element) {
	    var _this;

	    _classCallCheck(this, CSSReaderModern);

	    _this = _super.call(this, element);
	    _this.mStyle = getComputedStyle(_this.mElement);
	    _this.mObserver = new MutationObserver(function () {
	      return _this.handleObserverEvent();
	    });

	    _this.mObserver.observe(_this.mElement, {
	      attributes: true,
	      attributeFilter: ['style', 'class']
	    });

	    return _this;
	  }

	  _createClass(CSSReaderModern, [{
	    key: "option",
	    value: function option(name, value) {
	      var result = this.mStyle.getPropertyValue("--".concat(name));

	      if (result.length) {
	        return result;
	      }

	      return value;
	    }
	  }, {
	    key: "handleObserverEvent",
	    value: function handleObserverEvent() {
	      this.mStyle = getComputedStyle(this.mElement);
	    }
	  }]);

	  return CSSReaderModern;
	}(CSSReader);

	var CSSReaderLegacy = /*#__PURE__*/function (_CSSReader2) {
	  _inherits(CSSReaderLegacy, _CSSReader2);

	  var _super2 = _createSuper(CSSReaderLegacy);

	  function CSSReaderLegacy(element) {
	    _classCallCheck(this, CSSReaderLegacy);

	    return _super2.call(this, element);
	  }

	  _createClass(CSSReaderLegacy, [{
	    key: "option",
	    value: function option(name, value) {
	      return this._readOptionRecursive(this.mElement, name, value);
	    }
	  }, {
	    key: "_readOptionRecursive",
	    value: function _readOptionRecursive(element, name, value) {
	      if (element.currentStyle.hasOwnProperty("-lgcy-".concat(name))) {
	        return element.currentStyle["-lgcy-".concat(name)];
	      }

	      if (element === document.body) {
	        return value;
	      }

	      var parent = element.parentElement || element.__shady_native_parentElement;

	      if (!parent) {
	        return value;
	      }

	      return this._readOptionRecursive(parent, name, value);
	    }
	  }]);

	  return CSSReaderLegacy;
	}(CSSReader);

	var CSSOptions = /*#__PURE__*/function () {
	  function CSSOptions(element) {
	    _classCallCheck(this, CSSOptions);

	    this.mReader = CSSOptions._supportsCSSVars ? new CSSReaderModern(element) : new CSSReaderLegacy(element);
	  }

	  _createClass(CSSOptions, [{
	    key: "read",
	    value: function read(name, value) {
	      return this.mReader.option(name, value);
	    }
	  }, {
	    key: "supportsCSSVars",
	    get: function get() {
	      return CSSOptions._supportsCSSVars;
	    }
	  }], [{
	    key: "supportsCSSVars",
	    get: function get() {
	      return this._supportsCSSVars;
	    }
	  }]);

	  return CSSOptions;
	}();

	CSSOptions._supportsCSSVars = supportsCSSVariables();

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetPlugin_1;

	var FacetPlugin = FacetPlugin_1 = /*#__PURE__*/function (_LitElement) {
	  _inherits(FacetPlugin, _LitElement);

	  var _super = _createSuper(FacetPlugin);

	  function FacetPlugin() {
	    var _this;

	    _classCallCheck(this, FacetPlugin);

	    _this = _super.apply(this, arguments);
	    _this._boundUpdateHandler = _this._updateHandler.bind(_assertThisInitialized(_this));
	    _this._host = null;
	    return _this;
	  }

	  _createClass(FacetPlugin, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this2 = this;

	      _get(_getPrototypeOf(FacetPlugin.prototype), "connectedCallback", this).call(this);

	      var parent = this.parentElement;

	      if (parent) {
	        // stupid IE11...
	        var dispatchEvent = function dispatchEvent() {
	          parent.dispatchEvent(new CustomEvent(FacetPlugin_1.connectedEvent, {
	            bubbles: true,
	            detail: {
	              plugin: _this2
	            }
	          }));
	        };

	        if (window.ShadyDOM && window.ShadyDOM.inUse) {
	          requestAnimationFrame(dispatchEvent);
	        } else {
	          dispatchEvent();
	        }
	      }
	    }
	  }, {
	    key: "disconnectedCallback",
	    value: function disconnectedCallback() {
	      _get(_getPrototypeOf(FacetPlugin.prototype), "disconnectedCallback", this).call(this);

	      if (this.host) {
	        this.host.dispatchEvent(new CustomEvent(FacetPlugin_1.disconnectedEvent, {
	          bubbles: true,
	          detail: {
	            plugin: this
	          }
	        }));
	      }
	    }
	  }, {
	    key: "hostUpdated",
	    value: function hostUpdated(changedProperties) {// OVERRIDE
	    }
	  }, {
	    key: "hostChanged",
	    value: function hostChanged(host) {// OVERRIDE
	    }
	  }, {
	    key: "_updateHandler",
	    value: function _updateHandler(event) {
	      if (event.target === this._host && event instanceof CustomEvent) {
	        this.hostUpdated(event.detail.changedProperties);
	      }
	    }
	  }, {
	    key: "host",
	    get: function get() {
	      return this._host;
	    },
	    set: function set(value) {
	      if (value !== this._host) {
	        if (this._host) {
	          this._host.removeEventListener('facet-element-updated', this._boundUpdateHandler);
	        }

	        this._host = value;

	        if (this._host) {
	          this._host.addEventListener('facet-element-updated', this._boundUpdateHandler);

	          this._host.requestUpdate();
	        }

	        this.hostChanged(this._host);
	        this.requestUpdate();
	      }
	    }
	  }]);

	  return FacetPlugin;
	}(LitElement);

	FacetPlugin.connectedEvent = 'facet-plugin-connected';
	FacetPlugin.disconnectedEvent = 'facet-plugin-disconnected';
	FacetPlugin = FacetPlugin_1 = __decorate([customElement('facet-plugin')], FacetPlugin);

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */
	var MutationWrapper = /*#__PURE__*/function () {
	  function MutationWrapper(target) {
	    var _this = this;

	    var autoStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	    _classCallCheck(this, MutationWrapper);

	    this.nodesAdded = null;
	    this.nodesRemoved = null;
	    this._observer = new MutationObserver(function (records) {
	      for (var i = 0, n = records.length; i < n; ++i) {
	        if (records[i].type === 'childList') {
	          if (_this.nodesAdded) {
	            _this.nodesAdded(records[i].addedNodes);
	          }

	          if (_this.nodesRemoved) {
	            _this.nodesRemoved(records[i].removedNodes);
	          }
	        }
	      }
	    });
	    this._target = target;
	    this._config = {
	      attributes: false,
	      childList: true,
	      subtree: false
	    };

	    if (autoStart) {
	      this._observer.observe(this._target, this._config);
	    }
	  }

	  _createClass(MutationWrapper, [{
	    key: "start",
	    value: function start() {
	      this._observer.observe(this._target, this._config);
	    }
	  }, {
	    key: "stop",
	    value: function stop() {
	      this._observer.disconnect();
	    }
	  }]);

	  return MutationWrapper;
	}();

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetTemplate_1;
	var kSlotsKey = Symbol('FacetTemplate::Slots');
	var kDataKey = Symbol('FacetTemplate::Data');

	var FacetTemplate = FacetTemplate_1 = /*#__PURE__*/function (_LitElement) {
	  _inherits(FacetTemplate, _LitElement);

	  var _super = _createSuper(FacetTemplate);

	  function FacetTemplate() {
	    var _this;

	    _classCallCheck(this, FacetTemplate);

	    _this = _super.call(this);
	    _this.target = '';
	    _this._escapeRegex = new RegExp('\\${(.*?)}', 'gm');
	    _this._host = null;
	    _this.slots = [];
	    _this.templateAttributes = new Map();
	    _this.xlinkAttributes = new Map();
	    _this.customAttributesNames = new Map();
	    _this.customAttributesKeys = new Map();
	    _this.tagComponents = {
	      strings: [],
	      values: []
	    };
	    _this.mutationObserver = new MutationWrapper(_assertThisInitialized(_this), false);
	    _this.mutationObserver.nodesAdded = _this._processAddedNodes.bind(_assertThisInitialized(_this));
	    _this.xlinkDirective = directive(function (value) {
	      return function (part) {
	        part.committer.element.setAttributeNS('http://www.w3.org/1999/xlink', part.committer.name, value);
	      };
	    });
	    return _this;
	  }

	  _createClass(FacetTemplate, [{
	    key: "getHTML",
	    value: function getHTML(data) {
	      var customAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return this._getHTML(data, this.tagComponents, customAttributes);
	    }
	  }, {
	    key: "addCustomAttribute",
	    value: function addCustomAttribute(name) {
	      if (!this.customAttributesNames.has(name)) {
	        var key = Symbol("FacetTemplate::CustomAttribute::".concat(this.target, "::").concat(name));
	        this.customAttributesNames.set(name, key);
	        this.customAttributesKeys.set(key, name);
	        this.tagComponents = {
	          strings: [],
	          values: []
	        };

	        this._initializeTemplateTag();
	      }
	    }
	  }, {
	    key: "deleteCustomAttribute",
	    value: function deleteCustomAttribute(name) {
	      if (this.customAttributesNames.has(name)) {
	        this.customAttributesKeys.delete(this.customAttributesNames.get(name));
	        this.customAttributesNames.delete(name);
	        this.tagComponents = {
	          strings: [],
	          values: []
	        };

	        this._initializeTemplateTag();
	      }
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this2 = this;

	      _get(_getPrototypeOf(FacetTemplate.prototype), "connectedCallback", this).call(this);

	      this._initializeTemplateTag();

	      this.mutationObserver.start();

	      this._processAddedNodes(this.childNodes);

	      var parent = this.parentElement;

	      if (parent) {
	        // stupid IE11...
	        var dispatchEvent = function dispatchEvent() {
	          parent.dispatchEvent(new CustomEvent(FacetTemplate_1.connectedEvent, {
	            bubbles: true,
	            detail: {
	              template: _this2
	            }
	          }));
	        };

	        if (window.ShadyDOM && window.ShadyDOM.inUse) {
	          requestAnimationFrame(dispatchEvent);
	        } else {
	          dispatchEvent();
	        }
	      }
	    }
	  }, {
	    key: "disconnectedCallback",
	    value: function disconnectedCallback() {
	      _get(_getPrototypeOf(FacetTemplate.prototype), "disconnectedCallback", this).call(this);

	      this.mutationObserver.stop();
	      this.slots.length = 0;

	      if (this.host) {
	        this.host.dispatchEvent(new CustomEvent(FacetTemplate_1.disconnectedEvent, {
	          bubbles: true,
	          detail: {
	            plugin: this
	          }
	        }));
	      }
	    }
	  }, {
	    key: "createRenderRoot",
	    value: function createRenderRoot() {
	      return this;
	    }
	  }, {
	    key: "_initializeTemplateTag",
	    value: function _initializeTemplateTag() {
	      var _this3 = this;

	      var attributes = this.attributes;

	      for (var i = 0, n = attributes.length; i < n; ++i) {
	        if (attributes[i].nodeName !== 'target' && attributes[i].nodeName !== 'escape-regex') {
	          this.templateAttributes.set(attributes[i].nodeName, attributes[i].nodeValue);
	        }
	      }

	      var type = this.target.split('#')[0];
	      var tagHTML = "<".concat(type).concat(this.templateAttributes.size ? " ".concat(function () {
	        var result = [];

	        _this3.templateAttributes.forEach(function (value, key) {
	          return result.push("".concat(key.replace(/template-(.*?)/gm, ''), "=\"").concat(value, "\""));
	        });

	        return result.join(' ');
	      }()) : '');
	      this.tagComponents = {
	        strings: [],
	        values: []
	      };

	      this._processHtmlParts(tagHTML, this.tagComponents);
	      /* the data should always be appended at the end of the attributes :/ */


	      var appended = false;

	      var _iterator = _createForOfIteratorHelper(this.customAttributesNames),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var entry = _step.value;

	          if (!appended) {
	            appended = true;
	            this.tagComponents.strings[this.tagComponents.strings.length - 1] += " ".concat(entry[0], "=\"");
	          } else {
	            this.tagComponents.strings.push("\" ".concat(entry[0], "=\""));
	          }

	          this.tagComponents.values.push(entry[1]);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      if (!appended) {
	        this.tagComponents.strings[this.tagComponents.strings.length - 1] += ' .data="';
	      } else {
	        this.tagComponents.strings.push('" .data="');
	      }

	      this.tagComponents.values.push(kDataKey);
	      this.tagComponents.strings.push('">');
	      this.tagComponents.values.push(kSlotsKey);
	      this.tagComponents.strings.push("</".concat(type, ">"));
	    }
	  }, {
	    key: "_processAddedNodes",
	    value: function _processAddedNodes(nodes) {
	      for (var i = 0, n = nodes.length; i < n; ++i) {
	        if (nodes[i] instanceof HTMLElement) {
	          var child = nodes[i];
	          var slotComponents = {
	            strings: [],
	            values: []
	          };
	          var slotHTML = child.outerHTML.replace(/\stemplate-(.*?\s?)=/gm, function (match, inner) {
	            return " ".concat(inner, "=");
	          }).replace(/(<\/?)template-(.*?)>/gm, function (match, open, inner) {
	            return "".concat(open).concat(inner, ">");
	          });

	          if (child.tagName.toLowerCase() === 'facet-template') {
	            slotComponents.strings.push(slotHTML);
	          } else {
	            this._processHtmlParts(slotHTML, slotComponents);
	          }

	          this.slots.push(slotComponents);

	          if (this.parentNode instanceof LitElement) {
	            this.parentNode.requestUpdate();
	          }
	        }
	      }
	    }
	  }, {
	    key: "_processHtmlParts",
	    value: function _processHtmlParts(rawHTML, components) {
	      return this._processXlinkAttributes(rawHTML, components);
	    }
	  }, {
	    key: "_processXlinkAttributes",
	    value: function _processXlinkAttributes(rawHTML, components) {
	      var parts = rawHTML.split(/xlink:href="(.*?)"/gm);

	      for (var i = 0, n = parts.length; i < n; ++i) {
	        if (i % 2) {
	          components.strings[components.strings.length - 1] += 'xlink:href="';
	          parts[i + 1] = "\"".concat(parts[i + 1]);

	          var xlinkComponents = this._processEscapedValues(parts[i], {
	            strings: [],
	            values: []
	          });

	          var key = Symbol("FacetTemplate::XlinkAttribute::".concat(this.target, "::").concat(parts[i]));
	          this.xlinkAttributes.set(key, xlinkComponents);
	          components.values.push(key);
	        } else {
	          this._processEscapedValues(parts[i], components);
	        }
	      }

	      return components;
	    }
	  }, {
	    key: "_processEscapedValues",
	    value: function _processEscapedValues(rawHTML, components) {
	      var parts = rawHTML.split(this._escapeRegex);

	      for (var i = 0, n = parts.length; i < n; ++i) {
	        if (i % 2) {
	          components.values.push(parts[i]);
	        } else {
	          components.strings.push(parts[i]);
	        }
	      }

	      return components;
	    }
	  }, {
	    key: "_getHTML",
	    value: function _getHTML(data, components, customAttributes) {
	      var values = [];

	      for (var i = 0, n = components.values.length; i < n; ++i) {
	        if (_typeof(components.values[i]) === 'symbol') {
	          var key = components.values[i];

	          if (key === kDataKey) {
	            values.push(data);
	          } else if (key === kSlotsKey) {
	            values.push(this._getSlotsHTML(data));
	          } else if (this.xlinkAttributes.has(key)) {
	            values.push(this._getXlinkValue(this.xlinkAttributes.get(key), data));
	          } else if (this.customAttributesKeys.has(key) && customAttributes.hasOwnProperty(this.customAttributesKeys.get(key))) {
	            values.push(customAttributes[this.customAttributesKeys.get(key)]);
	          } else {
	            values.push('');
	          }
	        } else {
	          values.push(this._getEscapedValue(data, components.values[i]));
	        }
	      }

	      return html$1.apply(void 0, [components.strings].concat(values));
	    }
	  }, {
	    key: "_getSlotsHTML",
	    value: function _getSlotsHTML(data) {
	      var slots = [];

	      for (var i = 0, n = this.slots.length; i < n; ++i) {
	        slots.push(this._getHTML(data, this.slots[i], {}));
	      }

	      return slots;
	    }
	  }, {
	    key: "_getXlinkValue",
	    value: function _getXlinkValue(components, data) {
	      var value = '';

	      for (var i = 0, n = components.strings.length; i < n; ++i) {
	        value += components.strings[i];

	        if (i < components.values.length) {
	          value += this._getEscapedValue(data, components.values[i]);
	        }
	      }

	      return this.xlinkDirective(value);
	    }
	  }, {
	    key: "_getEscapedValue",
	    value: function _getEscapedValue(data, key) {
	      var valueStr = key;
	      var funcCall = valueStr.split(/\((.*?)\)/g, 2);

	      var result = this._readValueFromRoute(funcCall[0], data);

	      if (funcCall.length === 2 && typeof result === 'function') {
	        // it's important to pass `null` as `this` to avoid leaking data when possible so disable es-lint
	        if (funcCall[1]) {
	          // eslint-disable-next-line no-useless-call
	          result = result.call(null, this._readValueFromRoute(funcCall[1], data));
	        } else {
	          // eslint-disable-next-line no-useless-call
	          result = result.call(null);
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "_readValueFromRoute",
	    value: function _readValueFromRoute(route, data) {
	      var components = route.split('.');
	      var value = data;

	      for (var i = 0, n = components.length; i < n; ++i) {
	        value = value[components[i]];
	      }

	      return value;
	    }
	  }, {
	    key: "escapeRegex",
	    get: function get() {
	      return this._escapeRegex.source;
	    },
	    set: function set(value) {
	      this._escapeRegex = new RegExp(value, 'gm');
	    }
	  }, {
	    key: "host",
	    get: function get() {
	      return this._host;
	    },
	    set: function set(value) {
	      this._host = value;
	    }
	  }], [{
	    key: "properties",
	    get: function get() {
	      return {
	        target: {
	          type: String
	        },
	        escapeRegex: {
	          type: String,
	          attribute: 'escape-regex'
	        }
	      };
	    }
	  }]);

	  return FacetTemplate;
	}(LitElement);

	FacetTemplate.connectedEvent = 'facet-template-connected';
	FacetTemplate.disconnectedEvent = 'facet-template-disconnected';
	FacetTemplate = FacetTemplate_1 = __decorate([customElement('facet-template')], FacetTemplate);

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetElement = /*#__PURE__*/function (_LitElement) {
	  _inherits(FacetElement, _LitElement);

	  var _super = _createSuper(FacetElement);

	  function FacetElement() {
	    var _this;

	    _classCallCheck(this, FacetElement);

	    _this = _super.call(this);
	    _this.plugins = new Set();
	    _this.templates = new Map();
	    _this.boundAddOnEventHandler = _this._addOnEventHandler.bind(_assertThisInitialized(_this));
	    _this.cssOptions = new CSSOptions(_assertThisInitialized(_this));
	    return _this;
	  }

	  _createClass(FacetElement, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(FacetElement.prototype), "connectedCallback", this).call(this);

	      this._setupAddOnEvents();
	    }
	  }, {
	    key: "disconnectedCallback",
	    value: function disconnectedCallback() {
	      _get(_getPrototypeOf(FacetElement.prototype), "disconnectedCallback", this).call(this);

	      this._teardownAddOnEvents();
	    }
	  }, {
	    key: "updated",
	    value: function updated(_changedProperties) {
	      _get(_getPrototypeOf(FacetElement.prototype), "updated", this).call(this, _changedProperties);

	      this.dispatchEvent(new CustomEvent('facet-element-updated', {
	        bubbles: false,
	        detail: {
	          changedProperties: _changedProperties
	        }
	      }));
	    }
	  }, {
	    key: "connectPlugin",
	    value: function connectPlugin(plugin) {
	      if (!this.plugins.has(plugin)) {
	        this.plugins.add(plugin);
	        plugin.host = this;
	      }
	    }
	  }, {
	    key: "disconnectPlugin",
	    value: function disconnectPlugin(plugin) {
	      if (this.plugins.has(plugin)) {
	        this.plugins.delete(plugin);
	        plugin.host = null;
	      }
	    }
	  }, {
	    key: "setTemplateForTarget",
	    value: function setTemplateForTarget(target, template) {
	      this.templates.set(target, template);
	      template.host = this;
	      this.requestUpdate();
	    }
	  }, {
	    key: "deleteTemplateForTarget",
	    value: function deleteTemplateForTarget(target, template) {
	      this.templates.delete(target);
	      template.host = null;
	      this.requestUpdate();
	    }
	  }, {
	    key: "computeStyle",
	    value: function computeStyle() {
	      return undefined;
	    }
	  }, {
	    key: "createRenderRoot",
	    value: function createRenderRoot() {
	      var useShadowDOM = this.getAttribute('use-shadow-dom');

	      if (useShadowDOM && useShadowDOM.toLowerCase() === 'false') {
	        return this;
	      }

	      return _get(_getPrototypeOf(FacetElement.prototype), "createRenderRoot", this).call(this);
	    }
	  }, {
	    key: "_setupAddOnEvents",
	    value: function _setupAddOnEvents() {
	      this.addEventListener(FacetPlugin.connectedEvent, this.boundAddOnEventHandler);
	      this.addEventListener(FacetPlugin.disconnectedEvent, this.boundAddOnEventHandler);
	      this.addEventListener(FacetTemplate.connectedEvent, this.boundAddOnEventHandler);
	      this.addEventListener(FacetTemplate.disconnectedEvent, this.boundAddOnEventHandler); // if (this.renderRoot !== this) {
	      //     this.renderRoot.addEventListener(FacetPlugin.connectedEvent, this.boundAddOnEventHandler);
	      //     this.renderRoot.addEventListener(FacetPlugin.disconnectedEvent, this.boundAddOnEventHandler);
	      //     this.renderRoot.addEventListener(FacetTemplate.connectedEvent, this.boundAddOnEventHandler);
	      //     this.renderRoot.addEventListener(FacetTemplate.disconnectedEvent, this.boundAddOnEventHandler);
	      // }
	    }
	  }, {
	    key: "_teardownAddOnEvents",
	    value: function _teardownAddOnEvents() {
	      this.removeEventListener(FacetPlugin.connectedEvent, this.boundAddOnEventHandler);
	      this.removeEventListener(FacetPlugin.disconnectedEvent, this.boundAddOnEventHandler);
	      this.removeEventListener(FacetTemplate.connectedEvent, this.boundAddOnEventHandler);
	      this.removeEventListener(FacetTemplate.disconnectedEvent, this.boundAddOnEventHandler); // if (this.renderRoot !== this) {
	      //     this.renderRoot.removeEventListener(FacetPlugin.connectedEvent, this.boundAddOnEventHandler);
	      //     this.renderRoot.removeEventListener(FacetPlugin.disconnectedEvent, this.boundAddOnEventHandler);
	      //     this.renderRoot.removeEventListener(FacetTemplate.connectedEvent, this.boundAddOnEventHandler);
	      //     this.renderRoot.removeEventListener(FacetTemplate.disconnectedEvent, this.boundAddOnEventHandler);
	      // }
	    }
	  }, {
	    key: "_addOnEventHandler",
	    value: function _addOnEventHandler(evt) {
	      if (evt instanceof CustomEvent) {
	        if (evt.detail.hasOwnProperty('plugin')) {
	          var plugin = evt.detail.plugin;

	          if (plugin instanceof FacetPlugin) {
	            if (evt.type === FacetPlugin.connectedEvent) {
	              this.connectPlugin(plugin);
	              evt.stopPropagation();
	            } else if (evt.type === FacetPlugin.disconnectedEvent) {
	              this.disconnectPlugin(plugin);
	              evt.stopPropagation();
	            }
	          }
	        } else if (evt.detail.hasOwnProperty('template')) {
	          var template = evt.detail.template;

	          if (template instanceof FacetTemplate) {
	            if (evt.type === FacetTemplate.connectedEvent) {
	              this.setTemplateForTarget(template.target, template);
	              evt.stopPropagation();
	            } else if (evt.type === FacetTemplate.disconnectedEvent) {
	              this.deleteTemplateForTarget(template.target, template);
	              evt.stopPropagation();
	            }
	          }
	        }
	      }
	    }
	  }], [{
	    key: "getSuperStyles",
	    value: function getSuperStyles() {
	      var proto = Object.getPrototypeOf(this);
	      var desc = Object.getOwnPropertyDescriptor(proto, 'styles');
	      return desc && desc.get ? desc.get.call(proto) : [];
	    }
	  }, {
	    key: "getSuperProperties",
	    value: function getSuperProperties() {
	      var proto = Object.getPrototypeOf(this);
	      var desc = Object.getOwnPropertyDescriptor(proto, 'properties');
	      return desc && desc.get ? desc.get.call(proto) : {};
	    }
	  }, {
	    key: "styles",
	    get: function get() {
	      return [];
	    }
	  }]);

	  return FacetElement;
	}(LitElement);

	FacetElement = __decorate([customElement('facet-element')], FacetElement);

	function _templateObject7() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject7 = function _templateObject7() {
	    return data;
	  };

	  return data;
	}

	function _templateObject6() {
	  var data = _taggedTemplateLiteral(["<slot name=\"footer\"></slot>"]);

	  _templateObject6 = function _templateObject6() {
	    return data;
	  };

	  return data;
	}

	function _templateObject5() {
	  var data = _taggedTemplateLiteral(["<slot name=\"right\"></slot>"]);

	  _templateObject5 = function _templateObject5() {
	    return data;
	  };

	  return data;
	}

	function _templateObject4() {
	  var data = _taggedTemplateLiteral(["<slot name=\"content\"></slot>"]);

	  _templateObject4 = function _templateObject4() {
	    return data;
	  };

	  return data;
	}

	function _templateObject3() {
	  var data = _taggedTemplateLiteral(["<slot name=\"left\"></slot>"]);

	  _templateObject3 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2() {
	  var data = _taggedTemplateLiteral(["<slot name=\"header\"></slot>"]);

	  _templateObject2 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n            <div class=\"facet-blueprint\">\n                <div class=\"facet-blueprint-header\">\n                    ", "\n                </div>\n                <div class=\"facet-blueprint-body\">\n                    <div class=\"facet-blueprint-left\">\n                        ", "\n                    </div>\n                    <div class=\"facet-blueprint-content\">\n                        ", "\n                    </div>\n                    <div class=\"facet-blueprint-right\">\n                        ", "\n                    </div>\n                </div>\n                <div class=\"facet-blueprint-footer\">\n                    ", "\n                </div>\n                ", "\n            </div>\n        "]);

	  _templateObject = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var FacetBlueprintStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-blueprint {\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    width: 100%;\n}\n\n.facet-blueprint-header {\n    position: relative;\n}\n\n.facet-blueprint-footer {\n    position: relative;\n}\n\n.facet-blueprint-body {\n    display: flex;\n    flex-direction: row;\n    flex-grow: 1;\n    align-items: stretch;\n}\n\n.facet-blueprint-left {\n    width: auto;\n}\n\n.facet-blueprint-content {\n    flex-grow: 1;\n    min-width: 0;\n    position: relative;\n}\n\n.facet-blueprint-right {\n    width: auto;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetBlueprint = /*#__PURE__*/function (_FacetElement) {
	  _inherits(FacetBlueprint, _FacetElement);

	  var _super = _createSuper(FacetBlueprint);

	  function FacetBlueprint() {
	    _classCallCheck(this, FacetBlueprint);

	    return _super.apply(this, arguments);
	  }

	  _createClass(FacetBlueprint, [{
	    key: "render",
	    value: function render() {
	      var children = this.children;
	      var slots = new Set(); // could it be optimized with member variable? is it worth the optimization?

	      var slot;

	      for (var i = 0, n = children.length; i < n; ++i) {
	        slot = children[i].getAttribute('slot');

	        if (slot) {
	          slots.add(slot);
	        }
	      }

	      return html$1(_templateObject(), this.cssOptions.supportsCSSVars ? undefined : this.computeStyle(), slots.has('header') ? html$1(_templateObject2()) : this.renderHeader(), slots.has('left') ? html$1(_templateObject3()) : this.renderLeft(), slots.has('content') ? html$1(_templateObject4()) : this.renderContent(), slots.has('right') ? html$1(_templateObject5()) : this.renderRight(), slots.has('footer') ? html$1(_templateObject6()) : this.renderFooter(), this.renderLayoutAdditions());
	    }
	  }, {
	    key: "update",
	    value: function update(changedProperties) {
	      if (this.renderRoot !== this) {
	        var templateResult = this.renderLightDOM();

	        if (templateResult instanceof TemplateResult) {
	          this.constructor.render(templateResult, this, {
	            scopeName: this.localName,
	            eventContext: this
	          });
	        }
	      }

	      _get(_getPrototypeOf(FacetBlueprint.prototype), "update", this).call(this, changedProperties);
	    }
	  }, {
	    key: "renderLightDOM",
	    value: function renderLightDOM() {
	      return undefined;
	    }
	  }, {
	    key: "renderContent",
	    value: function renderContent() {
	      return undefined;
	    }
	  }, {
	    key: "renderHeader",
	    value: function renderHeader() {
	      return undefined;
	    }
	  }, {
	    key: "renderFooter",
	    value: function renderFooter() {
	      return undefined;
	    }
	  }, {
	    key: "renderLeft",
	    value: function renderLeft() {
	      return undefined;
	    }
	  }, {
	    key: "renderRight",
	    value: function renderRight() {
	      return undefined;
	    }
	  }, {
	    key: "renderLayoutAdditions",
	    value: function renderLayoutAdditions() {
	      return undefined;
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject7(), unsafeCSS(FacetBlueprintStyle)));
	      return styles;
	    }
	  }]);

	  return FacetBlueprint;
	}(FacetElement);

	FacetBlueprint = __decorate([customElement('facet-blueprint')], FacetBlueprint);

	function _templateObject$1() {
	  var data = _taggedTemplateLiteral(["<svg width=\"", "\" height=\"", "\" viewBox=\"0 0 ", " ", "\" style=\"", "\"><path d=\"", "\"/></svg>"]);

	  _templateObject$1 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	function makeIconSVG(definition, width, height, color) {
	  return html$1(_templateObject$1(), width, height, definition.icon[0], definition.icon[1], color ? "fill:".concat(color, ";") : '', definition.icon[4]);
	}

	var faEye = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, '__esModule', { value: true });
	var prefix = 'fas';
	var iconName = 'eye';
	var width = 576;
	var height = 512;
	var ligatures = [];
	var unicode = 'f06e';
	var svgPathData = 'M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z';

	exports.definition = {
	  prefix: prefix,
	  iconName: iconName,
	  icon: [
	    width,
	    height,
	    ligatures,
	    unicode,
	    svgPathData
	  ]};

	exports.faEye = exports.definition;
	exports.prefix = prefix;
	exports.iconName = iconName;
	exports.width = width;
	exports.height = height;
	exports.ligatures = ligatures;
	exports.unicode = unicode;
	exports.svgPathData = svgPathData;
	});

	var faBan = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, '__esModule', { value: true });
	var prefix = 'fas';
	var iconName = 'ban';
	var width = 512;
	var height = 512;
	var ligatures = [];
	var unicode = 'f05e';
	var svgPathData = 'M256 8C119.034 8 8 119.033 8 256s111.034 248 248 248 248-111.034 248-248S392.967 8 256 8zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676zM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676z';

	exports.definition = {
	  prefix: prefix,
	  iconName: iconName,
	  icon: [
	    width,
	    height,
	    ligatures,
	    unicode,
	    svgPathData
	  ]};

	exports.faBan = exports.definition;
	exports.prefix = prefix;
	exports.iconName = iconName;
	exports.width = width;
	exports.height = height;
	exports.ligatures = ligatures;
	exports.unicode = unicode;
	exports.svgPathData = svgPathData;
	});

	var faQuestionCircle = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, '__esModule', { value: true });
	var prefix = 'far';
	var iconName = 'question-circle';
	var width = 512;
	var height = 512;
	var ligatures = [];
	var unicode = 'f059';
	var svgPathData = 'M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 448c-110.532 0-200-89.431-200-200 0-110.495 89.472-200 200-200 110.491 0 200 89.471 200 200 0 110.53-89.431 200-200 200zm107.244-255.2c0 67.052-72.421 68.084-72.421 92.863V300c0 6.627-5.373 12-12 12h-45.647c-6.627 0-12-5.373-12-12v-8.659c0-35.745 27.1-50.034 47.579-61.516 17.561-9.845 28.324-16.541 28.324-29.579 0-17.246-21.999-28.693-39.784-28.693-23.189 0-33.894 10.977-48.942 29.969-4.057 5.12-11.46 6.071-16.666 2.124l-27.824-21.098c-5.107-3.872-6.251-11.066-2.644-16.363C184.846 131.491 214.94 112 261.794 112c49.071 0 101.45 38.304 101.45 88.8zM298 368c0 23.159-18.841 42-42 42s-42-18.841-42-42 18.841-42 42-42 42 18.841 42 42z';

	exports.definition = {
	  prefix: prefix,
	  iconName: iconName,
	  icon: [
	    width,
	    height,
	    ligatures,
	    unicode,
	    svgPathData
	  ]};

	exports.faQuestionCircle = exports.definition;
	exports.prefix = prefix;
	exports.iconName = iconName;
	exports.width = width;
	exports.height = height;
	exports.ligatures = ligatures;
	exports.unicode = unicode;
	exports.svgPathData = svgPathData;
	});

	function _templateObject2$1() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject2$1 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$2() {
	  var data = _taggedTemplateLiteral(["\n            <div class=\"facet-button ", "\">\n                <slot name=\"button_", "\">\n                    ", "\n                </slot>\n            </div>\n        "]);

	  _templateObject$2 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	function renderButtonIcon(facet, index, total) {
	  if (total > 1) {
	    if (index === total - 2) {
	      return makeIconSVG(faEye.faEye, 14, 14);
	    } else if (index === total - 1) {
	      return makeIconSVG(faBan.faBan, 12, 12);
	    }
	  }

	  return makeIconSVG(faQuestionCircle.faQuestionCircle, 12, 12, '#C9CACB');
	}

	function _generateButton(facet, className, index, total) {
	  return html$1(_templateObject$2(), className, index, renderButtonIcon(facet, index, total));
	}

	function renderButtons(facet) {
	  var actionButtons = !isNaN(facet.actionButtons) ? facet.actionButtons : 2;

	  if (actionButtons > 0) {
	    var template = [];

	    if (actionButtons === 1) {
	      template.push(_generateButton(facet, 'facet-button-single', 0, 1));
	    } else {
	      var className = '';

	      for (var i = 0, n = actionButtons; i < n; ++i) {
	        if (i === 0) {
	          className = 'facet-button-left';
	        } else if (i === n - 1) {
	          className = 'facet-button-right';
	        } else {
	          className = '';
	        }

	        template.push(_generateButton(facet, className, i, n));
	      }
	    }

	    return html$1(_templateObject2$1(), template);
	  }

	  return undefined;
	}

	var buttonsStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-button {\n    width: 25px;\n    height: 25px;\n    background: linear-gradient(180deg, #F2F3F3 0%, #EAEBEC 100%);\n    border: 1px solid #D9DADB;\n    box-sizing: border-box;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n}\n\n.facet-button-single {\n    border-radius: 3px;\n}\n\n.facet-button-left {\n    border-radius: 3px 0 0 3px;\n}\n\n.facet-button-right {\n    border-radius: 0 3px 3px 0;\n}\n";

	function _templateObject2$2() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n            ", "\n        "]);

	  _templateObject2$2 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$3() {
	  var data = _taggedTemplateLiteral(["\n        <div class=\"facet-hoverable-buttons\"><slot name=\"buttons\">\n            ", "\n        </slot></div>\n        "]);

	  _templateObject$3 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var facetHoverableStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-blueprint {\n    background-color: #FFFFFF;\n    transition: background-color 256ms;\n    position: relative;\n}\n\n.facet-hoverable-buttons {\n    position: absolute;\n    z-index: 1;\n    right: 8px;\n    top: 0;\n    display: flex;\n    flex-direction: row;\n    opacity: 0;\n    transition: opacity 100ms, visibility 100ms;\n    cursor: pointer;\n    visibility: hidden;\n    width: auto;\n}\n\n.facet-blueprint:hover .facet-hoverable-buttons {\n    opacity: 1;\n    visibility: visible;\n    transition: opacity 0ms, visibility 0ms;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetHoverable = /*#__PURE__*/function (_FacetBlueprint) {
	  _inherits(FacetHoverable, _FacetBlueprint);

	  var _super = _createSuper(FacetHoverable);

	  function FacetHoverable() {
	    var _this;

	    _classCallCheck(this, FacetHoverable);

	    _this = _super.call(this);
	    _this._actionButtons = 2;
	    return _this;
	  }

	  _createClass(FacetHoverable, [{
	    key: "renderLayoutAdditions",
	    value: function renderLayoutAdditions() {
	      return html$1(_templateObject$3(), renderButtons(this));
	    }
	  }, {
	    key: "actionButtons",
	    set: function set(value) {
	      var oldValue = this._actionButtons;
	      this._actionButtons = value;
	      this.requestUpdate('actionButtons', oldValue);
	    },
	    get: function get() {
	      return this._actionButtons;
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject2$2(), unsafeCSS(buttonsStyle), unsafeCSS(facetHoverableStyle)));
	      return styles;
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        actionButtons: {
	          type: Number,
	          attribute: 'action-buttons'
	        }
	      };
	    }
	  }]);

	  return FacetHoverable;
	}(FacetBlueprint);

	FacetHoverable = __decorate([customElement('facet-hoverable')], FacetHoverable);

	function _templateObject3$1() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n        "]);

	  _templateObject3$1 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$3() {
	  var data = _taggedTemplateLiteral(["\n            <div class=\"facet-container-footer\">\n                <slot name=\"footer-label\">\n                    ", "\n                </slot>\n            </div>\n            "]);

	  _templateObject2$3 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$4() {
	  var data = _taggedTemplateLiteral(["\n            <div class=\"facet-container-header\">\n                <slot name=\"header-label\">\n                    ", "\n                </slot>\n            </div>\n            "]);

	  _templateObject$4 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var facetContainerStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-blueprint {\n    border-top: 1px solid #D9DADB;\n    background-color: #FFFFFF;\n}\n\n.facet-container-header {\n    height: 20px;\n    color: #1A1B1C;\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 14px;\n    font-style: normal;\n    font-weight: 600;\n    line-height: 20px;\n    padding: 6px 12px 5px;\n\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n}\n\n.facet-container-footer {\n    height: 20px;\n    color: #1A1B1C;\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 10px;\n    font-style: normal;\n    font-weight: 600;\n    line-height: 14px;\n    padding: 4px 12px 5px;\n\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetContainer = /*#__PURE__*/function (_FacetBlueprint) {
	  _inherits(FacetContainer, _FacetBlueprint);

	  var _super = _createSuper(FacetContainer);

	  function FacetContainer() {
	    var _this;

	    _classCallCheck(this, FacetContainer);

	    _this = _super.call(this);
	    _this.slottedElements = new Map();
	    _this.mutationObserver = new MutationWrapper(_assertThisInitialized(_this), false);
	    _this.mutationObserver.nodesAdded = _this._processAddedNodes.bind(_assertThisInitialized(_this));
	    _this.mutationObserver.nodesRemoved = _this._processRemovedNodes.bind(_assertThisInitialized(_this));
	    return _this;
	  }

	  _createClass(FacetContainer, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(FacetContainer.prototype), "connectedCallback", this).call(this);

	      this.mutationObserver.start();

	      this._processAddedNodes(this.childNodes);
	    }
	  }, {
	    key: "disconnectedCallback",
	    value: function disconnectedCallback() {
	      _get(_getPrototypeOf(FacetContainer.prototype), "disconnectedCallback", this).call(this);

	      this.mutationObserver.stop();
	    }
	  }, {
	    key: "updated",
	    value: function updated(_changedProperties) {
	      _get(_getPrototypeOf(FacetContainer.prototype), "updated", this).call(this, _changedProperties);

	      this.renderSlottedElements();
	    }
	  }, {
	    key: "renderHeader",
	    value: function renderHeader() {
	      var label = this.renderHeaderLabel();

	      if (label) {
	        return html$1(_templateObject$4(), label);
	      }

	      return undefined;
	    }
	  }, {
	    key: "renderHeaderLabel",
	    value: function renderHeaderLabel() {
	      return undefined;
	    }
	  }, {
	    key: "renderFooter",
	    value: function renderFooter() {
	      var label = this.renderFooterLabel();

	      if (label) {
	        return html$1(_templateObject2$3(), label);
	      }

	      return undefined;
	    }
	  }, {
	    key: "renderFooterLabel",
	    value: function renderFooterLabel() {
	      return undefined;
	    }
	  }, {
	    key: "createSlottedElement",
	    value: function createSlottedElement(slot) {
	      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'div';

	      if (this.slottedElements.has(slot)) {
	        return this.slottedElements.get(slot);
	      }

	      var element = document.createElement(type);
	      element.setAttribute('slot', slot);
	      this.appendChild(element);
	      this.slottedElements.set(slot, element);

	      this._processAddedNodes(this.childNodes);

	      return this.slottedElements.get(slot);
	    }
	  }, {
	    key: "renderSlottedElements",
	    value: function renderSlottedElements() {// OVERRIDE
	    }
	  }, {
	    key: "renderSlottedElement",
	    value: function renderSlottedElement(template, slotted) {
	      this.constructor.render(template, slotted, {
	        scopeName: this.localName,
	        eventContext: this
	      });
	    }
	  }, {
	    key: "_processAddedNodes",
	    value: function _processAddedNodes(nodes) {
	      for (var i = 0, n = nodes.length; i < n; ++i) {
	        if (nodes[i] instanceof HTMLElement) {
	          var child = nodes[i];

	          if (child.hasAttribute('slot')) {
	            var slot = child.getAttribute('slot');
	            var slotted = this.slottedElements.get(slot);

	            if (slotted && child !== slotted && slotted.parentElement === this) {
	              slotted.parentElement.removeChild(slotted);
	              this.requestUpdate();
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: "_processRemovedNodes",
	    value: function _processRemovedNodes(nodes) {
	      for (var i = 0, n = nodes.length; i < n; ++i) {
	        if (nodes[i] instanceof HTMLElement) {
	          var child = nodes[i];

	          if (child.hasAttribute('slot')) {
	            var slot = child.getAttribute('slot');

	            if (child === this.slottedElements.get(slot)) {
	              this.slottedElements.delete(slot);
	            }
	          }
	        }
	      }
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject3$1(), unsafeCSS(facetContainerStyle)));
	      return styles;
	    }
	  }]);

	  return FacetContainer;
	}(FacetBlueprint);

	FacetContainer = __decorate([customElement('facet-container')], FacetContainer);

	// TODO(kschaaf): Refactor into Part API?

	var createAndInsertPart = function createAndInsertPart(containerPart, beforePart) {
	  var container = containerPart.startNode.parentNode;
	  var beforeNode = beforePart === undefined ? containerPart.endNode : beforePart.startNode;
	  var startNode = container.insertBefore(createMarker(), beforeNode);
	  container.insertBefore(createMarker(), beforeNode);
	  var newPart = new NodePart(containerPart.options);
	  newPart.insertAfterNode(startNode);
	  return newPart;
	};

	var updatePart = function updatePart(part, value) {
	  part.setValue(value);
	  part.commit();
	  return part;
	};

	var insertPartBefore = function insertPartBefore(containerPart, part, ref) {
	  var container = containerPart.startNode.parentNode;
	  var beforeNode = ref ? ref.startNode : containerPart.endNode;
	  var endNode = part.endNode.nextSibling;

	  if (endNode !== beforeNode) {
	    reparentNodes(container, part.startNode, endNode, beforeNode);
	  }
	};

	var removePart = function removePart(part) {
	  removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
	}; // Helper for generating a map of array item to its index over a subset
	// of an array (used to lazily generate `newKeyToIndexMap` and
	// `oldKeyToIndexMap`)


	var generateMap = function generateMap(list, start, end) {
	  var map = new Map();

	  for (var i = start; i <= end; i++) {
	    map.set(list[i], i);
	  }

	  return map;
	}; // Stores previous ordered list of parts and map of key to index


	var partListCache = new WeakMap();
	var keyListCache = new WeakMap();
	/**
	 * A directive that repeats a series of values (usually `TemplateResults`)
	 * generated from an iterable, and updates those items efficiently when the
	 * iterable changes based on user-provided `keys` associated with each item.
	 *
	 * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
	 * meaning previous DOM for a given key is moved into the new position if
	 * needed, and DOM will never be reused with values for different keys (new DOM
	 * will always be created for new keys). This is generally the most efficient
	 * way to use `repeat` since it performs minimum unnecessary work for insertions
	 * and removals.
	 *
	 * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a
	 * given call to `repeat`. The behavior when two or more items have the same key
	 * is undefined.
	 *
	 * If no `keyFn` is provided, this directive will perform similar to mapping
	 * items to values, and DOM will be reused against potentially different items.
	 */

	var repeat = directive(function (items, keyFnOrTemplate, template) {
	  var keyFn;

	  if (template === undefined) {
	    template = keyFnOrTemplate;
	  } else if (keyFnOrTemplate !== undefined) {
	    keyFn = keyFnOrTemplate;
	  }

	  return function (containerPart) {
	    if (!(containerPart instanceof NodePart)) {
	      throw new Error('repeat can only be used in text bindings');
	    } // Old part & key lists are retrieved from the last update
	    // (associated with the part for this instance of the directive)


	    var oldParts = partListCache.get(containerPart) || [];
	    var oldKeys = keyListCache.get(containerPart) || []; // New part list will be built up as we go (either reused from
	    // old parts or created for new keys in this update). This is
	    // saved in the above cache at the end of the update.

	    var newParts = []; // New value list is eagerly generated from items along with a
	    // parallel array indicating its key.

	    var newValues = [];
	    var newKeys = [];
	    var index = 0;

	    var _iterator = _createForOfIteratorHelper(items),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var item = _step.value;
	        newKeys[index] = keyFn ? keyFn(item, index) : index;
	        newValues[index] = template(item, index);
	        index++;
	      } // Maps from key to index for current and previous update; these
	      // are generated lazily only when needed as a performance
	      // optimization, since they are only required for multiple
	      // non-contiguous changes in the list, which are less common.

	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }

	    var newKeyToIndexMap;
	    var oldKeyToIndexMap; // Head and tail pointers to old parts and new values

	    var oldHead = 0;
	    var oldTail = oldParts.length - 1;
	    var newHead = 0;
	    var newTail = newValues.length - 1; // Overview of O(n) reconciliation algorithm (general approach
	    // based on ideas found in ivi, vue, snabbdom, etc.):
	    //
	    // * We start with the list of old parts and new values (and
	    //   arrays of their respective keys), head/tail pointers into
	    //   each, and we build up the new list of parts by updating
	    //   (and when needed, moving) old parts or creating new ones.
	    //   The initial scenario might look like this (for brevity of
	    //   the diagrams, the numbers in the array reflect keys
	    //   associated with the old parts or new values, although keys
	    //   and parts/values are actually stored in parallel arrays
	    //   indexed using the same head/tail pointers):
	    //
	    //      oldHead v                 v oldTail
	    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
	    //   newParts: [ ,  ,  ,  ,  ,  ,  ]
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new
	    //                                      item order
	    //      newHead ^                 ^ newTail
	    //
	    // * Iterate old & new lists from both sides, updating,
	    //   swapping, or removing parts at the head/tail locations
	    //   until neither head nor tail can move.
	    //
	    // * Example below: keys at head pointers match, so update old
	    //   part 0 in-place (no need to move it) and record part 0 in
	    //   the `newParts` list. The last thing we do is advance the
	    //   `oldHead` and `newHead` pointers (will be reflected in the
	    //   next diagram).
	    //
	    //      oldHead v                 v oldTail
	    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
	    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
	    //                                      & newHead
	    //      newHead ^                 ^ newTail
	    //
	    // * Example below: head pointers don't match, but tail
	    //   pointers do, so update part 6 in place (no need to move
	    //   it), and record part 6 in the `newParts` list. Last,
	    //   advance the `oldTail` and `oldHead` pointers.
	    //
	    //         oldHead v              v oldTail
	    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
	    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail
	    //                                      & newTail
	    //         newHead ^              ^ newTail
	    //
	    // * If neither head nor tail match; next check if one of the
	    //   old head/tail items was removed. We first need to generate
	    //   the reverse map of new keys to index (`newKeyToIndexMap`),
	    //   which is done once lazily as a performance optimization,
	    //   since we only hit this case if multiple non-contiguous
	    //   changes were made. Note that for contiguous removal
	    //   anywhere in the list, the head and tails would advance
	    //   from either end and pass each other before we get to this
	    //   case and removals would be handled in the final while loop
	    //   without needing to generate the map.
	    //
	    // * Example below: The key at `oldTail` was removed (no longer
	    //   in the `newKeyToIndexMap`), so remove that part from the
	    //   DOM and advance just the `oldTail` pointer.
	    //
	    //         oldHead v           v oldTail
	    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
	    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail
	    //         newHead ^           ^ newTail
	    //
	    // * Once head and tail cannot move, any mismatches are due to
	    //   either new or moved items; if a new key is in the previous
	    //   "old key to old index" map, move the old part to the new
	    //   location, otherwise create and insert a new part. Note
	    //   that when moving an old part we null its position in the
	    //   oldParts array if it lies between the head and tail so we
	    //   know to skip it when the pointers get there.
	    //
	    // * Example below: neither head nor tail match, and neither
	    //   were removed; so find the `newHead` key in the
	    //   `oldKeyToIndexMap`, and move that old part's DOM into the
	    //   next head position (before `oldParts[oldHead]`). Last,
	    //   null the part in the `oldPart` array since it was
	    //   somewhere in the remaining oldParts still to be scanned
	    //   (between the head and tail pointers) so that we know to
	    //   skip that old part on future iterations.
	    //
	    //         oldHead v        v oldTail
	    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
	    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance
	    //                                      newHead
	    //         newHead ^           ^ newTail
	    //
	    // * Note that for moves/insertions like the one above, a part
	    //   inserted at the head pointer is inserted before the
	    //   current `oldParts[oldHead]`, and a part inserted at the
	    //   tail pointer is inserted before `newParts[newTail+1]`. The
	    //   seeming asymmetry lies in the fact that new parts are
	    //   moved into place outside in, so to the right of the head
	    //   pointer are old parts, and to the right of the tail
	    //   pointer are new parts.
	    //
	    // * We always restart back from the top of the algorithm,
	    //   allowing matching and simple updates in place to
	    //   continue...
	    //
	    // * Example below: the head pointers once again match, so
	    //   simply update part 1 and record it in the `newParts`
	    //   array.  Last, advance both head pointers.
	    //
	    //         oldHead v        v oldTail
	    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
	    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
	    //                                      & newHead
	    //            newHead ^        ^ newTail
	    //
	    // * As mentioned above, items that were moved as a result of
	    //   being stuck (the final else clause in the code below) are
	    //   marked with null, so we always advance old pointers over
	    //   these so we're comparing the next actual old value on
	    //   either end.
	    //
	    // * Example below: `oldHead` is null (already placed in
	    //   newParts), so advance `oldHead`.
	    //
	    //            oldHead v     v oldTail
	    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:
	    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
	    //               newHead ^     ^ newTail
	    //
	    // * Note it's not critical to mark old parts as null when they
	    //   are moved from head to tail or tail to head, since they
	    //   will be outside the pointer range and never visited again.
	    //
	    // * Example below: Here the old tail key matches the new head
	    //   key, so the part at the `oldTail` position and move its
	    //   DOM to the new head position (before `oldParts[oldHead]`).
	    //   Last, advance `oldTail` and `newHead` pointers.
	    //
	    //               oldHead v  v oldTail
	    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
	    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,
	    //                                     advance oldTail & newHead
	    //               newHead ^     ^ newTail
	    //
	    // * Example below: Old and new head keys match, so update the
	    //   old head part in place, and advance the `oldHead` and
	    //   `newHead` pointers.
	    //
	    //               oldHead v oldTail
	    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
	    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &
	    //                                      newHead
	    //                  newHead ^  ^ newTail
	    //
	    // * Once the new or old pointers move past each other then all
	    //   we have left is additions (if old list exhausted) or
	    //   removals (if new list exhausted). Those are handled in the
	    //   final while loops at the end.
	    //
	    // * Example below: `oldHead` exceeded `oldTail`, so we're done
	    //   with the main loop.  Create the remaining part and insert
	    //   it at the new head position, and the update is complete.
	    //
	    //                   (oldHead > oldTail)
	    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
	    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7
	    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
	    //                     newHead ^ newTail
	    //
	    // * Note that the order of the if/else clauses is not
	    //   important to the algorithm, as long as the null checks
	    //   come first (to ensure we're always working on valid old
	    //   parts) and that the final else clause comes last (since
	    //   that's where the expensive moves occur). The order of
	    //   remaining clauses is is just a simple guess at which cases
	    //   will be most common.
	    //
	    // * TODO(kschaaf) Note, we could calculate the longest
	    //   increasing subsequence (LIS) of old items in new position,
	    //   and only move those not in the LIS set. However that costs
	    //   O(nlogn) time and adds a bit more code, and only helps
	    //   make rare types of mutations require fewer moves. The
	    //   above handles removes, adds, reversal, swaps, and single
	    //   moves of contiguous items in linear time, in the minimum
	    //   number of moves. As the number of multiple moves where LIS
	    //   might help approaches a random shuffle, the LIS
	    //   optimization becomes less helpful, so it seems not worth
	    //   the code at this point. Could reconsider if a compelling
	    //   case arises.

	    while (oldHead <= oldTail && newHead <= newTail) {
	      if (oldParts[oldHead] === null) {
	        // `null` means old part at head has already been used
	        // below; skip
	        oldHead++;
	      } else if (oldParts[oldTail] === null) {
	        // `null` means old part at tail has already been used
	        // below; skip
	        oldTail--;
	      } else if (oldKeys[oldHead] === newKeys[newHead]) {
	        // Old head matches new head; update in place
	        newParts[newHead] = updatePart(oldParts[oldHead], newValues[newHead]);
	        oldHead++;
	        newHead++;
	      } else if (oldKeys[oldTail] === newKeys[newTail]) {
	        // Old tail matches new tail; update in place
	        newParts[newTail] = updatePart(oldParts[oldTail], newValues[newTail]);
	        oldTail--;
	        newTail--;
	      } else if (oldKeys[oldHead] === newKeys[newTail]) {
	        // Old head matches new tail; update and move to new tail
	        newParts[newTail] = updatePart(oldParts[oldHead], newValues[newTail]);
	        insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
	        oldHead++;
	        newTail--;
	      } else if (oldKeys[oldTail] === newKeys[newHead]) {
	        // Old tail matches new head; update and move to new head
	        newParts[newHead] = updatePart(oldParts[oldTail], newValues[newHead]);
	        insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
	        oldTail--;
	        newHead++;
	      } else {
	        if (newKeyToIndexMap === undefined) {
	          // Lazily generate key-to-index maps, used for removals &
	          // moves below
	          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
	          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
	        }

	        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
	          // Old head is no longer in new list; remove
	          removePart(oldParts[oldHead]);
	          oldHead++;
	        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
	          // Old tail is no longer in new list; remove
	          removePart(oldParts[oldTail]);
	          oldTail--;
	        } else {
	          // Any mismatches at this point are due to additions or
	          // moves; see if we have an old part we can reuse and move
	          // into place
	          var oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
	          var oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;

	          if (oldPart === null) {
	            // No old part for this value; create a new one and
	            // insert it
	            var newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
	            updatePart(newPart, newValues[newHead]);
	            newParts[newHead] = newPart;
	          } else {
	            // Reuse old part
	            newParts[newHead] = updatePart(oldPart, newValues[newHead]);
	            insertPartBefore(containerPart, oldPart, oldParts[oldHead]); // This marks the old part as having been used, so that
	            // it will be skipped in the first two checks above

	            oldParts[oldIndex] = null;
	          }

	          newHead++;
	        }
	      }
	    } // Add parts for any remaining new values


	    while (newHead <= newTail) {
	      // For all remaining additions, we insert before last new
	      // tail, since old pointers are no longer valid
	      var _newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);

	      updatePart(_newPart, newValues[newHead]);
	      newParts[newHead++] = _newPart;
	    } // Remove any remaining unused old parts


	    while (oldHead <= oldTail) {
	      var _oldPart = oldParts[oldHead++];

	      if (_oldPart !== null) {
	        removePart(_oldPart);
	      }
	    } // Save order of new parts for next round


	    partListCache.set(containerPart, newParts);
	    keyListCache.set(containerPart, newKeys);
	  };
	});

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	function dropIndices(arr, needlessValues) {
	  var newArr = [];
	  var j = 0;

	  for (var i = 0, n = arr.length; i < n; ++i) {
	    if (needlessValues[j].index === i) {
	      ++j;
	    } else {
	      newArr.push(arr[i]);
	    }
	  }

	  return newArr;
	}

	var templateStringsCache = new WeakMap(); // Convert dynamic tags to template strings
	// example: <${'div'}>${'this is example'}</${'div'}> => <div>${'this is example'}</div>

	function preHTML(strings) {
	  // check cache !important return equal link at first argument
	  var cachedStrings = templateStringsCache.get(strings);

	  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    values[_key - 1] = arguments[_key];
	  }

	  if (cachedStrings) {
	    for (var i = 0, n = cachedStrings.length; i < n; ++i) {
	      var _needlessValues = cachedStrings[i].needlessValues;
	      var isSame = true;

	      for (var ii = 0, nn = _needlessValues.length; ii < nn; ++ii) {
	        if (values[_needlessValues[ii].index] !== _needlessValues[ii].value) {
	          isSame = false;
	          break;
	        }
	      }

	      if (isSame) {
	        return html$1.apply(void 0, [cachedStrings[i].strings].concat(_toConsumableArray(dropIndices(values, _needlessValues))));
	      }
	    }
	  }

	  var needlessValues = [];
	  var newStrings = [];
	  var str;

	  for (var _i = 0, _n = strings.length; _i < _n; ++_i) {
	    str = strings[_i];

	    while (str[str.length - 1] === '<' // open tag
	    || str[str.length - 2] === '<' && str[str.length - 1] === '/' // close tag
	    ) {
	      needlessValues.push({
	        value: values[_i],
	        index: _i
	      });
	      str += values[_i] + strings[++_i];
	    }

	    newStrings.push(str);
	  }

	  if (!cachedStrings) {
	    cachedStrings = [];
	    templateStringsCache.set(strings, cachedStrings);
	  }

	  cachedStrings.push({
	    strings: newStrings,
	    needlessValues: needlessValues
	  });
	  return html$1.apply(void 0, [newStrings].concat(_toConsumableArray(dropIndices(values, needlessValues))));
	}

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */
	var kPolyMatches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector || function () {
	  throw new Error('Browsers without a native implementation of `Element.prototype.matches` are not supported');
	}();

	function polyMatches(target, selector) {
	  return kPolyMatches.call(target, selector);
	}

	function _templateObject6$1() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n        "]);

	  _templateObject6$1 = function _templateObject6() {
	    return data;
	  };

	  return data;
	}

	function _templateObject5$1() {
	  var data = _taggedTemplateLiteral(["\n        <div class=\"facet-terms-container\" @mouseenter=\"", "\" @mouseleave=\"", "\">\n            ", "\n        </div>\n        "]);

	  _templateObject5$1 = function _templateObject5() {
	    return data;
	  };

	  return data;
	}

	function _templateObject4$1() {
	  var data = _taggedTemplateLiteral(["\n                <", "\n                    id=\"", "\"\n                    action-buttons=\"", "\"\n                    state=\"", "\"\n                    contrast=\"", "\"\n                    .values=\"", "\"\n                    .data=\"", "\"\n                    @click=\"", "\">\n                </", ">"]);

	  _templateObject4$1 = function _templateObject4() {
	    return data;
	  };

	  return data;
	}

	function _templateObject3$2() {
	  var data = _taggedTemplateLiteral(["\n                    <facet-terms-value\n                        id=\"", "\"\n                        action-buttons=\"", "\"\n                        state=\"", "\"\n                        contrast=\"", "\"\n                        .values=\"", "\"\n                        .data=\"", "\"\n                        @click=\"", "\">\n                    </facet-terms-value>"]);

	  _templateObject3$2 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$4() {
	  var data = _taggedTemplateLiteral([""]);

	  _templateObject2$4 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$5() {
	  var data = _taggedTemplateLiteral(["<span>", "</span>"]);

	  _templateObject$5 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var facetTermsStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var kDefaultData = {
	  values: []
	};

	var FacetTerms = /*#__PURE__*/function (_FacetContainer) {
	  _inherits(FacetTerms, _FacetContainer);

	  var _super = _createSuper(FacetTerms);

	  function FacetTerms() {
	    var _this;

	    _classCallCheck(this, FacetTerms);

	    _this = _super.apply(this, arguments);
	    _this.selection = null;
	    _this.subselection = null;
	    _this.multiselect = true;
	    _this.disabled = false;
	    _this.actionButtons = 2;
	    _this._data = kDefaultData;
	    _this._hover = false;
	    _this.valueKeys = [];
	    return _this;
	  }

	  _createClass(FacetTerms, [{
	    key: "setTemplateForTarget",
	    value: function setTemplateForTarget(target, template) {
	      _get(_getPrototypeOf(FacetTerms.prototype), "setTemplateForTarget", this).call(this, target, template);

	      template.addCustomAttribute('id');
	      template.addCustomAttribute('action-buttons');
	      template.addCustomAttribute('state');
	      template.addCustomAttribute('contrast');
	      template.addCustomAttribute('.values');
	      template.addCustomAttribute('@click');
	    }
	  }, {
	    key: "renderHeaderLabel",
	    value: function renderHeaderLabel() {
	      return html$1(_templateObject$5(), this.data.label);
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(FacetTerms.prototype), "connectedCallback", this).call(this);

	      var content = this.createSlottedElement('content');

	      if (content) {
	        content.setAttribute('id', 'facet-terms-content');
	      }
	    }
	  }, {
	    key: "renderSlottedElements",
	    value: function renderSlottedElements() {
	      _get(_getPrototypeOf(FacetTerms.prototype), "renderSlottedElements", this).call(this);

	      var content = this.slottedElements.get('content');

	      if (content) {
	        this.renderSlottedElement(this._renderContent() || html$1(_templateObject2$4()), content);
	      }
	    }
	  }, {
	    key: "_renderContent",
	    value: function _renderContent() {
	      var _this2 = this;

	      var contrast = this.hover;

	      var keyFunction = function keyFunction(key) {
	        return key;
	      };

	      var htmlFunction = function htmlFunction(key) {
	        var value = _this2._data.values[key];

	        if (value) {
	          var type = value.type || 'facet-terms-value';
	          var state = _this2.selection ? _this2.selection[key] && 'selected' || 'muted' : 'normal';
	          var subselection = _this2.subselection && _this2.subselection.hasOwnProperty(key) ? _this2.subselection[key] : null;

	          var values = _this2.computeValuesArray(value, subselection);

	          var template = _this2.templates.get(type);

	          if (template) {
	            return template.getHTML(value, {
	              'id': key,
	              'action-buttons': _this2.actionButtons,
	              'state': state,
	              'contrast': contrast,
	              '.values': values,
	              '@click': _this2.handleMouseClickEvent
	            });
	          } else if (type === 'facet-terms-value') {
	            return html$1(_templateObject3$2(), key, _this2.actionButtons, state, contrast, values, value, _this2.handleMouseClickEvent);
	          }

	          return preHTML(_templateObject4$1(), type, key, _this2.actionButtons, state, contrast, values, value, _this2.handleMouseClickEvent, type);
	        }

	        return undefined;
	      };

	      return html$1(_templateObject5$1(), this.handleMouseHoverEvent, this.handleMouseHoverEvent, repeat(this.valueKeys, keyFunction, htmlFunction));
	    }
	  }, {
	    key: "computeValuesArray",
	    value: function computeValuesArray(value, subselection) {
	      var result = [];

	      if (value) {
	        result.push(value.ratio);

	        if (subselection !== null) {
	          var sub = Array.isArray(subselection) ? subselection : [subselection];
	          result.push.apply(result, _toConsumableArray(sub));
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "handleMouseHoverEvent",
	    value: function handleMouseHoverEvent(event) {
	      if (event.target instanceof Element) {
	        this.hover = polyMatches(event.target, ':hover');
	      }
	    }
	  }, {
	    key: "handleMouseClickEvent",
	    value: function handleMouseClickEvent(event) {
	      if (event.currentTarget instanceof Element && !this.disabled) {
	        var id = parseInt(event.currentTarget.getAttribute('id') || '', 10);

	        if (!isNaN(id)) {
	          var selection = Object.assign({}, this.selection);

	          if (selection[id]) {
	            if (this.multiselect) {
	              delete selection[id];
	            } else {
	              selection = {};
	            }
	          } else {
	            if (this.multiselect) {
	              selection[id] = true;
	            } else {
	              selection = _defineProperty({}, id, true);
	            }
	          }

	          this.selection = Object.keys(selection).length === 0 ? null : selection;
	        }
	      }
	    }
	  }, {
	    key: "data",
	    // @ts-ignore
	    get: function get() {
	      return this._data;
	    } // @ts-ignore
	    ,
	    set: function set(value) {
	      var oldValue = this._data;

	      if (!value || value === kDefaultData) {
	        this._data = kDefaultData;
	        this.valueKeys = [];
	      } else {
	        this._data = value;
	        this.valueKeys = Object.keys(this._data.values).map(function (key) {
	          return parseInt(key, 10);
	        });
	      }

	      this.requestUpdate('data', oldValue);
	    }
	  }, {
	    key: "hover",
	    get: function get() {
	      return this._hover;
	    },
	    set: function set(value) {
	      var oldValue = this._hover;
	      this._hover = value;
	      this.requestUpdate('hover', oldValue);
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject6$1(), unsafeCSS(facetTermsStyle)));
	      return styles;
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        data: {
	          type: Object
	        },
	        selection: {
	          type: Object
	        },
	        subselection: {
	          type: Object
	        },
	        multiselect: {
	          type: Object
	        },
	        actionButtons: {
	          type: Number,
	          attribute: 'action-buttons'
	        },
	        disabled: {
	          type: Boolean
	        }
	      };
	    }
	  }]);

	  return FacetTerms;
	}(FacetContainer);

	FacetTerms = __decorate([customElement('facet-terms')], FacetTerms);

	function _templateObject8() {
	  var data = _taggedTemplateLiteral(["\n                    :host([state=\"normal\"]) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-normal);\n                    }\n\n                    :host([contrast=true][state=\"normal\"]) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-normal-contrast);\n                    }\n\n                    :host([contrast=true][state=\"normal\"]:hover) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-normal-contrast-hover);\n                    }\n\n                    :host([state=\"selected\"]) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-selected);\n                    }\n\n                    :host([contrast=true][state=\"selected\"]) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-selected-contrast);\n                    }\n\n                    :host([contrast=true][state=\"selected\"]:hover) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-selected-contrast-hover);\n                    }\n\n                    :host([state=\"muted\"]) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-muted);\n                    }\n\n                    :host([contrast=true][state=\"muted\"]) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-muted-contrast);\n                    }\n\n                    :host([contrast=true][state=\"muted\"]:hover) .facet-terms-value-bar-", " {\n                        background-color: var(--facet-terms-bar-", "-muted-contrast-hover);\n                    }\n                "]);

	  _templateObject8 = function _templateObject8() {
	    return data;
	  };

	  return data;
	}

	function _templateObject7$1() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n        "]);

	  _templateObject7$1 = function _templateObject7() {
	    return data;
	  };

	  return data;
	}

	function _templateObject6$2() {
	  var data = _taggedTemplateLiteral(["<style>", "</style>"]);

	  _templateObject6$2 = function _templateObject6() {
	    return data;
	  };

	  return data;
	}

	function _templateObject5$2() {
	  var data = _taggedTemplateLiteral(["<span>", "</span>"]);

	  _templateObject5$2 = function _templateObject5() {
	    return data;
	  };

	  return data;
	}

	function _templateObject4$2() {
	  var data = _taggedTemplateLiteral(["<span>", "</span>"]);

	  _templateObject4$2 = function _templateObject4() {
	    return data;
	  };

	  return data;
	}

	function _templateObject3$3() {
	  var data = _taggedTemplateLiteral(["<span>", "</span>"]);

	  _templateObject3$3 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$5() {
	  var data = _taggedTemplateLiteral(["\n                <div class=", " style=\"width: ", "%\" part=", "></div>\n                "]);

	  _templateObject2$5 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$6() {
	  var data = _taggedTemplateLiteral(["\n        <div class=\"facet-term-container\">\n            <div class=\"facet-term-bar\">\n                <slot name=\"bar\">\n                    <div class=\"facet-term-bar-background\">", "</div>\n                </slot>\n            </div>\n            <div class=\"facet-term-details\">\n                <div class=\"facet-term-label\"><slot name=\"label\">", "</slot></div>\n                <div class=\"facet-term-annotation\"><slot name=\"annotation\">", "</slot></div>\n                <div class=\"facet-term-value\"><slot name=\"value\">", "</slot></div>\n            </div>\n        </div>\n        "]);

	  _templateObject$6 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var facetTermValueStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-blueprint-content {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n.facet-blueprint-left {\n    border-left: 4px solid transparent;\n}\n\n:host(:hover) .facet-blueprint-left {\n    border-left: 4px solid var(--facet-terms-tick-color, #255DCC);\n}\n\n.facet-term-container {\n    padding: 4px 12px 4px 8px;\n    width: 100%;\n}\n\n:host(:hover) .facet-blueprint {\n    background-color: #F7F7F7;\n}\n\n:host([state=\"selected\"]) .facet-blueprint {\n    background-color: var(--facet-terms-selected-background, #EBF1FC);\n}\n\n.facet-term-bar {\n    height: 4px;\n    width: 100%;\n}\n\n\n\n.facet-term-bar-background {\n    position: relative;\n    height: 100%;\n    width: 100%;\n}\n\n:host([state=\"normal\"]) .facet-term-bar-background {\n    background-color: #EAEBEC;\n}\n\n:host([contrast=true][state=\"normal\"]) .facet-term-bar-background {\n    background-color: #F7F7F7;\n}\n\n:host([contrast=true][state=\"normal\"]:hover) .facet-term-bar-background {\n    background-color: #EAEBEC;\n}\n\n:host([state=\"selected\"]) .facet-term-bar-background {\n    background-color: #D9DADB;\n}\n\n:host([contrast=true][state=\"selected\"]) .facet-term-bar-background {\n    background-color: #EAEBEC;\n}\n\n:host([contrast=true][state=\"selected\"]:hover) .facet-term-bar-background {\n    background-color: #D9DADB;\n}\n\n:host([state=\"muted\"]) .facet-term-bar-background {\n    background-color: #EAEBEC;\n}\n\n:host([contrast=true][state=\"muted\"]) .facet-term-bar-background {\n    background-color: #F7F7F7;\n}\n\n:host([contrast=true][state=\"muted\"]:hover) .facet-term-bar-background {\n    background-color: #EAEBEC;\n}\n\n.facet-term-bar-background > div {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    transition: width 200ms ease-out;\n}\n\n\n\n\n:host([state=\"normal\"]) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-normal, #255DCC);\n}\n\n:host([contrast=true][state=\"normal\"]) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-normal-contrast, #A4C2FC);\n}\n\n:host([contrast=true][state=\"normal\"]:hover) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-normal-contrast-hover, #255DCC);\n}\n\n:host([state=\"selected\"]) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-selected, #255DCC);\n}\n\n:host([contrast=true][state=\"selected\"]) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-selected-contrast, #A4C2FC);\n}\n\n:host([contrast=true][state=\"selected\"]:hover) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-selected-contrast-hover, #255DCC);\n}\n\n:host([state=\"muted\"]) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-muted, #C2C3C4);\n}\n\n:host([contrast=true][state=\"muted\"]) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-muted-contrast-hover, #D9DADB);\n}\n\n:host([contrast=true][state=\"muted\"]:hover) .facet-terms-value-bar-0 {\n    background-color: var(--facet-terms-bar-0-muted-contrast-hover, #255DCC);\n}\n\n\n\n\n\n:host([state=\"normal\"]) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-normal, #C2C3C4);\n}\n\n:host([contrast=true][state=\"normal\"]) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-normal-contrast, #D9DADB);\n}\n\n:host([contrast=true][state=\"normal\"]:hover) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-normal-contrast-hover, #C2C3C4);\n}\n\n:host([state=\"selected\"]) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-selected, #C2C3C4);\n}\n\n:host([contrast=true][state=\"selected\"]) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-selected-contrast, #D9DADB);\n}\n\n:host([contrast=true][state=\"selected\"]:hover) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-selected-contrast-hover, #C2C3C4);\n}\n\n:host([state=\"muted\"]) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-muted, #D9DADB);\n}\n\n:host([contrast=true][state=\"muted\"]) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-muted-contrast, #EAEBEC);\n}\n\n:host([contrast=true][state=\"muted\"]:hover) .facet-terms-value-bar-1 {\n    background-color: var(--facet-terms-bar-1-muted-contrast-hover, #C4D9FC);\n}\n\n\n\n\n\n.facet-term-details {\n    min-height: 16px;\n    display: flex;\n    flex-direction: row;\n    overflow: hidden;\n}\n\n.facet-term-label {\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 12px;\n    line-height: 16px;\n    letter-spacing: 0.02em;\n    color: #1A1B1C;\n}\n\n.facet-term-annotation {\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 12px;\n    line-height: 16px;\n    letter-spacing: 0.02em;\n    color: #727375;\n\n    flex-grow: 1;\n    padding-left: 14px;\n}\n\n.facet-term-value {\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 12px;\n    line-height: 16px;\n    letter-spacing: 0.02em;\n    color: #1A1B1C;\n    margin-left: 14px;\n}\n\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var kDefaultData$1 = {
	  ratio: 0
	};

	function getBarColorHostSelector(theme, state, index, contrast, hover) {
	  return ":host(".concat(theme).concat(contrast ? '[contrast=true]' : '', "[state=\"").concat(state, "\"]").concat(hover ? ':hover' : '', ") .facet-term-bar-background .facet-terms-value-bar-").concat(index);
	}

	var kBarStylePrefix = 'facet-terms-bar-';
	var kBarStyleGenerators = {
	  '-normal': function normal(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'normal', index, false, false), " { background-color:").concat(value, " }");
	  },
	  '-normal-contrast': function normalContrast(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'normal', index, true, false), " { background-color:").concat(value, " }");
	  },
	  '-normal-contrast-hover': function normalContrastHover(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'normal', index, true, true), " { background-color:").concat(value, " }");
	  },
	  '-selected': function selected(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'selected', index, false, false), " { background-color:").concat(value, " }");
	  },
	  '-selected-contrast': function selectedContrast(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'selected', index, true, false), " { background-color:").concat(value, " }");
	  },
	  '-selected-contrast-hover': function selectedContrastHover(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'selected', index, true, true), " { background-color:").concat(value, " }");
	  },
	  '-muted': function muted(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'muted', index, false, false), " { background-color:").concat(value, " }");
	  },
	  '-muted-contrast': function mutedContrast(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'muted', index, true, false), " { background-color:").concat(value, " }");
	  },
	  '-muted-contrast-hover': function mutedContrastHover(theme, index, value) {
	    return "".concat(getBarColorHostSelector(theme, 'muted', index, true, true), " { background-color:").concat(value, " }");
	  }
	};
	var kBarStyleSuffixes = Object.keys(kBarStyleGenerators);

	var FacetTermsValue = /*#__PURE__*/function (_FacetHoverable) {
	  _inherits(FacetTermsValue, _FacetHoverable);

	  var _super = _createSuper(FacetTermsValue);

	  function FacetTermsValue() {
	    var _this;

	    _classCallCheck(this, FacetTermsValue);

	    _this = _super.apply(this, arguments);
	    _this._data = kDefaultData$1;
	    _this.values = [];
	    _this.computedStyle = null;
	    return _this;
	  }

	  _createClass(FacetTermsValue, [{
	    key: "renderContent",
	    value: function renderContent() {
	      return html$1(_templateObject$6(), this.renderBar(), this.renderLabel(), this.renderAnnotation(), this.renderValue());
	    }
	  }, {
	    key: "renderBar",
	    value: function renderBar() {
	      var result = [];

	      for (var i = 0, n = this.values.length; i < n; ++i) {
	        var value = this.values[i];

	        if (!isNaN(value)) {
	          var width = (Math.max(Math.min(value, 1), 0) * 100).toFixed(2);
	          var barClass = "facet-terms-value-bar-".concat(n - i - 1);
	          result.push(html$1(_templateObject2$5(), barClass, width, barClass));
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "renderLabel",
	    value: function renderLabel() {
	      return html$1(_templateObject3$3(), this.data.label);
	    }
	  }, {
	    key: "renderAnnotation",
	    value: function renderAnnotation() {
	      return html$1(_templateObject4$2(), this.data.annotation);
	    }
	  }, {
	    key: "renderValue",
	    value: function renderValue() {
	      return html$1(_templateObject5$2(), this.data.value);
	    }
	  }, {
	    key: "computeStyle",
	    value: function computeStyle() {
	      if (this.computedStyle === null) {
	        var theme = this.getAttribute('theme');
	        var hostTheme = theme ? "[theme=\"".concat(theme, "\"]") : ':not([theme])';
	        var cssOptions = this.cssOptions;
	        var styles = [];
	        var n = this.values.length;
	        var i = 0;
	        var hasOption;

	        do {
	          hasOption = false;

	          for (var ii = 0, nn = kBarStyleSuffixes.length; ii < nn; ++ii) {
	            var option = "".concat(kBarStylePrefix).concat(i).concat(kBarStyleSuffixes[ii]);
	            var optionValue = cssOptions.read(option);

	            if (optionValue !== undefined) {
	              hasOption = true;
	              styles.push(kBarStyleGenerators[kBarStyleSuffixes[ii]](hostTheme, i, optionValue));
	            }
	          }
	        } while (++i < n || hasOption);

	        var tickValue = cssOptions.read('facet-terms-tick-color');

	        if (tickValue !== undefined) {
	          styles.push(":host(".concat(hostTheme, ":hover) .facet-blueprint .facet-blueprint-left { border-left: 4px solid ").concat(tickValue, "; }"));
	        }

	        var selectedBackground = cssOptions.read('facet-terms-selected-background');

	        if (selectedBackground !== undefined) {
	          styles.push(":host(".concat(hostTheme, "[state=\"selected\"]) .facet-blueprint:first-of-type { background-color:").concat(selectedBackground, "; }"));
	        }

	        if (styles.length) {
	          this.computedStyle = html$1(_templateObject6$2(), styles);
	        } else {
	          this.computedStyle = undefined;
	        }
	      }

	      return this.computedStyle;
	    }
	  }, {
	    key: "data",
	    set: function set(newData) {
	      var oldData = this._data;
	      this._data = newData;
	      this.requestUpdate('data', oldData);
	    },
	    get: function get() {
	      return this._data;
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject7$1(), unsafeCSS(facetTermValueStyle)));

	      if (CSSOptions.supportsCSSVars) {
	        // add the style for 20 sub-bars, sorry future Dario, you'll probably have to make this number dynamic
	        // start at bar 2 since the css already has the proper style for the first two
	        for (var i = 2; i < 20; ++i) {
	          styles.push(css(_templateObject8(), i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i));
	        }
	      }

	      return styles;
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        data: {
	          type: Object
	        },
	        values: {
	          type: Array,
	          converter: {
	            fromAttribute: function fromAttribute(value) {
	              if (!value) {
	                return [];
	              }

	              var arr = JSON.parse(value);

	              for (var i = 0, n = arr.length; i < n; ++i) {
	                arr[i] = parseFloat(arr[i]);
	              }

	              return arr;
	            },
	            toAttribute: function toAttribute(value) {
	              return "[".concat(value.toString(), "]");
	            }
	          }
	        }
	      };
	    }
	  }]);

	  return FacetTermsValue;
	}(FacetHoverable);

	FacetTermsValue = __decorate([customElement('facet-terms-value')], FacetTermsValue);

	/**
	 * @license
	 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	/**
	 * Stores the StyleInfo object applied to a given AttributePart.
	 * Used to unset existing values when a new StyleInfo object is applied.
	 */

	var previousStylePropertyCache = new WeakMap();
	/**
	 * A directive that applies CSS properties to an element.
	 *
	 * `styleMap` can only be used in the `style` attribute and must be the only
	 * expression in the attribute. It takes the property names in the `styleInfo`
	 * object and adds the property values as CSS properties. Property names with
	 * dashes (`-`) are assumed to be valid CSS property names and set on the
	 * element's style object using `setProperty()`. Names without dashes are
	 * assumed to be camelCased JavaScript property names and set on the element's
	 * style object using property assignment, allowing the style object to
	 * translate JavaScript-style names to CSS property names.
	 *
	 * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
	 * '0'})` sets the `background-color`, `border-top` and `--size` properties.
	 *
	 * @param styleInfo {StyleInfo}
	 */

	var styleMap = directive(function (styleInfo) {
	  return function (part) {
	    if (!(part instanceof AttributePart) || part instanceof PropertyPart || part.committer.name !== 'style' || part.committer.parts.length > 1) {
	      throw new Error('The `styleMap` directive must be used in the style attribute ' + 'and must be the only part in the attribute.');
	    }

	    var committer = part.committer;
	    var style = committer.element.style;
	    var previousStyleProperties = previousStylePropertyCache.get(part);

	    if (previousStyleProperties === undefined) {
	      // Write static styles once
	      style.cssText = committer.strings.join(' ');
	      previousStylePropertyCache.set(part, previousStyleProperties = new Set());
	    } // Remove old properties that no longer exist in styleInfo
	    // We use forEach() instead of for-of so that re don't require down-level
	    // iteration.


	    previousStyleProperties.forEach(function (name) {
	      if (!(name in styleInfo)) {
	        previousStyleProperties.delete(name);

	        if (name.indexOf('-') === -1) {
	          // eslint-disable-next-line @typescript-eslint/no-explicit-any
	          style[name] = null;
	        } else {
	          style.removeProperty(name);
	        }
	      }
	    }); // Add or update properties

	    for (var name in styleInfo) {
	      previousStyleProperties.add(name);

	      if (name.indexOf('-') === -1) {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        style[name] = styleInfo[name];
	      } else {
	        style.setProperty(name, styleInfo[name]);
	      }
	    }
	  };
	});

	function _templateObject6$3() {
	  var data = _taggedTemplateLiteral(["\n                    :host([facet-value-state=\"normal\"]) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-normal);\n                    }\n\n                    :host([contrast=true][facet-value-state=\"normal\"]) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-normal-contrast);\n                    }\n\n                    :host([contrast=true][facet-value-state=\"normal\"]:hover) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-normal-contrast-hover);\n                    }\n\n                    :host([facet-value-state=\"selected\"]) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-selected);\n                    }\n\n                    :host([contrast=true][facet-value-state=\"selected\"]) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-selected-contrast);\n                    }\n\n                    :host([contrast=true][facet-value-state=\"selected\"]:hover) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-selected-contrast-hover);\n                    }\n\n                    :host([facet-value-state=\"unselected\"]) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-unselected);\n                    }\n\n                    :host([contrast=true][facet-value-state=\"unselected\"]) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-unselected-contrast);\n                    }\n\n                    :host([contrast=true][facet-value-state=\"unselected\"]:hover) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-unselected-contrast-hover);\n                    }\n\n                    :host([facet-value-state=\"muted\"]) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-muted);\n                    }\n\n                    :host([contrast=true][facet-value-state=\"muted\"]) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-muted-contrast);\n                    }\n\n                    :host([contrast=true][facet-value-state=\"muted\"]:hover) .facet-bars-value-bar-", "\n                    {\n                        background-color: var(--facet-bars-", "-muted-contrast-hover);\n                    }\n                "]);

	  _templateObject6$3 = function _templateObject6() {
	    return data;
	  };

	  return data;
	}

	function _templateObject5$3() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n            ", "\n            ", "\n            ", "\n        "]);

	  _templateObject5$3 = function _templateObject5() {
	    return data;
	  };

	  return data;
	}

	function _templateObject4$3() {
	  var data = _taggedTemplateLiteral(["<style>", "</style>"]);

	  _templateObject4$3 = function _templateObject4() {
	    return data;
	  };

	  return data;
	}

	function _templateObject3$4() {
	  var data = _taggedTemplateLiteral(["\n                <div class=", " style=\"height: ", "%\" part=", "></div>\n                "]);

	  _templateObject3$4 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$6() {
	  var data = _taggedTemplateLiteral(["\n        <div class=\"facet-bars-value-background\">\n            ", "\n        </div>\n        <div class=\"facet-hoverable-buttons\"><slot name=\"buttons\">\n            ", "\n        </slot></div>\n        "]);

	  _templateObject2$6 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$7() {
	  var data = _taggedTemplateLiteral(["\n            <div class=\"facet-bars-value-background\" style=\"", "\">\n                ", "\n            </div>\n            <div class=\"facet-hoverable-buttons\"><slot name=\"buttons\">\n                ", "\n            </slot></div>\n            "]);

	  _templateObject$7 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var FacetBarsValueStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n:host {\n    height: inherit;\n    position: relative;\n    flex-grow: 1;\n}\n\n:host(:not(:last-of-type)) {\n    padding-right: 2px;\n}\n\n.facet-blueprint {\n    height: 100%;\n}\n\n.facet-hoverable-buttons {\n    position: absolute;\n    z-index: 1;\n    right: 8px;\n    top: 0;\n    display: flex;\n    flex-direction: row;\n    opacity: 0;\n    transition: opacity 100ms, visibility 100ms;\n    cursor: pointer;\n    visibility: hidden;\n    width: auto;\n}\n\n:host(:hover) .facet-hoverable-buttons {\n    opacity: 1;\n    visibility: visible;\n    transition: opacity 0ms, visibility 0ms;\n}\n\n.facet-hoverable-buttons {\n    right: unset;\n    left: 0;\n    top: -29px;\n}\n\n.facet-bars-value-background {\n    position: relative;\n    height: 100%;\n    transition: margin-left 200ms ease-out, background-color 128ms ease-out;\n}\n\n.facet-bars-value-background > div {\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    transition: height 200ms ease-out, background-color 128ms ease-out;\n}\n\n/*.facet-bars-value-bar-1 {*/\n/*    position: absolute;*/\n/*    left: 0;*/\n/*    right: 0;*/\n/*    bottom: 0;*/\n/*    transition: height 200ms ease-out, background-color 128ms ease-out;*/\n/*}*/\n\n/*.facet-bars-value-bar-0 {*/\n/*    position: absolute;*/\n/*    left: 0;*/\n/*    right: 0;*/\n/*    bottom: 0;*/\n/*    transition: height 200ms ease-out, background-color 128ms ease-out;*/\n/*}*/\n\n@keyframes facet-bars-value-loading-background {\n    0% {\n        background-color: #F7F7F7;\n    }\n\n    50% {\n        background-color: #F3F3F3;\n    }\n\n    100% {\n        background-color: #F7F7F7;\n    }\n}\n\n@keyframes facet-bars-value-loading-foreground {\n    0% {\n        height: 0;\n        opacity: 0;\n    }\n\n    25% {\n        opacity: 0.35;\n    }\n\n    50% {\n        height: 100%;\n        opacity: 1;\n    }\n\n    75% {\n        opacity: 0.35;\n    }\n\n    100% {\n        height: 0;\n        opacity: 0;\n    }\n}\n\n:host([facet-value-state=\"loading\"]) {\n    pointer-events: none;\n}\n\n:host([facet-value-state=\"loading\"]) .facet-bars-value-background\n{\n    animation-name: facet-bars-value-loading-background;\n    animation-timing-function: linear;\n    animation-duration: 2048ms;\n    animation-iteration-count:infinite;\n    transition: unset;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+2)) .facet-bars-value-background\n{\n    animation-delay: 256ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+3)) .facet-bars-value-background\n{\n    animation-delay: 512ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+4)) .facet-bars-value-background\n{\n    animation-delay: 768ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+5)) .facet-bars-value-background\n{\n    animation-delay: 1024ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+6)) .facet-bars-value-background\n{\n    animation-delay: 1280ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+7)) .facet-bars-value-background\n{\n    animation-delay: 1536ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+8)) .facet-bars-value-background\n{\n    animation-delay: 1792ms;\n}\n\n:host([facet-value-state=\"loading\"]) .facet-bars-value-bar-1,\n:host([facet-value-state=\"loading\"]) .facet-bars-value-bar-0\n{\n    height: 0;\n    animation-name: facet-bars-value-loading-foreground;\n    animation-timing-function: ease;\n    animation-duration: 3072ms;\n    animation-iteration-count:infinite;\n    transition: unset;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+2)) .facet-bars-value-bar-1,\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+2)) .facet-bars-value-bar-0\n{\n    animation-delay: 1909ms;\n    animation-duration: 3891ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+3)) .facet-bars-value-bar-1,\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+3)) .facet-bars-value-bar-0\n{\n    animation-delay: 1390ms;\n    animation-duration: 3770ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+4)) .facet-bars-value-bar-1,\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+4)) .facet-bars-value-bar-0\n{\n    animation-delay: 547ms;\n    animation-duration: 3275ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+5)) .facet-bars-value-bar-1,\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+5)) .facet-bars-value-bar-0\n{\n    animation-delay: 1182ms;\n    animation-duration: 3805ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+6)) .facet-bars-value-bar-1,\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+6)) .facet-bars-value-bar-0\n{\n    animation-delay: 262ms;\n    animation-duration: 3867ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+7)) .facet-bars-value-bar-1,\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+7)) .facet-bars-value-bar-0\n{\n    animation-delay: 741ms;\n    animation-duration: 3799ms;\n}\n\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+8)) .facet-bars-value-bar-1,\n:host([facet-value-state=\"loading\"]:nth-of-type(8n+8)) .facet-bars-value-bar-0\n{\n    animation-delay: 1182ms;\n    animation-duration: 4067ms;\n}\n";
	var FacetBarsValueDefaultTheme = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n/* .facet-bars-value-background */\n\n:host(:not([theme])[facet-value-state=\"normal\"]) .facet-bars-value-background,\n:host([theme=\"default\"][facet-value-state=\"normal\"]) .facet-bars-value-background\n{\n    background-color: #EAEBEC;\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"normal\"]) .facet-bars-value-background,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"normal\"]) .facet-bars-value-background\n{\n    background-color: #F7F7F7;\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"normal\"]):hover .facet-bars-value-background,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"normal\"]):hover .facet-bars-value-background\n{\n    background-color: #EAEBEC;\n}\n\n:host(:not([theme])[facet-value-state=\"selected\"]) .facet-bars-value-background,\n:host([theme=\"default\"][facet-value-state=\"selected\"]) .facet-bars-value-background\n{\n    background-color: #EBF1FC;\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"selected\"]) .facet-bars-value-background,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"selected\"]) .facet-bars-value-background\n{\n    background-color: #EAEBEC;\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"selected\"]:hover) .facet-bars-value-background,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"selected\"]:hover) .facet-bars-value-background\n{\n    background-color: #EAEBEC;\n}\n\n:host(:not([theme])[facet-value-state=\"unselected\"]) .facet-bars-value-background,\n:host([theme=\"default\"][facet-value-state=\"unselected\"]) .facet-bars-value-background\n{\n    background-color: #EAEBEC;\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"unselected\"]) .facet-bars-value-background,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"unselected\"]) .facet-bars-value-background\n{\n    background-color: #F7F7F7;\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"unselected\"]:hover) .facet-bars-value-background,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"unselected\"]:hover) .facet-bars-value-background\n{\n    background-color: #EBF1FC;\n}\n\n:host(:not([theme])[facet-value-state=\"muted\"]) .facet-bars-value-background,\n:host([theme=\"default\"][facet-value-state=\"muted\"]) .facet-bars-value-background\n{\n    background-color: #EAEBEC;\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"muted\"]) .facet-bars-value-background,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"muted\"]) .facet-bars-value-background\n{\n    background-color: #F7F7F7;\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"muted\"]:hover) .facet-bars-value-background,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"muted\"]:hover) .facet-bars-value-background\n{\n    background-color: #EBF1FC;\n}\n\n\n\n\n/* .facet-bars-value-bar-0 */\n\n:host(:not([theme])[facet-value-state=\"normal\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][facet-value-state=\"normal\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-normal, #255DCC);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"normal\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"normal\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-normal-contrast, #A4C2FC);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"normal\"]:hover) .facet-bars-value-bar-0,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"normal\"]:hover) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-normal-contrast-hover, #255DCC);\n}\n\n:host(:not([theme])[facet-value-state=\"selected\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][facet-value-state=\"selected\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-selected, #255DCC);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"selected\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"selected\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-selected-contrast, #A4C2FC);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"selected\"]:hover) .facet-bars-value-bar-0,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"selected\"]:hover) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-selected-contrast-hover, #255DCC);\n}\n\n:host(:not([theme])[facet-value-state=\"unselected\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][facet-value-state=\"unselected\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-unselected, #C2C3C4);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"unselected\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"unselected\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-unselected-contrast, #D9DADB);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"unselected\"]:hover) .facet-bars-value-bar-0,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"unselected\"]:hover) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-unselected-contrast-hover, #255DCC);\n}\n\n:host(:not([theme])[facet-value-state=\"muted\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][facet-value-state=\"muted\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-muted, #C2C3C4);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"muted\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"muted\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-muted-contrast, #D9DADB);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"muted\"]:hover) .facet-bars-value-bar-0,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"muted\"]:hover) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-muted-contrast-hover, #255DCC);\n}\n\n\n\n\n/* .facet-bars-value-bar-1 */\n\n:host(:not([theme])[facet-value-state=\"normal\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][facet-value-state=\"normal\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-normal, #C2C3C4);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"normal\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"normal\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-normal-contrast, #D9DADB);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"normal\"]:hover) .facet-bars-value-bar-1,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"normal\"]:hover) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-normal-contrast-hover, #C2C3C4);\n}\n\n:host(:not([theme])[facet-value-state=\"selected\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][facet-value-state=\"selected\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-selected, #C2C3C4);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"selected\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"selected\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-selected-contrast, #D9DADB);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"selected\"]:hover) .facet-bars-value-bar-1,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"selected\"]:hover) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-selected-contrast-hover, #C2C3C4);\n}\n\n:host(:not([theme])[facet-value-state=\"unselected\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][facet-value-state=\"unselected\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-unselected, #D9DADB);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"unselected\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"unselected\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-unselected-contrast, #EAEBEC);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"unselected\"]:hover) .facet-bars-value-bar-1,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"unselected\"]:hover) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-unselected-contrast-hover, #C4D9FC);\n}\n\n:host(:not([theme])[facet-value-state=\"muted\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][facet-value-state=\"muted\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-muted, #D9DADB);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"muted\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"muted\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-muted-contrast, #EAEBEC);\n}\n\n:host(:not([theme])[contrast=true][facet-value-state=\"muted\"]:hover) .facet-bars-value-bar-1,\n:host([theme=\"default\"][contrast=true][facet-value-state=\"muted\"]:hover) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-muted-contrast-hover, #C4D9FC);\n}\n\n\n\n\n/* facet-value-state=\"loading\" */\n\n:host(:not([theme])[facet-value-state=\"loading\"]) .facet-bars-value-background,\n:host([theme=\"default\"][facet-value-state=\"loading\"]) .facet-bars-value-background\n{\n    background-color: #F7F7F7;\n}\n\n:host(:not([theme])[facet-value-state=\"loading\"]) .facet-bars-value-bar-1,\n:host(:not([theme])[facet-value-state=\"loading\"]) .facet-bars-value-bar-0,\n:host([theme=\"default\"][facet-value-state=\"loading\"]) .facet-bars-value-bar-1,\n:host([theme=\"default\"][facet-value-state=\"loading\"]) .facet-bars-value-bar-0\n{\n    background-color: #ECECEC;\n}\n";
	var FacetBarsValueTimelineTheme = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n/* .facet-bars-value-background */\n:host([theme=\"timeline\"]) .facet-bars-value-background\n{\n    background-color: transparent;\n}\n\n/* .facet-bars-value-bar-0 */\n:host([theme=\"timeline\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-normal, #255DCC);\n}\n\n:host([theme=\"timeline\"]:hover) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-normal-contrast-hover, #73abf1);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"unselected\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-unselected, #73abf1);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"unselected\"]:hover) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-unselected-contrast-hover, #8dc3ff);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"muted\"]) .facet-bars-value-bar-0\n{\n    background-color: var(--facet-bars-0-muted, #D8D9DA);\n}\n\n/* .facet-bars-value-bar-1 */\n:host([theme=\"timeline\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-normal, #a4d1ff);\n}\n\n:host([theme=\"timeline\"]:hover) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-normal-contrast-hover, #b6e3ff);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"unselected\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-unselected, #a4d1ff);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"unselected\"]:hover) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-unselected-contrast-hover, #b6e3ff);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"muted\"]) .facet-bars-value-bar-1\n{\n    background-color: var(--facet-bars-1-muted, #D8D9DA);\n}\n\n/* .facet-bars-value-bar-2 */\n:host([theme=\"timeline\"]) .facet-bars-value-bar-2\n{\n    background-color: var(--facet-bars-2-normal, #D8D9DA);\n}\n\n:host([theme=\"timeline\"]:hover) .facet-bars-value-bar-2\n{\n    background-color: var(--facet-bars-2-normal-contrast-hover, #D8D9DA);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"unselected\"]) .facet-bars-value-bar-2\n{\n    background-color: var(--facet-bars-2-unselected, #D8D9DA);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"unselected\"]:hover) .facet-bars-value-bar-2\n{\n    background-color: var(--facet-bars-2-unselected-contrast-hover, #D8D9DA);\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"muted\"]) .facet-bars-value-bar-2\n{\n    background-color: var(--facet-bars-2-muted, #D8D9DA);\n}\n\n/* facet-value-state=\"loading\" */\n\n:host([theme=\"timeline\"][facet-value-state=\"loading\"]) .facet-bars-value-background\n{\n    background-color: #F0F1F2;\n}\n\n:host([theme=\"timeline\"][facet-value-state=\"loading\"]) .facet-bars-value-bar-1,\n:host([theme=\"timeline\"][facet-value-state=\"loading\"]) .facet-bars-value-bar-0\n{\n    background-color: #ECECEC;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	function getBarColorHostSelector$1(theme, state, index, contrast, hover) {
	  return ":host(".concat(theme).concat(contrast ? '[contrast=true]' : '', "[facet-value-state=\"").concat(state, "\"]").concat(hover ? ':hover' : '', ") .facet-bars-value-background .facet-bars-value-bar-").concat(index);
	}

	var kBarStylePrefix$1 = 'facet-bars-';
	var kBarStyleGenerators$1 = {
	  '-normal': function normal(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'normal', index, false, false), " { background-color:").concat(value, " }");
	  },
	  '-normal-contrast': function normalContrast(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'normal', index, true, false), " { background-color:").concat(value, " }");
	  },
	  '-normal-contrast-hover': function normalContrastHover(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'normal', index, true, true), " { background-color:").concat(value, " }");
	  },
	  '-selected': function selected(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'selected', index, false, false), " { background-color:").concat(value, " }");
	  },
	  '-selected-contrast': function selectedContrast(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'selected', index, true, false), " { background-color:").concat(value, " }");
	  },
	  '-selected-contrast-hover': function selectedContrastHover(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'selected', index, true, true), " { background-color:").concat(value, " }");
	  },
	  '-unselected': function unselected(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'unselected', index, false, false), " { background-color:").concat(value, " }");
	  },
	  '-unselected-contrast': function unselectedContrast(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'unselected', index, true, false), " { background-color:").concat(value, " }");
	  },
	  '-unselected-contrast-hover': function unselectedContrastHover(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'unselected', index, true, true), " { background-color:").concat(value, " }");
	  },
	  '-muted': function muted(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'muted', index, false, false), " { background-color:").concat(value, " }");
	  },
	  '-muted-contrast': function mutedContrast(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'muted', index, true, false), " { background-color:").concat(value, " }");
	  },
	  '-muted-contrast-hover': function mutedContrastHover(theme, index, value) {
	    return "".concat(getBarColorHostSelector$1(theme, 'muted', index, true, true), " { background-color:").concat(value, " }");
	  }
	};
	var kBarStyleSuffixes$1 = Object.keys(kBarStyleGenerators$1);
	var kFacetVarsValueNullData = {
	  ratio: 0
	};

	var FacetBarsValue = /*#__PURE__*/function (_FacetBlueprint) {
	  _inherits(FacetBarsValue, _FacetBlueprint);

	  var _super = _createSuper(FacetBarsValue);

	  function FacetBarsValue() {
	    var _this;

	    _classCallCheck(this, FacetBarsValue);

	    _this = _super.apply(this, arguments);
	    _this._data = kFacetVarsValueNullData;
	    _this.values = [];
	    _this.actionButtons = 2;
	    _this.clipLeft = 0;
	    _this.clipRight = 0;
	    _this.computedStyle = null;
	    return _this;
	  }

	  _createClass(FacetBarsValue, [{
	    key: "renderContent",
	    value: function renderContent() {
	      if (this.clipLeft > 0 || this.clipRight > 0) {
	        var clipStyle = {
	          'margin-left': "".concat((this.clipLeft * 100).toFixed(2), "%"),
	          'margin-right': "".concat((this.clipRight * 100).toFixed(2), "%")
	        };
	        return html$1(_templateObject$7(), styleMap(clipStyle), this.renderBars(), renderButtons(this));
	      }

	      return html$1(_templateObject2$6(), this.renderBars(), renderButtons(this));
	    }
	  }, {
	    key: "renderBars",
	    value: function renderBars() {
	      var result = [];

	      for (var i = 0, n = this.values.length; i < n; ++i) {
	        var value = this.values[i];

	        if (!isNaN(value)) {
	          var height = (Math.max(Math.min(value, 1), 0) * 100).toFixed(2);
	          var barClass = "facet-bars-value-bar-".concat(n - i - 1);
	          result.push(html$1(_templateObject3$4(), barClass, height, barClass));
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "computeStyle",
	    value: function computeStyle() {
	      if (this.computedStyle === null) {
	        var theme = this.getAttribute('theme');
	        var hostTheme = theme ? "[theme=\"".concat(theme, "\"]") : ':not([theme])';
	        var cssOptions = this.cssOptions;
	        var styles = [];
	        var n = this.values.length;
	        var i = 0;
	        var hasOption;

	        do {
	          hasOption = false;

	          for (var ii = 0, nn = kBarStyleSuffixes$1.length; ii < nn; ++ii) {
	            var option = "".concat(kBarStylePrefix$1).concat(i).concat(kBarStyleSuffixes$1[ii]);
	            var optionValue = cssOptions.read(option);

	            if (optionValue !== undefined) {
	              hasOption = true;
	              styles.push(kBarStyleGenerators$1[kBarStyleSuffixes$1[ii]](hostTheme, i, optionValue));
	            }
	          }
	        } while (++i < n || hasOption);

	        if (styles.length) {
	          this.computedStyle = html$1(_templateObject4$3(), styles);
	        } else {
	          this.computedStyle = undefined;
	        }
	      }

	      return this.computedStyle;
	    }
	  }, {
	    key: "data",
	    get: function get() {
	      return this._data;
	    },
	    set: function set(newData) {
	      var oldData = this._data;
	      this._data = newData;
	      this.requestUpdate('data', oldData);
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject5$3(), unsafeCSS(buttonsStyle), unsafeCSS(FacetBarsValueStyle), unsafeCSS(FacetBarsValueDefaultTheme), unsafeCSS(FacetBarsValueTimelineTheme)));

	      if (CSSOptions.supportsCSSVars) {
	        // add the style for 20 sub-bars, sorry future Dario, you'll probably have to make this number dynamic
	        // start at bar 2 since the css already has the proper style for the first two
	        for (var i = 2; i < 20; ++i) {
	          styles.push(css(_templateObject6$3(), i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i));
	        }
	      }

	      return styles;
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        data: {
	          type: Object
	        },
	        values: {
	          type: Array,
	          converter: {
	            fromAttribute: function fromAttribute(value) {
	              if (!value) {
	                return [];
	              }

	              var arr = JSON.parse(value);

	              for (var i = 0, n = arr.length; i < n; ++i) {
	                arr[i] = parseFloat(arr[i]);
	              }

	              return arr;
	            },
	            toAttribute: function toAttribute(value) {
	              return "[".concat(value.toString(), "]");
	            }
	          }
	        },
	        actionButtons: {
	          type: Number,
	          attribute: 'action-buttons'
	        },
	        clipLeft: {
	          type: Number
	        },
	        clipRight: {
	          type: Number
	        }
	      };
	    }
	  }]);

	  return FacetBarsValue;
	}(FacetBlueprint);

	FacetBarsValue = __decorate([customElement('facet-bars-value')], FacetBarsValue);

	function _templateObject6$4() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n        "]);

	  _templateObject6$4 = function _templateObject6() {
	    return data;
	  };

	  return data;
	}

	function _templateObject5$4() {
	  var data = _taggedTemplateLiteral(["\n            <", "\n                id=\"", "\"\n                theme=\"", "\"\n                facet-value-state=\"", "\"\n                action-buttons=\"", "\"\n                contrast=\"", "\"\n                .values=\"", "\"\n                .data=\"", "\"\n                .clipLeft=\"", "\"\n                .clipRight=\"", "\">\n            </", ">"]);

	  _templateObject5$4 = function _templateObject5() {
	    return data;
	  };

	  return data;
	}

	function _templateObject4$4() {
	  var data = _taggedTemplateLiteral(["\n                <facet-bars-value\n                    id=\"", "\"\n                    theme=\"", "\"\n                    facet-value-state=\"", "\"\n                    action-buttons=\"", "\"\n                    contrast=\"", "\"\n                    .values=\"", "\"\n                    .data=\"", "\"\n                    .clipLeft=\"", "\"\n                    .clipRight=\"", "\">\n                </facet-bars-value>"]);

	  _templateObject4$4 = function _templateObject4() {
	    return data;
	  };

	  return data;
	}

	function _templateObject3$5() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject3$5 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$7() {
	  var data = _taggedTemplateLiteral(["\n        <div\n            class=\"facet-bars-base-values-container\"\n            @mouseenter=\"", "\"\n            @mouseleave=\"", "\"\n        >\n            <slot name=\"values\"></slot>\n        </div>\n        "]);

	  _templateObject2$7 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$8() {
	  var data = _taggedTemplateLiteral([""]);

	  _templateObject$8 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var facetBarsBaseStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n:host {\n    display: flex;\n}\n\n.facet-bars-base-values-container {\n    height: 100%;\n    min-height: 64px;\n    display: flex;\n    align-items: stretch;\n    margin: 0 1px;\n}\n\n.facet-bars-base-values-container ::slotted(.facet-bars-base-container) {\n    flex-grow: 1;\n    position: relative;\n    display: flex;\n    flex-direction: row;\n    align-items: stretch;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var kFacetBarsBaseDefaultValues = [null, null, null, null, null, null, null, null, null, null];
	var kFacetBarsBaseNullView = [null, null];
	var kFacetBarsBaseNullDomain = [null, null];

	var kRangeValueHasChanged = function kRangeValueHasChanged(newVal, oldVal) {
	  if (!oldVal || !newVal) {
	    return oldVal !== newVal;
	  }

	  return newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1];
	};

	var kGetFilterValue = function kGetFilterValue(filter, index) {
	  return isNaN(filter[index]) ? filter[index].value : filter[index];
	};

	var kFilterValueHasChanged = function kFilterValueHasChanged(newVal, oldVal) {
	  if (kRangeValueHasChanged(newVal, oldVal)) {
	    if (newVal && oldVal) {
	      var newVal0 = kGetFilterValue(newVal, 0);
	      var newVal1 = kGetFilterValue(newVal, 1);
	      var oldVal0 = kGetFilterValue(oldVal, 0);
	      var oldVal1 = kGetFilterValue(oldVal, 1);
	      return newVal0 !== oldVal0 || newVal1 !== oldVal1;
	    }

	    return true;
	  }

	  return false;
	};

	var FacetBarsBase = /*#__PURE__*/function (_FacetContainer) {
	  _inherits(FacetBarsBase, _FacetContainer);

	  var _super = _createSuper(FacetBarsBase);

	  function FacetBarsBase() {
	    var _this;

	    _classCallCheck(this, FacetBarsBase);

	    _this = _super.apply(this, arguments);
	    _this.filter = null;
	    _this.selection = null;
	    _this.subselection = null;
	    _this.actionButtons = 0;
	    _this._values = kFacetBarsBaseDefaultValues;
	    _this._domain = kFacetBarsBaseNullDomain;
	    _this._view = kFacetBarsBaseNullView;
	    _this._activeView = _this._view;
	    _this._hover = false;
	    _this.nullDomain = [0, 0];
	    _this.nullView = [0, 0];
	    _this.valueKeys = Object.keys(kFacetBarsBaseDefaultValues).map(function (key) {
	      return parseInt(key, 10);
	    });
	    _this.viewValues = {};
	    return _this;
	  }

	  _createClass(FacetBarsBase, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(FacetBarsBase.prototype), "connectedCallback", this).call(this);

	      var values = this.createSlottedElement('values');

	      if (values) {
	        values.setAttribute('class', 'facet-bars-base-container');
	      }
	    }
	  }, {
	    key: "renderSlottedElements",
	    value: function renderSlottedElements() {
	      _get(_getPrototypeOf(FacetBarsBase.prototype), "renderSlottedElements", this).call(this);

	      var values = this.slottedElements.get('values');

	      if (values) {
	        this.renderSlottedElement(this.renderValues() || html$1(_templateObject$8()), values);
	      }
	    }
	  }, {
	    key: "setTemplateForTarget",
	    value: function setTemplateForTarget(target, template) {
	      _get(_getPrototypeOf(FacetBarsBase.prototype), "setTemplateForTarget", this).call(this, target, template);

	      template.addCustomAttribute('id');
	      template.addCustomAttribute('theme');
	      template.addCustomAttribute('facet-value-state');
	      template.addCustomAttribute('action-buttons');
	      template.addCustomAttribute('contrast');
	      template.addCustomAttribute('.values');
	      template.addCustomAttribute('.clipLeft');
	      template.addCustomAttribute('.clipRight');
	    }
	  }, {
	    key: "renderContent",
	    value: function renderContent() {
	      return html$1(_templateObject2$7(), this.handleMouseEvent, this.handleMouseEvent);
	    }
	  }, {
	    key: "renderValues",
	    value: function renderValues() {
	      var actionButtons = this.actionButtons.toString();
	      var view = this.view;
	      var values = this._values;
	      var htmlTemplate = this.getValuesHTML(this._getViewValues(values, view), actionButtons, view[0]);
	      this._activeView = view;
	      this.viewValues = values;
	      return html$1(_templateObject3$5(), htmlTemplate);
	    }
	  }, {
	    key: "getValuesHTML",
	    value: function getValuesHTML(values, actionButtons, offset) {
	      var _this2 = this;

	      var theme = this.barValueTheme;
	      var contrast = this.hover;
	      var id = 0;

	      var keyFunction = function keyFunction() {
	        return id++ + offset;
	      };

	      var htmlFunction = function htmlFunction(value, i) {
	        var computedState = _this2.computeValueState(i + offset);

	        var subselection = _this2.subselection ? _this2.subselection[i + offset] : null;
	        var overrideState = value === null || value.ratio === null ? 'loading' : null;
	        var type = value && value.type || 'facet-bars-value';

	        var template = _this2.templates.get(type);

	        var valuesArray = _this2.computeValuesArray(value || kFacetVarsValueNullData, subselection);

	        var domain = _this2.domain;
	        var clipLeft = i < domain[0] ? domain[0] - Math.floor(domain[0]) : 0;
	        var clipRight = i + 1 > domain[1] ? i + 1 - domain[1] : 0;

	        if (template) {
	          return template.getHTML(value || kFacetVarsValueNullData, {
	            'id': i + offset,
	            'theme': theme,
	            'facet-value-state': overrideState !== null ? overrideState : computedState,
	            'action-buttons': actionButtons,
	            'contrast': contrast,
	            '.values': valuesArray,
	            '.clipLeft': clipLeft,
	            '.clipRight': clipRight
	          });
	        } else if (type === 'facet-bars-value') {
	          return html$1(_templateObject4$4(), i + offset, theme, overrideState !== null ? overrideState : computedState, actionButtons, contrast, valuesArray, value || kFacetVarsValueNullData, clipLeft, clipRight);
	        }

	        return preHTML(_templateObject5$4(), type, i + offset, theme, overrideState !== null ? overrideState : computedState, actionButtons, contrast, valuesArray, value || kFacetVarsValueNullData, clipLeft, clipRight, type);
	      };

	      return repeat(values, keyFunction, htmlFunction);
	    }
	  }, {
	    key: "computeValueState",
	    value: function computeValueState(barIndex) {
	      var result = 'normal';

	      if (this.selection) {
	        if (barIndex >= Math.floor(this.selection[0]) && barIndex < Math.ceil(this.selection[1])) {
	          result = 'selected';
	        } else {
	          result = 'unselected';
	        }
	      }

	      if (this.filter) {
	        var min = Math.floor(kGetFilterValue(this.filter, 0));
	        var max = Math.ceil(kGetFilterValue(this.filter, 1));

	        if (barIndex < min || barIndex >= max) {
	          result = 'muted';
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "handleMouseEvent",
	    value: function handleMouseEvent(event) {
	      if ((event.type === 'mouseenter' || event.type === 'mouseleave') && event.target instanceof Element) {
	        this.hover = polyMatches(event.target, ':hover');
	      }
	    }
	  }, {
	    key: "computeValuesArray",
	    value: function computeValuesArray(value, subselection) {
	      var result = [];

	      if (value) {
	        result.push(value.ratio);

	        if (subselection !== null) {
	          var sub = Array.isArray(subselection) ? subselection : [subselection];
	          result.push.apply(result, _toConsumableArray(sub));
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "_getViewValues",
	    value: function _getViewValues(values, view) {
	      var result = [];

	      for (var i = view[0], n = view[view.length - 1]; i < n; ++i) {
	        if (values[i]) {
	          result.push(values[i]);
	        } else {
	          result.push(null);
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "values",
	    get: function get() {
	      return this._values;
	    },
	    set: function set(newData) {
	      var oldData = this._values;
	      this._values = newData;
	      this.valueKeys = Object.keys(this._values).map(function (key) {
	        return parseInt(key, 10);
	      });
	      this.valueKeys.sort(function (a, b) {
	        return a - b;
	      });
	      this.requestUpdate('values', oldData);
	    } // @ts-ignore

	  }, {
	    key: "domain",
	    get: function get() {
	      if (this._domain === kFacetBarsBaseNullDomain || this._domain === this.nullDomain) {
	        if (this.valueKeys.length) {
	          this.nullDomain[0] = this.valueKeys[0];
	          this.nullDomain[1] = this.valueKeys[this.valueKeys.length - 1] + 1;
	        } else {
	          this.nullDomain[0] = 0;
	          this.nullDomain[1] = 0;
	        }

	        this._domain = this.nullDomain;
	      }

	      return this._domain;
	    } // @ts-ignore
	    ,
	    set: function set(value) {
	      var oldValue = this._domain;

	      if (!value || value === kFacetBarsBaseNullDomain || value === this.nullDomain) {
	        this._domain = this.nullDomain;
	      } else {
	        this._domain = [Math.max(value[0], 0), Math.max(value[1], 0)];
	      }

	      this.requestUpdate('domain', oldValue);
	    } // @ts-ignore

	  }, {
	    key: "view",
	    get: function get() {
	      if (this._view === kFacetBarsBaseNullView || this._view === this.nullView) {
	        var domain = this.domain;
	        this.nullView[0] = Math.floor(domain[0]);
	        this.nullView[1] = Math.ceil(domain[1]);
	        this._view = this.nullView;
	      }

	      return this._view;
	    } // @ts-ignore
	    ,
	    set: function set(value) {
	      var oldValue = this._view;

	      if (!value || value === kFacetBarsBaseNullView || value === this.nullView) {
	        this._view = this.nullView;
	      } else {
	        this._view = [Math.max(value[0], 0), Math.max(value[1], 0)];
	      }

	      this.requestUpdate('view', oldValue);
	    }
	  }, {
	    key: "activeView",
	    get: function get() {
	      if (this._activeView === kFacetBarsBaseNullView) {
	        if (this._activeView !== this._view) {
	          return this.view;
	        } else if (this.valueKeys.length) {
	          var domain = this.domain;
	          return [Math.floor(domain[0]), Math.ceil(domain[1])];
	        }

	        return [0, 0];
	      }

	      return this._activeView;
	    }
	  }, {
	    key: "hover",
	    get: function get() {
	      return this._hover;
	    },
	    set: function set(value) {
	      var oldValue = this._hover;
	      this._hover = value;
	      this.requestUpdate('hover', oldValue);
	    }
	  }, {
	    key: "filterIndices",
	    get: function get() {
	      var filter = this.filter;

	      if (!filter) {
	        return null;
	      }

	      var filter0 = Math.floor(kGetFilterValue(filter, 0));
	      var filter1 = Math.floor(kGetFilterValue(filter, 1));
	      return [filter0, filter1];
	    }
	  }, {
	    key: "filterValues",
	    get: function get() {
	      var filter = this.filter;

	      if (!filter) {
	        return null;
	      }

	      var filter0 = kGetFilterValue(filter, 0);
	      var filter1 = kGetFilterValue(filter, 1);
	      return [filter0, filter1];
	    }
	  }, {
	    key: "barAreaElement",
	    get: function get() {
	      return this.slottedElements.get('values') || null;
	    }
	  }, {
	    key: "barValueTheme",
	    get: function get() {
	      return 'default';
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject6$4(), unsafeCSS(facetBarsBaseStyle)));
	      return styles;
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        values: {
	          type: Object
	        },
	        domain: {
	          type: Array,
	          hasChanged: kRangeValueHasChanged
	        },
	        view: {
	          type: Array,
	          hasChanged: kRangeValueHasChanged
	        },
	        filter: {
	          type: Array,
	          hasChanged: kFilterValueHasChanged
	        },
	        selection: {
	          type: Array,
	          hasChanged: kRangeValueHasChanged
	        },
	        subselection: {
	          type: Array
	        },
	        actionButtons: {
	          type: Number,
	          attribute: 'action-buttons'
	        }
	      };
	    }
	  }]);

	  return FacetBarsBase;
	}(FacetContainer);

	FacetBarsBase = __decorate([customElement('facet-bars-base')
	/* should not be instantiated as a custom element */
	], FacetBarsBase);

	function _templateObject4$5() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n        "]);

	  _templateObject4$5 = function _templateObject4() {
	    return data;
	  };

	  return data;
	}

	function _templateObject3$6() {
	  var data = _taggedTemplateLiteral(["<style>", "</style>"]);

	  _templateObject3$6 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$8() {
	  var data = _taggedTemplateLiteral(["\n        ", "\n        <slot name=\"labels\"></slot>\n        "]);

	  _templateObject2$8 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$9() {
	  var data = _taggedTemplateLiteral(["<span>", "</span>"]);

	  _templateObject$9 = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var facetBarsStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-blueprint-content {\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    padding: 4px 8px 4px 0;\n    margin: 0 16px;\n}\n\n.facet-blueprint-left {\n    border-left: 4px solid transparent;\n}\n\n:host(:hover) .facet-blueprint-left {\n    border-left: 4px solid var(--facet-bars-tick-color, #255DCC);\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var kDefaultData$2 = {
	  values: kFacetBarsBaseDefaultValues
	};

	var FacetBars = /*#__PURE__*/function (_FacetBarsBase) {
	  _inherits(FacetBars, _FacetBarsBase);

	  var _super = _createSuper(FacetBars);

	  function FacetBars() {
	    var _this;

	    _classCallCheck(this, FacetBars);

	    _this = _super.apply(this, arguments);
	    _this.disabled = false;
	    _this._data = kDefaultData$2;
	    _this.computedStyle = null;
	    return _this;
	  }

	  _createClass(FacetBars, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(FacetBars.prototype), "connectedCallback", this).call(this);

	      var labels = this.createSlottedElement('labels', 'facet-bars-labels');

	      if (labels) {
	        labels.setAttribute('id', 'facet-bars-labels');
	      }

	      if (!this.disabled) {
	        var selection = this.createSlottedElement('selection', 'facet-bars-selection');

	        if (selection) {
	          selection.setAttribute('id', 'facet-bars-selection');
	        }
	      }
	    }
	  }, {
	    key: "renderHeaderLabel",
	    value: function renderHeaderLabel() {
	      return html$1(_templateObject$9(), this.data.label);
	    }
	  }, {
	    key: "renderContent",
	    value: function renderContent() {
	      return html$1(_templateObject2$8(), _get(_getPrototypeOf(FacetBars.prototype), "renderContent", this).call(this));
	    }
	  }, {
	    key: "computeStyle",
	    value: function computeStyle() {
	      if (this.computedStyle === null) {
	        var theme = this.getAttribute('theme');
	        var hostTheme = theme ? "[theme=\"".concat(theme, "\"]") : ':not([theme])';
	        var cssOptions = this.cssOptions;
	        var styles = [];
	        var tickValue = cssOptions.read('facet-bars-tick-color');

	        if (tickValue !== undefined) {
	          styles.push(":host(".concat(hostTheme, ":hover) .facet-blueprint .facet-blueprint-left { border-left: 4px solid ").concat(tickValue, "; }"));
	        }

	        if (styles.length) {
	          this.computedStyle = html$1(_templateObject3$6(), styles);
	        } else {
	          this.computedStyle = undefined;
	        }
	      }

	      return this.computedStyle;
	    }
	  }, {
	    key: "data",
	    // @ts-ignore
	    get: function get() {
	      return this._data;
	    } // @ts-ignore
	    ,
	    set: function set(value) {
	      var oldValue = this._data;

	      if (!value || value === kDefaultData$2) {
	        this._data = kDefaultData$2;
	      } else {
	        this._data = value;
	      }

	      this.values = this._data.values;
	      this.requestUpdate('data', oldValue);
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject4$5(), unsafeCSS(facetBarsStyle)));
	      return styles;
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        data: {
	          type: Object
	        },
	        disabled: {
	          type: Boolean
	        }
	      };
	    }
	  }]);

	  return FacetBars;
	}(FacetBarsBase);

	FacetBars = __decorate([customElement('facet-bars')], FacetBars);

	function _templateObject11() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject11 = function _templateObject11() {
	    return data;
	  };

	  return data;
	}

	function _templateObject10() {
	  var data = _taggedTemplateLiteral(["\n        <div class=\"facet-bars-labels-marker\" style=\"left:\n        ", "%;\n        right:", "%\"\n        ></div>\n        "]);

	  _templateObject10 = function _templateObject10() {
	    return data;
	  };

	  return data;
	}

	function _templateObject9() {
	  var data = _taggedTemplateLiteral(["<div class=\"facet-bars-labels-tick\" style=\"left:", "%\"></div>"]);

	  _templateObject9 = function _templateObject9() {
	    return data;
	  };

	  return data;
	}

	function _templateObject8$1() {
	  var data = _taggedTemplateLiteral(["<div class=\"facet-bars-label\" style=\"right:calc(", "% - ", "px)\">", "</div>"]);

	  _templateObject8$1 = function _templateObject8() {
	    return data;
	  };

	  return data;
	}

	function _templateObject7$2() {
	  var data = _taggedTemplateLiteral(["<div class=\"facet-bars-label\" id=\"", "\" style=\"left:calc(", "% - ", "px)\">", "</div>"]);

	  _templateObject7$2 = function _templateObject7() {
	    return data;
	  };

	  return data;
	}

	function _templateObject6$5() {
	  var data = _taggedTemplateLiteral(["<div class=\"facet-bars-labels-tick\" id=\"", "\" style=\"left:", "%\"></div>"]);

	  _templateObject6$5 = function _templateObject6() {
	    return data;
	  };

	  return data;
	}

	function _templateObject5$5() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject5$5 = function _templateObject5() {
	    return data;
	  };

	  return data;
	}

	function _templateObject4$6() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject4$6 = function _templateObject4() {
	    return data;
	  };

	  return data;
	}

	function _templateObject3$7() {
	  var data = _taggedTemplateLiteral(["<div class=\"facet-bars-labels-text\">", "</div>"]);

	  _templateObject3$7 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$9() {
	  var data = _taggedTemplateLiteral(["<div class=\"facet-bars-labels-ticks\">", "</div>"]);

	  _templateObject2$9 = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$a() {
	  var data = _taggedTemplateLiteral(["\n                <div class=\"facet-bars-labels-row\">\n                    ", "\n                    ", "\n                </div>\n                "]);

	  _templateObject$a = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var FacetBarsLabelsStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n:host {\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n}\n\n.facet-bars-labels-row {\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n}\n\n.facet-bars-labels-ticks {\n    position: relative;\n    height: 9px;\n    margin-top: 2px;\n}\n\n.facet-bars-labels-tick {\n    position: absolute;\n    top: 0;\n    bottom: 3px;\n    width: 1px;\n    background-color: #B2B3B4;\n}\n\n.facet-bars-labels-marker {\n    position: absolute;\n    top: 3px;\n    bottom: 0;\n    border-top: 1px solid #D9DADB;\n}\n\n.facet-bars-labels-marker:after {\n    content: '';\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    background-color: #D9DADB;\n    left: 50%;\n}\n\n.facet-bars-labels-text {\n    position: relative;\n    height: 10px;\n    margin-top: 2px;\n    color: #B2B3B4;\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 10px;\n    line-height: 10px;\n}\n\n.facet-bars-label {\n    position: absolute;\n    user-select: none;\n    -ms-user-select: none;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var kBooleanConverter = {
	  fromAttribute: function fromAttribute(value) {
	    try {
	      return JSON.parse(value);
	    } catch (e) {
	      return Boolean(value);
	    }
	  },
	  toAttribute: function toAttribute(value) {
	    return JSON.stringify(Boolean(value));
	  }
	};

	var FacetBarsLabels = /*#__PURE__*/function (_FacetPlugin) {
	  _inherits(FacetBarsLabels, _FacetPlugin);

	  var _super = _createSuper(FacetBarsLabels);

	  function FacetBarsLabels() {
	    var _this;

	    _classCallCheck(this, FacetBarsLabels);

	    _this = _super.apply(this, arguments);
	    _this.automaticLabels = false;
	    _this.drawDelimiters = true;
	    _this.facet = null;
	    _this.labelCanvas = document.createElement('canvas');
	    _this.labelContext = _this.labelCanvas.getContext('2d');
	    return _this;
	  }

	  _createClass(FacetBarsLabels, [{
	    key: "hostUpdated",
	    value: function hostUpdated(changedProperties) {
	      _get(_getPrototypeOf(FacetBarsLabels.prototype), "hostUpdated", this).call(this, changedProperties);

	      if (changedProperties.has('view') || changedProperties.has('domain') || changedProperties.has('data')) {
	        this.requestUpdate();
	      }
	    }
	  }, {
	    key: "hostChanged",
	    value: function hostChanged(host) {
	      if (host instanceof FacetBarsBase) {
	        this.facet = host;
	      } else {
	        this.facet = null;
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var facet = this.facet;

	      if (facet) {
	        var rows = [];
	        var barArea = facet.barAreaElement;

	        if (barArea) {
	          var view = facet.view;
	          var values = facet.values;
	          var viewLength = view[1] - view[0];
	          var width = barArea.scrollWidth;
	          var barStep = width / viewLength;
	          var barStepPercentage = 100 / viewLength;

	          for (var i = -1, v = view[0] - 1, n = view[1]; v <= n; ++i, ++v) {
	            this._processValue(values[v], rows, this.automaticLabels, v, i, barStepPercentage);
	          }

	          for (var _i = 0, _n = rows.length; _i < _n; ++_i) {
	            this._processRow(rows[_i], width, barStep, barStepPercentage);
	          }
	        } else {
	          requestAnimationFrame(function () {
	            return facet.requestUpdate();
	          });
	        }

	        var result = [];

	        for (var _i2 = 0, _n2 = rows.length; _i2 < _n2; ++_i2) {
	          result.push(html$1(_templateObject$a(), rows[_i2].ticks.length ? html$1(_templateObject2$9(), rows[_i2].ticks) : undefined, rows[_i2].labels.length ? html$1(_templateObject3$7(), rows[_i2].labels) : undefined));
	        }

	        return html$1(_templateObject4$6(), result);
	      }

	      return html$1(_templateObject5$5(), undefined);
	    }
	  }, {
	    key: "_processValue",
	    value: function _processValue(value, rows, drawIndexLabels, valueIndex, barIndex, barStepPercentage) {
	      var labels = this._getLabels(value, valueIndex, drawIndexLabels);

	      var percentagePosition = (barStepPercentage * barIndex).toFixed(2);

	      if (labels) {
	        var row;
	        var label;

	        for (var i = 0, n = Math.max(labels.length, rows.length); i < n; ++i) {
	          if (rows.length < i + 1) {
	            rows.push({
	              ticks: [],
	              labels: [],
	              sections: [],
	              section: null
	            });
	          }

	          row = rows[i];
	          label = labels[i];

	          if (!label) {
	            this._capRow(rows[i], percentagePosition);
	          } else if (row.section && row.section.label === label) {
	            row.section.max = barIndex + 1;
	          } else {
	            row.section = {
	              label: label,
	              min: barIndex,
	              max: barIndex + 1
	            };
	            row.sections.push(row.section);

	            if (label && this.drawDelimiters && barIndex >= 0) {
	              row.ticks.push(html$1(_templateObject6$5(), valueIndex, percentagePosition));
	            }
	          }
	        }
	      } else {
	        this._capRows(rows, percentagePosition);
	      }
	    }
	  }, {
	    key: "_processRow",
	    value: function _processRow(row, width, barStep, barStepPercentage) {
	      var padding = 3;
	      var halfBar = barStep * 0.5;
	      var maxBars = Math.round(width / barStep);
	      var left = 0;
	      var right = width;
	      var center;
	      var offset;
	      var pixelWidth;
	      var halfPixelWidth;
	      var section;
	      var position;
	      var pixelMin;
	      var pixelMax;

	      if (row.sections.length) {
	        for (var l = 0, r = row.sections.length - 1, n = (l + r) * 0.5; l <= n; ++l, --r) {
	          /* left */
	          section = row.sections[l];

	          if (section.label && section.max > 0) {
	            pixelWidth = this._computeLabelWidth(section.label);
	            halfPixelWidth = pixelWidth * 0.5 + padding;
	            pixelMin = Math.max(section.min * barStep + halfBar, 0);
	            pixelMax = Math.min(section.max * barStep - halfBar, width);
	            center = (pixelMin + pixelMax) * 0.5;

	            if (left === 0 || center - halfPixelWidth >= left && center + halfPixelWidth <= right) {
	              this._addMarker(section, barStepPercentage, row.ticks);

	              position = (center / width * 100).toFixed(2);
	              offset = Math.round(Math.min(pixelWidth * 0.5, center));
	              row.labels.push(html$1(_templateObject7$2(), section.label, position, offset, section.label));
	              left = center + pixelWidth - offset + padding;
	            }
	          }
	          /* right */


	          if (l !== r) {
	            section = row.sections[r];

	            if (section.label && section.min < maxBars) {
	              pixelWidth = this._computeLabelWidth(section.label);
	              halfPixelWidth = pixelWidth * 0.5 + padding;
	              pixelMin = Math.max(section.min * barStep + halfBar, 0);
	              pixelMax = Math.min(section.max * barStep - halfBar, width);
	              center = (pixelMin + pixelMax) * 0.5;

	              if (right === width || center - halfPixelWidth >= left && center + halfPixelWidth <= right) {
	                this._addMarker(section, barStepPercentage, row.ticks);

	                position = (100 - center / width * 100).toFixed(2);
	                offset = Math.round(Math.min(pixelWidth * 0.5, width - center));
	                row.labels.push(html$1(_templateObject8$1(), position, offset, section.label));
	                right = center - pixelWidth + offset - padding;
	              }
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: "_capRows",
	    value: function _capRows(rows, percentage) {
	      for (var i = 0, n = rows.length; i < n; i++) {
	        this._capRow(rows[i], percentage);
	      }
	    }
	  }, {
	    key: "_capRow",
	    value: function _capRow(row, percentage) {
	      var section = row.section;

	      if (section && section.label && this.drawDelimiters) {
	        row.ticks.push(html$1(_templateObject9(), percentage));
	      }

	      row.section = null;
	    }
	  }, {
	    key: "_getLabels",
	    value: function _getLabels(value, index, drawIndexLabels) {
	      if (value) {
	        if (value.label) {
	          return Array.isArray(value.label) ? value.label : [value.label];
	        }

	        return drawIndexLabels ? ["".concat(index)] : null;
	      }

	      return null;
	    }
	  }, {
	    key: "_computeLabelWidth",
	    value: function _computeLabelWidth(label) {
	      this.labelContext.font = '10px "IBM Plex Sans", sans-serif';
	      return this.labelContext.measureText(label).width;
	    }
	  }, {
	    key: "_addMarker",
	    value: function _addMarker(section, barStepPercentage, ticks) {
	      ticks.push(html$1(_templateObject10(), Math.max(section.min * barStepPercentage + barStepPercentage * 0.5, 0).toFixed(2), Math.max(100 - section.max * barStepPercentage + barStepPercentage * 0.5, 0).toFixed(2)));
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      return [css(_templateObject11(), unsafeCSS(FacetBarsLabelsStyle))];
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        automaticLabels: {
	          type: Boolean,
	          attribute: 'automatic-labels',
	          converter: kBooleanConverter
	        },
	        drawDelimiters: {
	          type: Boolean,
	          attribute: 'draw-delimiters',
	          converter: kBooleanConverter
	        }
	      };
	    }
	  }]);

	  return FacetBarsLabels;
	}(FacetPlugin);

	FacetBarsLabels = __decorate([customElement('facet-bars-labels')], FacetBarsLabels);

	function _templateObject$b() {
	  var data = _taggedTemplateLiteral(["\n            <style>", "</style>\n            ", "\n            <div class=\"facet-bars-selection-computed\" style=\"", "\">\n                <div\n                    class=\"facet-bars-selection-handle facet-bars-selection-handle-left\"\n                    style=\"", "\"\n                    @mousedown=\"", "\">\n                </div>\n                <div\n                    class=\"facet-bars-selection-clear-button\"\n                    style=\"", "\"\n                    @mousedown=\"", "\">\n                </div>\n                <div\n                    class=\"facet-bars-selection-handle facet-bars-selection-handle-right\"\n                    style=\"", "\"\n                    @mousedown=\"", "\">\n                </div>\n            </div>\n            <div class=\"facet-bars-selection-user\" style=\"", "\"></div>\n            "]);

	  _templateObject$b = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var FacetBarsSelectionStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-bars-selection-user {\n    position: absolute;\n    border: 1px dashed black;\n    pointer-events: none;\n    user-select: none;\n    -ms-user-select: none;\n}\n\n.facet-bars-selection-computed {\n    position: absolute;\n    background-color: rgba(37,93,204, 0.15);\n    border: 1px solid #255DCC;\n    pointer-events: none;\n    user-select: none;\n    -ms-user-select: none;\n    top: 0;\n    bottom: 0;\n}\n\n.facet-bars-selection-handle {\n    position: absolute;\n    top: calc(50% - 9px);\n    width: 0;\n    height: 15px;\n    cursor: ew-resize;\n    pointer-events: all;\n\n    border-top: 4px solid transparent;\n    border-bottom: 4px solid transparent;\n}\n\n.facet-bars-selection-handle:before {\n    content: '';\n    position: absolute;\n    width: 1px;\n    top: -4px;\n    bottom: -4px;\n    background-color: transparent;\n}\n\n.facet-bars-selection-handle:after {\n    content: '';\n    position: absolute;\n    top: 2px;\n    bottom: 2px;\n    width: 1px;\n    background-color: #EBF1FC;\n}\n\n.facet-bars-selection-handle-left {\n    left: -7px;\n    border-right: 5px solid #255DCC;\n}\n\n.facet-bars-selection-handle-left:after {\n    left: 2px;\n}\n\n.facet-bars-selection-handle-left:before {\n    left: 5px;\n}\n\n.facet-bars-selection-handle-right {\n    right: -7px;\n    border-left: 5px solid #255DCC;\n}\n\n.facet-bars-selection-handle-right:after {\n    right: 2px;\n}\n\n.facet-bars-selection-handle-right:before {\n    right: 5px;\n}\n\n.facet-bars-selection-clear-button {\n    position: absolute;\n    right: -11px;\n    top: -1px;\n    width: 9px;\n    height: 9px;\n    background-color: #255DCC;\n    border-radius: 2px;\n    cursor: pointer;\n    pointer-events: all;\n}\n\n.facet-bars-selection-clear-button:after {\n    content: '';\n    position: absolute;\n    left: 4px;\n    top: 1px;\n    height: 7px;\n    width: 1px;\n    background-color: white;\n    transform: rotate(45deg);\n}\n\n.facet-bars-selection-clear-button:before {\n    content: '';\n    position: absolute;\n    left: 4px;\n    top: 1px;\n    height: 7px;\n    width: 1px;\n    background-color: white;\n    transform: rotate(-45deg);\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetBarsSelection = /*#__PURE__*/function (_FacetPlugin) {
	  _inherits(FacetBarsSelection, _FacetPlugin);

	  var _super = _createSuper(FacetBarsSelection);

	  function FacetBarsSelection() {
	    var _this;

	    _classCallCheck(this, FacetBarsSelection);

	    _this = _super.apply(this, arguments);
	    _this.facet = null;
	    _this.facetRenderValues = null;
	    _this.handleMouseEventBound = _this.handleMouseEvent.bind(_assertThisInitialized(_this));
	    _this.handleLocalMouseEventBound = _this.handleLocalMouseEvent.bind(_assertThisInitialized(_this));
	    _this.mouse = {
	      tracking: null,
	      startX: 0,
	      startY: 0,
	      endX: 0,
	      endY: 0,
	      offset: 0
	    };
	    return _this;
	  }

	  _createClass(FacetBarsSelection, [{
	    key: "hostUpdated",
	    value: function hostUpdated(changedProperties) {
	      _get(_getPrototypeOf(FacetBarsSelection.prototype), "hostUpdated", this).call(this, changedProperties);

	      if (changedProperties.has('view') || changedProperties.has('domain') || changedProperties.has('data')) {
	        this.requestUpdate();
	      }
	    }
	  }, {
	    key: "hostChanged",
	    value: function hostChanged(host) {
	      if (host instanceof FacetBarsBase) {
	        this.facet = host;
	        var barArea = this.facet.barAreaElement;

	        if (barArea) {
	          barArea.addEventListener('mousedown', this.handleMouseEventBound);
	          barArea.addEventListener('mousemove', this.handleMouseEventBound);
	          barArea.addEventListener('mouseup', this.handleMouseEventBound);
	          barArea.addEventListener('mouseleave', this.handleMouseEventBound);
	        }

	        this.monkeyPatchRenderer(this.facet);
	      } else {
	        if (this.facet) {
	          var _barArea = this.facet.barAreaElement;

	          if (_barArea) {
	            _barArea.removeEventListener('mousedown', this.handleMouseEventBound);

	            _barArea.removeEventListener('mousemove', this.handleMouseEventBound);

	            _barArea.removeEventListener('mouseup', this.handleMouseEventBound);

	            _barArea.removeEventListener('mouseleave', this.handleMouseEventBound);
	          }

	          this.monkeyUnpatchRenderer(this.facet);
	        }

	        this.facet = null;
	      }
	    }
	  }, {
	    key: "createRenderRoot",
	    value: function createRenderRoot() {
	      return this;
	    }
	  }, {
	    key: "renderSelection",
	    value: function renderSelection(renderedValues) {
	      var host = this.facet;

	      if (host) {
	        var barArea = host.barAreaElement;
	        var userStyle = 'display:none';
	        var computedStyle = 'display:none';
	        var leftStyle = 'display:block';
	        var rightStyle = 'display:block';

	        if (barArea) {
	          host.style.cursor = 'default';

	          if (this.mouse.tracking) {
	            var rect = barArea.getBoundingClientRect();
	            var left = Math.min(this.mouse.startX, this.mouse.endX) - rect.left;
	            var right = rect.right - Math.max(this.mouse.startX, this.mouse.endX);

	            if (this.mouse.tracking === 'draw') {
	              var top = Math.min(this.mouse.startY, this.mouse.endY) - rect.top;
	              var bottom = rect.bottom - Math.max(this.mouse.startY, this.mouse.endY);
	              userStyle = "top:".concat(top, "px;bottom:").concat(bottom, "px;left:").concat(left, "px;right:").concat(right, "px;");
	              host.style.cursor = 'crosshair';
	            } else {
	              host.style.cursor = 'ew-resize';
	            }

	            var values = host.values;
	            var view = host.view;
	            var viewLength = view[1] - view[0];
	            var width = rect.right - rect.left;
	            var barStep = width / viewLength;
	            var barStepPercentage = 100 / viewLength;
	            var leftIndex = Math.floor(left / barStep);
	            var rightIndex = viewLength - Math.floor(right / barStep);

	            while (leftIndex < rightIndex && !values[leftIndex + view[0]]) {
	              ++leftIndex;
	            }

	            while (rightIndex > leftIndex && !values[rightIndex + view[0] - 1]) {
	              --rightIndex;
	            }

	            if (leftIndex !== rightIndex) {
	              var leftPercentage = barStepPercentage * leftIndex;
	              var rightPercentage = 100 - barStepPercentage * rightIndex;
	              var displayLeft = Math.min(Math.max(0, leftPercentage), 100).toFixed(2);
	              var displayRight = Math.min(Math.max(0, rightPercentage), 100).toFixed(2);
	              computedStyle = "left:".concat(displayLeft, "%;right:").concat(displayRight, "%;");

	              if (parseFloat(rightPercentage.toFixed(2)) < 0) {
	                computedStyle += 'border-right:none;';
	                rightStyle = 'display:none';
	              }

	              if (parseFloat(leftPercentage.toFixed(2)) < 0) {
	                computedStyle += 'border-left:none;';
	                leftStyle = 'display:none';
	              }
	            }
	          } else if (host.selection) {
	            var _view = host.view;
	            var selection = host.selection;

	            var _viewLength = _view[1] - _view[0];

	            var _barStepPercentage = 100 / _viewLength;

	            var _leftPercentage = _barStepPercentage * (selection[0] - _view[0]);

	            var _rightPercentage = _barStepPercentage * (_view[1] - selection[1]);

	            var _displayLeft = Math.min(Math.max(0, _leftPercentage), 100).toFixed(2);

	            var _displayRight = Math.min(Math.max(0, _rightPercentage), 100).toFixed(2);

	            if (_rightPercentage <= 100 && _leftPercentage <= 100) {
	              computedStyle = "left:".concat(_displayLeft, "%;right:").concat(_displayRight, "%;");

	              if (_rightPercentage < 0) {
	                computedStyle += 'border-right:none;';
	                rightStyle = 'display:none';
	              }

	              if (_leftPercentage < 0) {
	                computedStyle += 'border-left:none;';
	                leftStyle = 'display:none';
	              }
	            }
	          }
	        }

	        return html$1(_templateObject$b(), FacetBarsSelectionStyle, renderedValues, computedStyle, leftStyle, this.handleLocalMouseEventBound, rightStyle, this.handleLocalMouseEventBound, rightStyle, this.handleLocalMouseEventBound, userStyle);
	      }

	      return undefined;
	    }
	  }, {
	    key: "handleMouseEvent",
	    value: function handleMouseEvent(mouseEvent) {
	      var host = this.facet;

	      if (host && host.barAreaElement) {
	        switch (mouseEvent.type) {
	          case 'mousedown':
	            this.mouse.tracking = 'draw';
	            this.mouse.startX = this.mouse.endX = mouseEvent.clientX;
	            this.mouse.startY = this.mouse.endY = mouseEvent.clientY;
	            this.mouse.offset = 0;
	            mouseEvent.stopPropagation();
	            mouseEvent.preventDefault();
	            host.requestUpdate();
	            break;

	          case 'mousemove':
	            if (this.mouse.tracking) {
	              this.mouse.endX = mouseEvent.clientX;
	              this.mouse.endY = mouseEvent.clientY;

	              if (this.mouse.endX > this.mouse.startX) {
	                this.mouse.endX = Math.max(this.mouse.startX, this.mouse.endX - this.mouse.offset);
	              } else if (this.mouse.endX < this.mouse.startX) {
	                this.mouse.endX = Math.min(this.mouse.startX, this.mouse.endX + this.mouse.offset);
	              }

	              mouseEvent.stopPropagation();
	              mouseEvent.preventDefault();
	              host.requestUpdate();
	            }

	            break;

	          case 'mouseup':
	          case 'mouseleave':
	            if (this.mouse.tracking) {
	              this.mouse.tracking = null;
	              this.setSelection(host);
	              mouseEvent.stopPropagation();
	              mouseEvent.preventDefault();
	              host.requestUpdate();
	            }

	            break;
	        }
	      }
	    }
	  }, {
	    key: "handleLocalMouseEvent",
	    value: function handleLocalMouseEvent(evt) {
	      var host = this.facet;

	      if (host && evt.type === 'mousedown' && evt.target instanceof HTMLElement) {
	        evt.stopPropagation();
	        evt.preventDefault();

	        if (evt.target.className.includes('facet-bars-selection-clear-button')) {
	          host.selection = null;
	        } else {
	          var barArea = host.barAreaElement;
	          var selection = host.selection;

	          if (barArea && selection) {
	            var view = host.view;
	            var rect = barArea.getBoundingClientRect();
	            var viewLength = view[1] - view[0];
	            var width = rect.right - rect.left;
	            var barStep = width / viewLength;

	            if (evt.target.className.includes('facet-bars-selection-handle-left')) {
	              this.mouse.tracking = 'resize';
	              this.mouse.startX = rect.left + barStep * (selection[1] - view[0]) - 1;
	              this.mouse.startY = rect.top;
	              this.mouse.endX = rect.left + barStep * (selection[0] - view[0]) + 1;
	              this.mouse.endY = evt.clientY;
	              this.mouse.offset = this.mouse.endX - evt.clientX;
	            } else if (evt.target.className.includes('facet-bars-selection-handle-right')) {
	              this.mouse.tracking = 'resize';
	              this.mouse.startX = rect.left + barStep * (selection[0] - view[0]) + 1;
	              this.mouse.startY = rect.top;
	              this.mouse.endX = rect.left + barStep * (selection[1] - view[0]) - 1;
	              this.mouse.endY = evt.clientY;
	              this.mouse.offset = evt.clientX - this.mouse.endX;
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: "setSelection",
	    value: function setSelection(host) {
	      var barArea = host.barAreaElement;

	      if (barArea) {
	        var rect = barArea.getBoundingClientRect();
	        var left = Math.min(this.mouse.startX, this.mouse.endX) - rect.left;
	        var right = Math.max(this.mouse.startX, this.mouse.endX) - rect.left;
	        var view = host.view;
	        var viewLength = view[1] - view[0];
	        var width = rect.right - rect.left;
	        var barStep = width / viewLength;
	        var values = host.values;
	        var leftIndex = Math.floor(left / barStep) + view[0];
	        var rightIndex = Math.ceil(right / barStep) + view[0];

	        while (leftIndex < rightIndex && !values[leftIndex]) {
	          ++leftIndex;
	        }

	        while (rightIndex > leftIndex && !values[rightIndex - 1]) {
	          --rightIndex;
	        }

	        if (leftIndex !== rightIndex) {
	          host.selection = [leftIndex, rightIndex];
	        } else {
	          host.selection = null;
	        }
	      }
	    }
	  }, {
	    key: "monkeyPatchRenderer",
	    value: function monkeyPatchRenderer(facet) {
	      var _this2 = this;

	      var facetAny = facet;

	      if (typeof facetAny.renderValues === 'function') {
	        this.facetRenderValues = facetAny.renderValues;

	        facetAny.renderValues = function () {
	          if (_this2.facetRenderValues) {
	            return _this2.renderSelection(_this2.facetRenderValues.call(facetAny));
	          }

	          return undefined;
	        };
	      }
	    }
	  }, {
	    key: "monkeyUnpatchRenderer",
	    value: function monkeyUnpatchRenderer(facet) {
	      var facetAny = facet;

	      if (this.facetRenderValues && typeof this.facetRenderValues === 'function') {
	        facetAny.renderValues = this.facetRenderValues;
	        this.facetRenderValues = null;
	      }
	    }
	  }]);

	  return FacetBarsSelection;
	}(FacetPlugin);

	FacetBarsSelection = __decorate([customElement('facet-bars-selection')], FacetBarsSelection);

	function _templateObject3$8() {
	  var data = _taggedTemplateLiteral(["\n            ", "\n        "]);

	  _templateObject3$8 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$a() {
	  var data = _taggedTemplateLiteral(["\n        ", "\n        <slot name=\"labels\"></slot>\n        "]);

	  _templateObject2$a = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$c() {
	  var data = _taggedTemplateLiteral(["\n        <div class=\"facet-timeline-content\">\n            ", "\n            <slot name=\"scrollbar\"></slot>\n        </div>\n        "]);

	  _templateObject$c = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var FacetTimelineStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-blueprint {\n    background-color: #F0F1F2;\n    overflow: hidden;\n}\n\n.facet-blueprint-content {\n    padding: 2px 15px 0 10px;\n}\n\n.facet-timeline-content {\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    position: relative;\n}\n\n.facet-bars-base-values-container {\n    min-height: 34px;\n}\n\n.facet-bars-base-values-container ::slotted(.facet-bars-base-container) {\n    z-index: 1;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetTimeline = /*#__PURE__*/function (_FacetBarsBase) {
	  _inherits(FacetTimeline, _FacetBarsBase);

	  var _super = _createSuper(FacetTimeline);

	  function FacetTimeline() {
	    var _this;

	    _classCallCheck(this, FacetTimeline);

	    _this = _super.apply(this, arguments);
	    _this.disabled = false;
	    _this._data = kFacetBarsBaseDefaultValues;
	    return _this;
	  }

	  _createClass(FacetTimeline, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(FacetTimeline.prototype), "connectedCallback", this).call(this);

	      var labels = this.createSlottedElement('labels', 'facet-timeline-labels');

	      if (labels) {
	        labels.setAttribute('id', 'facet-timeline-labels');
	      }

	      if (!this.disabled) {
	        var selection = this.createSlottedElement('selection', 'facet-timeline-selection');

	        if (selection) {
	          selection.setAttribute('id', 'facet-timeline-selection');
	        }
	      }
	    }
	  }, {
	    key: "renderContent",
	    value: function renderContent() {
	      return html$1(_templateObject$c(), this.renderTimelineContent());
	    }
	  }, {
	    key: "renderTimelineContent",
	    value: function renderTimelineContent() {
	      return html$1(_templateObject2$a(), _get(_getPrototypeOf(FacetTimeline.prototype), "renderContent", this).call(this));
	    }
	  }, {
	    key: "data",
	    // @ts-ignore
	    get: function get() {
	      return this._data;
	    } // @ts-ignore
	    ,
	    set: function set(value) {
	      var oldValue = this._data;

	      if (!value || value === kFacetBarsBaseDefaultValues) {
	        this._data = kFacetBarsBaseDefaultValues;
	      } else {
	        this._data = value;
	      }

	      this.values = this._data;
	      this.requestUpdate('data', oldValue);
	    }
	  }, {
	    key: "barValueTheme",
	    get: function get() {
	      return 'timeline';
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      var styles = this.getSuperStyles();
	      styles.push(css(_templateObject3$8(), unsafeCSS(FacetTimelineStyle)));
	      return styles;
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        data: {
	          type: Object
	        },
	        disabled: {
	          type: Boolean
	        }
	      };
	    }
	  }]);

	  return FacetTimeline;
	}(FacetBarsBase);

	FacetTimeline = __decorate([customElement('facet-timeline')], FacetTimeline);

	function _templateObject5$6() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject5$6 = function _templateObject5() {
	    return data;
	  };

	  return data;
	}

	function _templateObject4$7() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject4$7 = function _templateObject4() {
	    return data;
	  };

	  return data;
	}

	function _templateObject3$9() {
	  var data = _taggedTemplateLiteral(["\n            <div class=\"facet-timeline-labels-container\">\n                ", "\n                ", "\n            </div>"]);

	  _templateObject3$9 = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$b() {
	  var data = _taggedTemplateLiteral(["<div class=\"facet-timeline-labels-tick\" style=\"height:", "px;left:", "%\"></div>"]);

	  _templateObject2$b = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$d() {
	  var data = _taggedTemplateLiteral(["\n                                <div\n                                class=\"facet-timeline-labels-label\"\n                                style=\"top:", "px;left:", "%;font-weight:", ";color:", ";transform:translate(", "%,0);\">\n                                    ", "\n                                </div>"]);

	  _templateObject$d = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var FacetTimelineLabelsStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n:host {\n    pointer-events: none;\n}\n\n.facet-timeline-labels-container {\n    width: 100%;\n    height: 25px;\n    border-top: 1px solid #A7A7A8;\n    position: relative;\n    z-index: 1;\n}\n\n.facet-timeline-labels-tick {\n    position: absolute;\n    width: 1px;\n    top: 0;\n    background-color: #A7A7A8;\n}\n\n.facet-timeline-labels-label {\n    position: absolute;\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 10px;\n    font-style: normal;\n    line-height: 13px;\n    white-space: nowrap;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetTimelineLabels = /*#__PURE__*/function (_FacetPlugin) {
	  _inherits(FacetTimelineLabels, _FacetPlugin);

	  var _super = _createSuper(FacetTimelineLabels);

	  function FacetTimelineLabels() {
	    var _this;

	    _classCallCheck(this, FacetTimelineLabels);

	    _this = _super.apply(this, arguments);
	    _this.resizeObserver = new ResizeObserver(function (entries) {
	      entries.forEach(function (e) {
	        var label = e.target;
	        label.resizeCallback(e.contentRect);
	      });
	    });
	    _this.facet = null;
	    _this.labelCanvas = document.createElement('canvas');
	    _this.labelContext = _this.labelCanvas.getContext('2d');
	    _this.renderedWidth = null;
	    return _this;
	  }

	  _createClass(FacetTimelineLabels, [{
	    key: "hostUpdated",
	    value: function hostUpdated(changedProperties) {
	      _get(_getPrototypeOf(FacetTimelineLabels.prototype), "hostUpdated", this).call(this, changedProperties);

	      if (changedProperties.has('view') || changedProperties.has('domain') || changedProperties.has('data')) {
	        this.requestUpdate();
	      }
	    }
	  }, {
	    key: "hostChanged",
	    value: function hostChanged(host) {
	      if (host instanceof FacetBarsBase) {
	        this.facet = host;
	      } else {
	        this.facet = null;
	      }
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(FacetTimelineLabels.prototype), "connectedCallback", this).call(this);

	      this.resizeObserver.observe(this);
	    }
	  }, {
	    key: "disconnectedCallback",
	    value: function disconnectedCallback() {
	      _get(_getPrototypeOf(FacetTimelineLabels.prototype), "disconnectedCallback", this).call(this);

	      this.resizeObserver.unobserve(this);
	    }
	  }, {
	    key: "resizeCallback",
	    value: function resizeCallback(domRect) {
	      if (this.renderedWidth && domRect.width !== this.renderedWidth) {
	        this.requestUpdate();
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var facet = this.facet;

	      if (facet) {
	        var ticks = [];
	        var labels = [];
	        var barArea = facet.barAreaElement;

	        if (barArea) {
	          var domain = facet.domain;
	          var view = facet.view;
	          var values = facet.values;
	          var viewLength = view[1] - view[0];
	          var width = barArea.getBoundingClientRect().width;
	          var barStep = width / viewLength;
	          var barStepPercentage = 100 / viewLength;
	          var labelLevels = [];
	          var padding = 5;
	          var renderedWidth = 0;

	          for (var v = view[0], n = view[1] - 1; v <= n; ++v) {
	            var value = values[v];
	            var i = v - view[0];
	            var tickHeight = 2;

	            if (v >= domain[0] && v <= domain[1]) {
	              if (value && value.label) {
	                // get the label for the value
	                var label = Array.isArray(value.label) ? value.label : [value.label]; // if we are not keeping track of all the levels in the label, initialize them

	                if (labelLevels.length < label.length) {
	                  for (var ii = labelLevels.length, nn = label.length; ii < nn; ++ii) {
	                    labelLevels[ii] = '';
	                  }
	                } // check which level should be rendered


	                var renderLevel = -1;

	                for (var _ii = label.length - 1; _ii >= 0; --_ii) {
	                  if (label[_ii] !== labelLevels[_ii]) {
	                    renderLevel = _ii;
	                    break;
	                  }
	                } // if a level should be rendered, check if there's enough space to render it


	                if (renderLevel >= 0 && renderedWidth <= barStep * i) {
	                  var labelWidth = this.computeLabelWidth(label[renderLevel]);
	                  var hasSpace = false;
	                  var offset = 0;
	                  var offsetPercent = 0;
	                  var labelPosition = 0;

	                  if (i === 0) {
	                    hasSpace = true;
	                    labelPosition = 0;
	                    offset = padding;
	                    offsetPercent = 0;
	                  } else if (barStep * i + labelWidth * 0.5 > width && renderedWidth <= width - labelWidth - padding) {
	                    hasSpace = true;
	                    labelPosition = width;
	                    offset = labelWidth + padding * 2;
	                    offsetPercent = -100;
	                  } else if (renderedWidth <= barStep * i - labelWidth * 0.5 - padding && renderedWidth + labelWidth + padding < width) {
	                    hasSpace = true;
	                    labelPosition = barStep * i;
	                    offset = labelWidth * 0.5 + padding;
	                    offsetPercent = -50;
	                  }

	                  if (hasSpace) {
	                    tickHeight += renderLevel * 2 + 2;
	                    labelLevels[renderLevel] = label[renderLevel];
	                    renderedWidth = labelPosition + labelWidth + padding * 2 - offset;
	                    var positionPercent = (labelPosition / width * 100).toFixed(2);
	                    var labelWeight = renderLevel ? '600' : 'normal';
	                    var labelColor = renderLevel ? '#666768' : '#A7A7A8';
	                    labels.push(html$1(_templateObject$d(), tickHeight, positionPercent, labelWeight, labelColor, offsetPercent, label[renderLevel]));
	                  }
	                }
	              }

	              ticks.push(html$1(_templateObject2$b(), tickHeight, (barStepPercentage * i).toFixed(2)));
	            }
	          }

	          this.renderedWidth = renderedWidth;
	        }

	        return html$1(_templateObject3$9(), ticks, labels);
	      }

	      return html$1(_templateObject4$7(), undefined);
	    }
	  }, {
	    key: "computeLabelWidth",
	    value: function computeLabelWidth(label) {
	      this.labelContext.font = '10px "IBM Plex Sans", sans-serif';
	      return this.labelContext.measureText(label).width;
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      return [css(_templateObject5$6(), unsafeCSS(FacetTimelineLabelsStyle))];
	    }
	  }]);

	  return FacetTimelineLabels;
	}(FacetPlugin);

	FacetTimelineLabels = __decorate([customElement('facet-timeline-labels')], FacetTimelineLabels);

	function _templateObject$e() {
	  var data = _taggedTemplateLiteral(["\n            <style>", "</style>\n            <div class=\"facet-timeline-filter-handle-track\"></div>\n            ", "\n            <div class=\"facet-timeline-selection-computed\" style=\"", "\"></div>\n            <div class=\"facet-timeline-selection-user\" style=\"", "\"></div>\n            <div class=\"facet-timeline-filter-computed\" display-border=\"", "\" style=\"", "\">\n                <div\n                    class=\"facet-timeline-filter-handle facet-timeline-filter-handle-left\"\n                    style=\"", "\"\n                    @mousedown=\"", "\">\n                </div>\n                <div\n                    class=\"facet-timeline-filter-handle facet-timeline-filter-handle-right\"\n                    style=\"", "\"\n                    @mousedown=\"", "\">\n                </div>\n                <div\n                    class=\"facet-timeline-date-label facet-timeline-date-label-left\"\n                    style=\"", "\"\n                    @click=\"", "\"\n                    >\n                    ", "\n                </div>\n                <div\n                    class=\"facet-timeline-date-label facet-timeline-date-label-right\"\n                    style=\"", "\"\n                    @click=\"", "\"\n                    >\n                    ", "\n                </div>\n            </div>\n            "]);

	  _templateObject$e = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var FacetTimelineSelectionStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-timeline-filter-handle-track {\n    height: 16px;\n    pointer-events: none;\n}\n\n.facet-timeline-filter-computed {\n    position: absolute;\n    pointer-events: none;\n    user-select: none;\n    -ms-user-select: none;\n    top: 0;\n    bottom: 0;\n    padding: inherit;\n    margin: -2px -2px 0;\n}\n\n.facet-timeline-filter-computed:before {\n    content: '';\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    background-color: white;\n    z-index: 0;\n}\n\n.facet-timeline-filter-computed:after {\n    content: '';\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    border-top: 2px solid #FFC107;\n    border-left: 2px solid #FFC107;\n    border-right: 2px solid #FFC107;\n    z-index: 2;\n}\n\n.facet-timeline-filter-computed[display-border*=\"no-right\"]:after {\n    border-right: none;\n}\n\n.facet-timeline-filter-computed[display-border*=\"no-left\"]:after {\n    border-left: none;\n}\n\n.facet-timeline-filter-computed[display-border*=\"no-border\"]:after {\n    border: none;\n}\n\n.facet-timeline-filter-handle {\n    position: absolute;\n    top: 0;\n    width: 8px;\n    height: 18px;\n    cursor: ew-resize;\n    pointer-events: all;\n\n    background-color: #FFC107;\n\n    z-index: 1;\n}\n\n.facet-timeline-filter-handle:before {\n    content: '';\n    position: absolute;\n    top: 3px;\n    bottom: 3px;\n    width: 1px;\n    border-left: 1px solid white;\n    border-right: 1px solid white;\n}\n\n.facet-timeline-filter-handle-left {\n    left: -8px;\n    border-radius: 2px 0 0 2px;\n}\n\n.facet-timeline-filter-handle-left:before {\n    left: 3px;\n}\n\n.facet-timeline-filter-handle-right {\n    right: -8px;\n    border-radius: 0 2px 2px 0;\n}\n\n.facet-timeline-filter-handle-right:before {\n    right: 3px;\n}\n\n.facet-timeline-date-label {\n    position: absolute;\n    top: 2px;\n\n    color: #050D5C;\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 12px;\n    font-style: normal;\n    font-weight: 600;\n    line-height: 16px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n\n    z-index: 1;\n    cursor: pointer;\n    pointer-events: all;\n}\n\n.facet-timeline-date-label-left {\n    text-align: left;\n}\n\n.facet-timeline-date-label-right {\n    text-align: right;\n}\n\n.facet-timeline-selection-user {\n    position: absolute;\n    border: 1px dashed black;\n    pointer-events: none;\n    user-select: none;\n    -ms-user-select: none;\n    z-index: 1;\n}\n\n.facet-timeline-selection-computed {\n    position: absolute;\n    background-color: rgba(37,93,204, 0.15);\n    border: 1px solid #255DCC;\n    pointer-events: none;\n    user-select: none;\n    -ms-user-select: none;\n    z-index: 1;\n}\n\n:host([filter-handle-track=false]) .facet-timeline-filter-handle-track {\n    height: 2px;\n}\n:host([filter-handle-track=false]) .facet-timeline-date-label {\n    text-shadow:\n        -.5px -.5px 0 white,\n        .5px -.5px 0 white,\n        -.5px .5px 0 white,\n        .5px .5px 0 white;\n}\n:host([filter-labels-interactive=false]) .facet-timeline-date-label {\n    color: black;\n    pointer-events: none;\n    font-size: 10px;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetTimelineSelection = /*#__PURE__*/function (_FacetPlugin) {
	  _inherits(FacetTimelineSelection, _FacetPlugin);

	  var _super = _createSuper(FacetTimelineSelection);

	  function FacetTimelineSelection() {
	    var _this;

	    _classCallCheck(this, FacetTimelineSelection);

	    _this = _super.apply(this, arguments);
	    _this.facet = null;
	    _this.facetRenderContent = null;
	    _this.labelCanvas = document.createElement('canvas');
	    _this.labelContext = _this.labelCanvas.getContext('2d');
	    _this.boundMouseHandler = _this.handleMouseEvent.bind(_assertThisInitialized(_this));
	    _this.boundLocalMouseHandler = _this.handleLocalMouseEvent.bind(_assertThisInitialized(_this));
	    _this.mouse = {
	      tracking: null,
	      cursor: null,
	      startX: 0,
	      startY: 0,
	      endX: 0,
	      endY: 0,
	      offset: 0
	    };
	    return _this;
	  }

	  _createClass(FacetTimelineSelection, [{
	    key: "hostUpdated",
	    value: function hostUpdated(changedProperties) {
	      _get(_getPrototypeOf(FacetTimelineSelection.prototype), "hostUpdated", this).call(this, changedProperties);

	      if (changedProperties.has('view') || changedProperties.has('domain') || changedProperties.has('data') || changedProperties.has('filter')) {
	        this.requestUpdate();
	      }
	    }
	  }, {
	    key: "hostChanged",
	    value: function hostChanged(host) {
	      if (this.facet) {
	        window.document.removeEventListener('mousemove', this.boundMouseHandler);
	        window.document.removeEventListener('mouseup', this.boundMouseHandler);
	        window.document.removeEventListener('mouseleave', this.boundMouseHandler);
	        var barArea = this.facet.barAreaElement;

	        if (barArea) {
	          barArea.removeEventListener('mousedown', this.boundMouseHandler);
	        }

	        this.monkeyUnpatchRenderer(this.facet);
	      }

	      if (host instanceof FacetTimeline) {
	        this.facet = host;
	        window.document.addEventListener('mousemove', this.boundMouseHandler);
	        window.document.addEventListener('mouseup', this.boundMouseHandler);
	        window.document.addEventListener('mouseleave', this.boundMouseHandler);
	        var _barArea = this.facet.barAreaElement;

	        if (_barArea) {
	          _barArea.addEventListener('mousedown', this.boundMouseHandler);
	        }

	        this.monkeyPatchRenderer(this.facet);
	      } else {
	        this.facet = null;
	      }
	    }
	  }, {
	    key: "createRenderRoot",
	    value: function createRenderRoot() {
	      return this;
	    }
	  }, {
	    key: "renderPlugin",
	    value: function renderPlugin(renderedValues) {
	      var facet = this.facet;

	      if (facet) {
	        var barArea = facet.barAreaElement;
	        var filterInfo = this.computeFilterRenderInfo(facet, barArea);
	        var selectionInfo = this.computeSelectionRenderInfo(facet, barArea);

	        if (this.mouse.cursor) {
	          facet.style.cursor = this.mouse.cursor;
	        } else {
	          facet.style.removeProperty('cursor');
	        }

	        return html$1(_templateObject$e(), FacetTimelineSelectionStyle, renderedValues, styleMap(selectionInfo.style), styleMap(selectionInfo.userBoxStyle), filterInfo.displayBorder, styleMap(filterInfo.style), styleMap(filterInfo.minHandleStyle), this.boundLocalMouseHandler, styleMap(filterInfo.maxHandleStyle), this.boundLocalMouseHandler, styleMap(filterInfo.minLabelStyle), this.minFilterDateClicked, filterInfo.minLabel, styleMap(filterInfo.maxLabelStyle), this.maxFilterDateClicked, filterInfo.maxLabel);
	      }

	      return undefined;
	    }
	  }, {
	    key: "computeSelectionRenderInfo",
	    value: function computeSelectionRenderInfo(facet, barArea) {
	      var result = {
	        style: {
	          display: 'none'
	        },
	        userBoxStyle: {
	          display: 'none'
	        }
	      };

	      if (facet && barArea) {
	        var rect = barArea.getBoundingClientRect();
	        var width = rect.right - rect.left;
	        var view = facet.view;
	        var values = facet.values;
	        var viewLength = view[1] - view[0];
	        var barStep = width / viewLength;
	        var timelineContent = facet.renderRoot.querySelector('.facet-timeline-content');
	        var timelineBB = timelineContent ? timelineContent.getBoundingClientRect() : rect;

	        if (this.mouse.tracking === 'selection-draw') {
	          var filterValues = facet.filterValues;
	          var minLocation = rect.left;
	          var maxLocation = rect.left;
	          var minIndex;
	          var maxIndex;

	          if (filterValues) {
	            minLocation = rect.left + Math.max(filterValues[0] - view[0], 0) * barStep;
	            maxLocation = rect.left + (Math.min(filterValues[1], view[1]) - view[0]) * barStep;
	            minIndex = Math.max(Math.floor(filterValues[0]) - view[0], 0);
	            maxIndex = Math.min(view[1] - view[0], Math.ceil(filterValues[1]) - view[0]);
	          } else {
	            // minLocation += 0; // no need
	            maxLocation += (view[1] - view[0]) * barStep;
	            minIndex = 0;
	            maxIndex = view[1] - view[0];
	          }

	          var left = Math.max(Math.min(this.mouse.startX, this.mouse.endX), minLocation) - rect.left;
	          var right = rect.right - Math.min(Math.max(this.mouse.startX, this.mouse.endX), maxLocation);
	          var top = Math.max(Math.min(this.mouse.startY, this.mouse.endY), rect.top) - timelineBB.top;
	          var bottom = timelineBB.bottom - Math.min(Math.max(this.mouse.startY, this.mouse.endY), rect.bottom);
	          result.userBoxStyle = {
	            display: 'block',
	            top: "".concat(top, "px"),
	            bottom: "".concat(bottom, "px"),
	            left: "".concat(left, "px"),
	            right: "".concat(right, "px")
	          };
	          var barStepPercentage = 100 / viewLength;
	          var leftIndex = Math.max(Math.floor(left / barStep), minIndex);
	          var rightIndex = Math.min(viewLength - Math.floor(right / barStep), maxIndex);

	          while (leftIndex < rightIndex && !values[leftIndex + view[0]]) {
	            ++leftIndex;
	          }

	          while (rightIndex > leftIndex && !values[rightIndex + view[0] - 1]) {
	            --rightIndex;
	          }

	          if (leftIndex !== rightIndex) {
	            var leftBoundary = filterValues ? Math.max(filterValues[0], leftIndex) : leftIndex;
	            var rightBoundary = filterValues ? Math.min(filterValues[1], rightIndex) : rightIndex;
	            var leftPercentage = barStepPercentage * leftBoundary;
	            var rightPercentage = 100 - barStepPercentage * rightBoundary;
	            var displayLeft = Math.min(Math.max(0, leftPercentage), 100).toFixed(2);
	            var displayRight = Math.min(Math.max(0, rightPercentage), 100).toFixed(2);
	            result.style = {
	              display: 'block',
	              left: "".concat(displayLeft, "%"),
	              right: "".concat(displayRight, "%"),
	              top: "".concat(rect.top - timelineBB.top - 2, "px"),
	              bottom: "".concat(timelineBB.bottom - rect.bottom - 1, "px")
	            };
	          }
	        } else if (facet.selection) {
	          var selection = facet.selection;
	          var _filterValues = facet.filterValues;

	          var _barStepPercentage = 100 / viewLength;

	          var _leftBoundary = _filterValues ? Math.max(_filterValues[0], selection[0]) : selection[0];

	          var _rightBoundary = _filterValues ? Math.min(_filterValues[1], selection[1]) : selection[1];

	          var _leftPercentage = _barStepPercentage * (_leftBoundary - view[0]);

	          var _rightPercentage = _barStepPercentage * (view[1] - _rightBoundary);

	          var _displayLeft = Math.min(Math.max(0, _leftPercentage), 100).toFixed(2);

	          var _displayRight = Math.min(Math.max(0, _rightPercentage), 100).toFixed(2);

	          if (selection[1] >= view[0] && selection[0] <= view[1]) {
	            var style = {
	              display: 'block',
	              left: "".concat(_displayLeft, "%"),
	              right: "".concat(_displayRight, "%"),
	              top: "".concat(rect.top - timelineBB.top - 2, "px"),
	              bottom: "".concat(timelineBB.bottom - rect.bottom - 1, "px")
	            };

	            if (selection[0] < view[0]) {
	              style.borderLeft = 'none';
	            }

	            if (selection[1] > view[1]) {
	              style.borderRight = 'none';
	            }

	            result.style = style;
	          }
	        }
	      }

	      return result;
	    }
	  }, {
	    key: "computeFilterRenderInfo",
	    value: function computeFilterRenderInfo(facet, barArea) {
	      var result = {
	        style: {
	          display: 'none'
	        },
	        displayBorder: ';',
	        minHandleStyle: {
	          display: 'block'
	        },
	        maxHandleStyle: {
	          display: 'block'
	        },
	        minLabel: null,
	        maxLabel: null,
	        minLabelStyle: {
	          display: 'none'
	        },
	        maxLabelStyle: {
	          display: 'none'
	        },
	        filterWidth: 0,
	        outerLeftWidth: 0,
	        outerRightWidth: 0
	      };

	      if (facet && barArea) {
	        if (this.mouse.tracking === 'filter-resize') {
	          this.computeFilterRenderInfoResize(result, facet, barArea);
	        } else if (facet.filter) {
	          this.computeFilterRenderInfoFilter(result, facet, barArea);
	        } else {
	          result.style = {
	            display: 'block',
	            left: '0',
	            right: '0'
	          };
	          result.displayBorder = 'no-border';
	          result.minHandleStyle = {
	            display: 'none'
	          };
	          result.maxHandleStyle = {
	            display: 'none'
	          };
	        }

	        this.computeFilterLabelsRenderInfo(result);
	      }

	      return result;
	    }
	  }, {
	    key: "computeFilterRenderInfoResize",
	    value: function computeFilterRenderInfoResize(filterInfo, facet, barArea) {
	      var rect = barArea.getBoundingClientRect();
	      var width = rect.right - rect.left;
	      var view = facet.view;
	      var values = facet.values;
	      var viewLength = view[1] - view[0];
	      var barStep = width / viewLength;
	      var left = Math.min(this.mouse.startX, this.mouse.endX) - rect.left;
	      var right = rect.right - Math.max(this.mouse.startX, this.mouse.endX);
	      var barStepPercentage = 100 / viewLength;
	      var leftIndex = Math.floor(left / barStep);
	      var rightIndex = viewLength - Math.floor(right / barStep);

	      while (leftIndex < rightIndex && !values[leftIndex + view[0]]) {
	        ++leftIndex;
	      }

	      while (rightIndex > leftIndex && !values[rightIndex + view[0] - 1]) {
	        --rightIndex;
	      }

	      if (leftIndex !== rightIndex) {
	        var leftBar = facet.data[view[0] + leftIndex];
	        var rightBar = facet.data[view[0] + rightIndex - 1];
	        var domain = facet.domain;
	        leftIndex = Math.max(leftIndex, domain[0]);
	        rightIndex = Math.min(rightIndex, domain[1]);
	        var leftPercentage = barStepPercentage * leftIndex;
	        var rightPercentage = 100 - barStepPercentage * rightIndex;
	        var displayLeft = Math.min(Math.max(0, leftPercentage), 100).toFixed(2);
	        var displayRight = Math.min(Math.max(0, rightPercentage), 100).toFixed(2);
	        filterInfo.style = {
	          display: 'block',
	          left: "".concat(displayLeft, "%"),
	          right: "".concat(displayRight, "%")
	        };
	        filterInfo.outerLeftWidth = Math.max(0, barStep * leftIndex);
	        filterInfo.outerRightWidth = Math.max(0, width - barStep * rightIndex);
	        filterInfo.filterWidth = width - filterInfo.outerLeftWidth - filterInfo.outerRightWidth;

	        if (parseFloat(rightPercentage.toFixed(2)) < 0) {
	          filterInfo.maxLabel = 'âââ';
	          filterInfo.displayBorder += 'no-right;';
	          filterInfo.maxHandleStyle = {
	            display: 'none'
	          };
	        } else if (rightBar) {
	          filterInfo.maxLabel = rightBar.maxDateLabel;
	        } else {
	          filterInfo.maxLabel = null;
	        }

	        if (parseFloat(leftPercentage.toFixed(2)) < 0) {
	          filterInfo.minLabel = 'âââ';
	          filterInfo.displayBorder += 'no-left;';
	          filterInfo.minHandleStyle = {
	            display: 'none'
	          };
	        } else if (leftBar) {
	          filterInfo.minLabel = leftBar.minDateLabel;
	        } else {
	          filterInfo.minLabel = null;
	        }
	      }
	    }
	  }, {
	    key: "computeFilterRenderInfoFilter",
	    value: function computeFilterRenderInfoFilter(filterInfo, facet, barArea) {
	      var rect = barArea.getBoundingClientRect();
	      var width = rect.right - rect.left;
	      var view = facet.view;
	      var values = facet.values;
	      var viewLength = view[1] - view[0];
	      var barStep = width / viewLength;
	      var filter = facet.filter;
	      var filterValues = facet.filterValues;
	      var barStepPercentage = 100 / viewLength;
	      var leftPercentage = barStepPercentage * (filterValues[0] - view[0]);
	      var rightPercentage = barStepPercentage * (view[1] - filterValues[1]);
	      var displayLeft = Math.min(Math.max(0, leftPercentage), 100).toFixed(2);
	      var displayRight = Math.min(Math.max(0, rightPercentage), 100).toFixed(2);
	      var leftIndex = Math.floor(filterValues[0]);
	      var rightIndex = Math.ceil(filterValues[1]);

	      while (leftIndex < rightIndex && !values[leftIndex]) {
	        ++leftIndex;
	      }

	      while (rightIndex > leftIndex && !values[rightIndex - 1]) {
	        --rightIndex;
	      }

	      if (leftIndex !== rightIndex) {
	        var leftBar = facet.data[leftIndex];
	        var rightBar = facet.data[rightIndex - 1];

	        if (rightPercentage <= 100 && leftPercentage <= 100) {
	          filterInfo.style = {
	            display: 'block',
	            left: "".concat(displayLeft, "%"),
	            right: "".concat(displayRight, "%")
	          };
	          filterInfo.outerLeftWidth = Math.max(0, barStep * (filterValues[0] - view[0]));
	          filterInfo.outerRightWidth = Math.max(0, width - barStep * (filterValues[1] - view[0]));
	          filterInfo.filterWidth = width - filterInfo.outerLeftWidth - filterInfo.outerRightWidth;

	          if (rightPercentage < 0) {
	            filterInfo.maxLabel = 'âââ';
	            filterInfo.displayBorder += 'no-right;';
	            filterInfo.maxHandleStyle = {
	              display: 'none'
	            };
	          } else if (isNaN(filter[1])) {
	            filterInfo.maxLabel = filter[1].label;
	          } else if (rightBar) {
	            filterInfo.maxLabel = rightBar.maxDateLabel;
	          } else {
	            filterInfo.maxLabel = 'âââ';
	          }

	          if (leftPercentage < 0) {
	            filterInfo.minLabel = 'âââ';
	            filterInfo.displayBorder += 'no-left;';
	            filterInfo.minHandleStyle = {
	              display: 'none'
	            };
	          } else if (isNaN(filter[0])) {
	            filterInfo.minLabel = filter[0].label;
	          } else if (leftBar) {
	            filterInfo.minLabel = leftBar.minDateLabel;
	          } else {
	            filterInfo.minLabel = 'âââ';
	          }
	        }
	      }
	    }
	  }, {
	    key: "computeFilterLabelsRenderInfo",
	    value: function computeFilterLabelsRenderInfo(filterInfo) {
	      if (filterInfo.minLabel && filterInfo.maxLabel) {
	        var minDateWidth = this.computeLabelWidth(filterInfo.minLabel);
	        var maxDateWidth = this.computeLabelWidth(filterInfo.maxLabel);
	        var dateLabelsPadding = 15;
	        /* px */

	        if (filterInfo.filterWidth > minDateWidth + maxDateWidth + dateLabelsPadding) {
	          filterInfo.minLabelStyle = {
	            display: 'block',
	            left: '4px'
	          };
	          filterInfo.maxLabelStyle = {
	            display: 'block',
	            right: '4px'
	          };
	        } else if (filterInfo.outerLeftWidth < minDateWidth && filterInfo.outerRightWidth < maxDateWidth) {
	          filterInfo.minLabelStyle = {
	            display: 'block',
	            left: '4px',
	            width: "".concat(filterInfo.filterWidth * 0.5, "px")
	          };
	          filterInfo.maxLabelStyle = {
	            display: 'block',
	            right: '4px',
	            width: "".concat(filterInfo.filterWidth * 0.5, "px")
	          };
	        } else if (filterInfo.outerLeftWidth < minDateWidth) {
	          filterInfo.minLabelStyle = {
	            display: 'block',
	            left: '4px',
	            width: "".concat(Math.min(minDateWidth + dateLabelsPadding, Math.max(filterInfo.filterWidth - dateLabelsPadding, 0)), "px")
	          };
	          filterInfo.maxLabelStyle = {
	            display: 'block',
	            right: '-10px',
	            transform: 'translate(100%,0)'
	          };
	        } else if (filterInfo.outerRightWidth < maxDateWidth) {
	          filterInfo.minLabelStyle = {
	            display: 'block',
	            left: '-10px',
	            transform: 'translate(-100%,0)'
	          };
	          filterInfo.maxLabelStyle = {
	            display: 'block',
	            right: '4px',
	            width: "".concat(Math.min(maxDateWidth + dateLabelsPadding, Math.max(filterInfo.filterWidth - dateLabelsPadding, 0)), "px")
	          };
	        } else {
	          filterInfo.minLabelStyle = {
	            display: 'block',
	            left: '-10px',
	            transform: 'translate(-100%,0)'
	          };
	          filterInfo.maxLabelStyle = {
	            display: 'block',
	            right: '-10px',
	            transform: 'translate(100%,0)'
	          };
	        }
	      }
	    }
	  }, {
	    key: "handleMouseEvent",
	    value: function handleMouseEvent(evt) {
	      var host = this.facet;

	      if (host) {
	        var barArea = host.barAreaElement;

	        if (barArea) {
	          var mouseEvent = evt;

	          switch (mouseEvent.type) {
	            case 'mousedown':
	              mouseEvent.stopPropagation();
	              mouseEvent.preventDefault();

	              if (this.isPointInSelectionArea(mouseEvent.clientX, mouseEvent.clientY, barArea, host)) {
	                this.mouse.tracking = 'selection-draw';
	                this.mouse.cursor = 'crosshair';
	                this.mouse.startX = this.mouse.endX = mouseEvent.clientX;
	                this.mouse.startY = this.mouse.endY = mouseEvent.clientY;
	                this.mouse.offset = 0;
	                host.requestUpdate();
	              }

	              break;

	            case 'mousemove':
	              if (this.mouse.tracking) {
	                this.mouse.endX = mouseEvent.clientX;
	                this.mouse.endY = mouseEvent.clientY;

	                if (this.mouse.endX > this.mouse.startX) {
	                  this.mouse.endX = Math.max(this.mouse.startX, this.mouse.endX - this.mouse.offset);
	                } else if (this.mouse.endX < this.mouse.startX) {
	                  this.mouse.endX = Math.min(this.mouse.startX, this.mouse.endX + this.mouse.offset);
	                }

	                mouseEvent.stopPropagation();
	                mouseEvent.preventDefault();
	                host.requestUpdate();
	              } else if (host.filterValues) {
	                var newCursor = null;

	                if (this.isPointInSelectionArea(mouseEvent.clientX, mouseEvent.clientY, barArea, host)) {
	                  newCursor = 'crosshair';
	                }

	                if (this.mouse.cursor !== newCursor) {
	                  this.mouse.cursor = newCursor;
	                  host.requestUpdate();
	                }
	              }

	              break;

	            case 'mouseleave':
	            case 'mouseup':
	              if (this.mouse.tracking === 'filter-resize') {
	                this.setFilter(host);
	                host.requestUpdate();
	              } else if (this.mouse.tracking === 'selection-draw') {
	                this.setSelection(host);
	                host.requestUpdate();
	              }

	              mouseEvent.stopPropagation();
	              mouseEvent.preventDefault();
	              this.mouse.tracking = null;
	              break;
	          }
	        }
	      }
	    }
	  }, {
	    key: "handleLocalMouseEvent",
	    value: function handleLocalMouseEvent(evt) {
	      var host = this.facet;

	      if (host && evt.type === 'mousedown' && evt.button === 0 && evt.target instanceof HTMLElement) {
	        evt.stopPropagation();
	        evt.preventDefault();

	        if (evt.target.className.includes('facet-timeline-filter-clear-button')) {
	          host.filter = null;
	        } else {
	          var barArea = host.barAreaElement;
	          var filterValues = host.filterValues;

	          if (barArea && filterValues) {
	            var view = host.view;
	            var rect = barArea.getBoundingClientRect();
	            var viewLength = view[1] - view[0];
	            var width = rect.right - rect.left;
	            var barStep = width / viewLength;

	            if (evt.target.className.includes('facet-timeline-filter-handle-left')) {
	              this.mouse.tracking = 'filter-resize';
	              this.mouse.cursor = 'ew-resize';
	              this.mouse.startX = rect.left + barStep * (filterValues[1] - view[0]) - 1;
	              this.mouse.startY = rect.top;
	              this.mouse.endX = rect.left + barStep * (filterValues[0] - view[0]) + 1;
	              this.mouse.endY = evt.clientY;
	              this.mouse.offset = this.mouse.endX - evt.clientX;
	            } else if (evt.target.className.includes('facet-timeline-filter-handle-right')) {
	              this.mouse.tracking = 'filter-resize';
	              this.mouse.cursor = 'ew-resize';
	              this.mouse.startX = rect.left + barStep * (filterValues[0] - view[0]) + 1;
	              this.mouse.startY = rect.top;
	              this.mouse.endX = rect.left + barStep * (filterValues[1] - view[0]) - 1;
	              this.mouse.endY = evt.clientY;
	              this.mouse.offset = evt.clientX - this.mouse.endX;
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: "minFilterDateClicked",
	    value: function minFilterDateClicked(event) {
	      this.dispatchEvent(new CustomEvent('timeline-interaction', {
	        bubbles: false,
	        detail: {
	          type: 'min-filter-label-clicked',
	          el: event.currentTarget
	        }
	      }));
	    }
	  }, {
	    key: "maxFilterDateClicked",
	    value: function maxFilterDateClicked(event) {
	      this.dispatchEvent(new CustomEvent('timeline-interaction', {
	        bubbles: false,
	        detail: {
	          type: 'max-filter-label-clicked',
	          el: event.currentTarget
	        }
	      }));
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(host) {
	      var barArea = host.barAreaElement;

	      if (barArea) {
	        var rect = barArea.getBoundingClientRect();
	        var left = Math.min(this.mouse.startX, this.mouse.endX) - rect.left;
	        var right = Math.max(this.mouse.startX, this.mouse.endX) - rect.left;
	        var view = host.view;
	        var viewLength = view[1] - view[0];
	        var width = rect.right - rect.left;
	        var barStep = width / viewLength;
	        var values = host.values;
	        var leftIndex = Math.floor(left / barStep) + view[0];
	        var rightIndex = Math.ceil(right / barStep) + view[0];

	        while (leftIndex < rightIndex && !values[leftIndex]) {
	          ++leftIndex;
	        }

	        while (rightIndex > leftIndex && !values[rightIndex - 1]) {
	          --rightIndex;
	        }

	        if (leftIndex !== rightIndex) {
	          var domain = host.domain;
	          leftIndex = Math.max(leftIndex, domain[0]);
	          rightIndex = Math.min(rightIndex, domain[1]);
	          host.filter = [leftIndex, rightIndex];
	          var selection = host.selection;

	          if (selection) {
	            if (selection[1] <= leftIndex || selection[0] >= rightIndex) {
	              host.selection = null;
	            } else if (selection[0] < leftIndex || selection[1] > rightIndex) {
	              host.selection = [Math.max(selection[0], leftIndex), Math.min(selection[1], rightIndex)];
	            }
	          }
	        } else {
	          host.filter = null;
	        }
	      }
	    }
	  }, {
	    key: "setSelection",
	    value: function setSelection(host) {
	      var barArea = host.barAreaElement;

	      if (barArea) {
	        var rect = barArea.getBoundingClientRect();
	        var left = Math.min(this.mouse.startX, this.mouse.endX) - rect.left;
	        var right = Math.max(this.mouse.startX, this.mouse.endX) - rect.left;
	        var view = host.view;
	        var viewLength = view[1] - view[0];
	        var width = rect.right - rect.left;
	        var barStep = width / viewLength;
	        var values = host.values;
	        var filterValues = host.filterValues;
	        var leftIndex;
	        var rightIndex;

	        if (filterValues) {
	          var filter0 = Math.floor(filterValues[0]);
	          var filter1 = Math.ceil(filterValues[1]);
	          leftIndex = Math.max(Math.floor(left / barStep) + view[0], filter0);
	          rightIndex = Math.min(Math.ceil(right / barStep) + view[0], filter1);
	        } else {
	          leftIndex = Math.max(Math.floor(left / barStep) + view[0], view[0]);
	          rightIndex = Math.min(Math.ceil(right / barStep) + view[0], view[1]);
	        }

	        while (leftIndex < rightIndex && !values[leftIndex]) {
	          ++leftIndex;
	        }

	        while (rightIndex > leftIndex && !values[rightIndex - 1]) {
	          --rightIndex;
	        }

	        if (host.selection && host.selection[0] === leftIndex && host.selection[1] === rightIndex) {
	          host.selection = null;
	        } else if (leftIndex !== rightIndex) {
	          host.selection = [leftIndex, rightIndex];
	        } else {
	          host.selection = null;
	        }
	      }
	    }
	  }, {
	    key: "monkeyPatchRenderer",
	    value: function monkeyPatchRenderer(facet) {
	      var _this2 = this;

	      var facetAny = facet;

	      if (typeof facetAny.renderTimelineContent === 'function') {
	        this.facetRenderContent = facetAny.renderTimelineContent;

	        facetAny.renderTimelineContent = function () {
	          if (_this2.facetRenderContent) {
	            return _this2.renderPlugin(_this2.facetRenderContent.call(facetAny));
	          }

	          return undefined;
	        };
	      }
	    }
	  }, {
	    key: "monkeyUnpatchRenderer",
	    value: function monkeyUnpatchRenderer(facet) {
	      var facetAny = facet;

	      if (this.facetRenderContent && typeof this.facetRenderContent === 'function') {
	        facetAny.renderTimelineContent = this.facetRenderContent;
	        this.facetRenderContent = null;
	      }
	    }
	  }, {
	    key: "computeLabelWidth",
	    value: function computeLabelWidth(label) {
	      this.labelContext.font = '12px "IBM Plex Sans", sans-serif';
	      return this.labelContext.measureText(label).width;
	    }
	  }, {
	    key: "isPointInSelectionArea",
	    value: function isPointInSelectionArea(x, y, barArea, host) {
	      var rect = barArea.getBoundingClientRect();

	      if (y >= rect.top && y <= rect.bottom) {
	        if (host.filterValues) {
	          var left = x - rect.left;
	          var right = x - rect.left;
	          var view = host.view;
	          var viewLength = view[1] - view[0];
	          var width = rect.right - rect.left;
	          var barStep = width / viewLength;
	          var filterValues = host.filterValues;
	          var filter0 = Math.floor(filterValues[0]);
	          var filter1 = Math.ceil(filterValues[1]);
	          var leftIndex = Math.floor(left / barStep) + view[0];
	          var rightIndex = Math.ceil(right / barStep) + view[0];
	          return leftIndex >= filter0 && rightIndex <= filter1;
	        }

	        return x >= rect.left && x <= rect.right;
	      }

	      return false;
	    }
	  }]);

	  return FacetTimelineSelection;
	}(FacetPlugin);

	FacetTimelineSelection = __decorate([customElement('facet-timeline-selection')], FacetTimelineSelection);

	function _templateObject2$c() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject2$c = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$f() {
	  var data = _taggedTemplateLiteral(["\n                    <", "\n                    id=\"", "\"\n                    .data=\"", "\"\n                    .selection=\"", "\"\n                    @facet-element-updated=\"", "\"\n                    ></", ">"]);

	  _templateObject$f = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var FacetList = /*#__PURE__*/function (_FacetContainer) {
	  _inherits(FacetList, _FacetContainer);

	  var _super = _createSuper(FacetList);

	  function FacetList() {
	    var _this;

	    _classCallCheck(this, FacetList);

	    _this = _super.apply(this, arguments);
	    _this._data = [];
	    _this._selection = null;
	    _this.ignoreSelectionMap = new Map();
	    _this.facetIDs = new Set();
	    return _this;
	  }

	  _createClass(FacetList, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(FacetList.prototype), "connectedCallback", this).call(this);

	      var list = this.createSlottedElement('content');

	      if (list) {
	        list.setAttribute('id', 'facet-list-content');
	      }
	    }
	  }, {
	    key: "renderHeader",
	    value: function renderHeader() {
	      return undefined;
	    }
	  }, {
	    key: "renderFooter",
	    value: function renderFooter() {
	      return undefined;
	    }
	  }, {
	    key: "renderSlottedElements",
	    value: function renderSlottedElements() {
	      _get(_getPrototypeOf(FacetList.prototype), "renderSlottedElements", this).call(this);

	      var listSlot = this.slottedElements.get('content');

	      if (listSlot) {
	        this.renderSlottedElement(this._renderContent(), listSlot);
	      }
	    }
	  }, {
	    key: "setTemplateForTarget",
	    value: function setTemplateForTarget(target, template) {
	      _get(_getPrototypeOf(FacetList.prototype), "setTemplateForTarget", this).call(this, target, template);

	      template.addCustomAttribute('id');
	      template.addCustomAttribute('.selection');
	      template.addCustomAttribute('@facet-element-updated');
	    }
	  }, {
	    key: "handleElementUpdated",
	    value: function handleElementUpdated(event) {
	      var changedProperties = event.detail.changedProperties;
	      var content = this.querySelector('#facet-list-content');

	      if (content) {
	        if (changedProperties.has('hover')) {
	          var source = event.target;
	          var value = source.hover;
	          var facet;

	          for (var i = 0, n = content.children.length; i < n; ++i) {
	            facet = content.children[i];
	            facet.hover = value;
	          }
	        }

	        if (changedProperties.has('selection')) {
	          var _source = event.target;

	          if (this.shouldProcessSelectionEvent(_source) && (changedProperties.get('selection') || _source.selection)) {
	            var _constructor = Object.getPrototypeOf(_source).constructor;
	            var siblings = [];

	            var _facet;

	            for (var _i = 0, _n = content.children.length; _i < _n; ++_i) {
	              _facet = content.children[_i];

	              if (_facet !== _source && Object.getPrototypeOf(_facet).constructor === _constructor) {
	                siblings.push(_facet);
	              }
	            }

	            if (siblings.length) {
	              this.handleSelectionEvent(_source, siblings);
	            } else {
	              var oldValue = this._selection;
	              this._selection = this.buildSelection();
	              this.requestUpdate('selection', oldValue);
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: "handleSelectionEvent",
	    value: function handleSelectionEvent(source, siblings) {
	      var sourceSelection = source.selection;

	      if (!sourceSelection) {
	        var hasSelection = false;

	        for (var i = 0, n = siblings.length; i < n; ++i) {
	          // @ts-ignore
	          if (siblings[i].selection && Object.keys(siblings[i].selection).length) {
	            hasSelection = true;
	            break;
	          }
	        }

	        if (hasSelection) {
	          this.setSelectionIgnoringEvent(source, []);
	        } else {
	          for (var _i2 = 0, _n2 = siblings.length; _i2 < _n2; ++_i2) {
	            if (siblings[_i2].selection) {
	              this.setSelectionIgnoringEvent(siblings[_i2], null);
	            }
	          }
	        }
	      } else {
	        for (var _i3 = 0, _n3 = siblings.length; _i3 < _n3; ++_i3) {
	          if (!siblings[_i3].selection) {
	            this.setSelectionIgnoringEvent(siblings[_i3], []);
	          }
	        }
	      }

	      var oldValue = this._selection;
	      this._selection = this.buildSelection();
	      this.requestUpdate('selection', oldValue);
	    }
	  }, {
	    key: "setSelectionIgnoringEvent",
	    value: function setSelectionIgnoringEvent(target, value) {
	      this.ignoreSelectionMap.set(target, value);
	      target.selection = value;
	    }
	  }, {
	    key: "shouldProcessSelectionEvent",
	    value: function shouldProcessSelectionEvent(source) {
	      if (this.ignoreSelectionMap.has(source)) {
	        var expectedSelection = this.ignoreSelectionMap.get(source);
	        this.ignoreSelectionMap.delete(source);
	        var sourceSelection = source.selection;
	        return !this.isSameSelection(expectedSelection, sourceSelection);
	      }

	      return true;
	    }
	  }, {
	    key: "isSameSelection",
	    value: function isSameSelection(expectedSelection, sourceSelection) {
	      if (sourceSelection === expectedSelection) {
	        return true;
	      }

	      if (!expectedSelection || !sourceSelection) {
	        return false;
	      }

	      var expectedKeys = Object.keys(expectedSelection);
	      var sourceKeys = Object.keys(sourceSelection);

	      if (expectedKeys.length !== sourceKeys.length) {
	        return false;
	      }

	      for (var i = 0, n = sourceKeys.length; i < n; ++i) {
	        // @ts-ignore
	        if (sourceSelection[sourceKeys[i]] !== expectedSelection[expectedKeys[i]]) {
	          return false;
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "buildSelection",
	    value: function buildSelection() {
	      var content = this.querySelector('#facet-list-content');

	      if (content) {
	        var newSelection = {};
	        var hasSelection = false;
	        var element;
	        var facet;

	        var _iterator = _createForOfIteratorHelper(this.facetIDs),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var id = _step.value;
	            element = content.querySelector("[id='".concat(id, "']"));

	            if (element) {
	              facet = element;
	              newSelection[id] = facet.selection;
	              hasSelection = hasSelection || Boolean(newSelection[id]);
	            }
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }

	        if (hasSelection) {
	          return newSelection;
	        }
	      }

	      return null;
	    }
	  }, {
	    key: "_renderContent",
	    value: function _renderContent() {
	      var result = [];
	      this.facetIDs.clear();

	      for (var i = 0, n = this.data.length; i < n; ++i) {
	        var facet = this.data[i];
	        var id = facet.hasOwnProperty('id') ? facet.id : "".concat(i);
	        var selection = this._selection ? this._selection[id] || [] : null;
	        this.facetIDs.add(id);

	        if (this.templates.has(facet.type)) {
	          // @ts-ignore
	          result.push(this.templates.get(facet.type).getHTML(facet.data, {
	            id: id,
	            '.selection': selection,
	            '@facet-element-updated': this.handleElementUpdated
	          }));
	        } else {
	          var type = facet.type.split('#')[0];
	          result.push(preHTML(_templateObject$f(), type, id, facet.data, selection, this.handleElementUpdated, type));
	        }
	      }

	      return html$1(_templateObject2$c(), result);
	    }
	  }, {
	    key: "data",
	    get: function get() {
	      return this._data;
	    },
	    set: function set(value) {
	      var oldValue = this._data;
	      this._data = value;
	      this.requestUpdate('data', oldValue);
	    }
	  }, {
	    key: "selection",
	    get: function get() {
	      return this._selection;
	    },
	    set: function set(value) {
	      var oldValue = this._selection;
	      this._selection = value;
	      var content = this.querySelector('#facet-list-content');

	      if (content) {
	        if (this._selection) {
	          var keys = Object.keys(this._selection);
	          var element;
	          var facet;
	          var newSelection;

	          for (var i = 0, n = keys.length; i < n; ++i) {
	            element = content.querySelector("#".concat(keys[i]));

	            if (element) {
	              facet = element;
	              newSelection = this._selection[keys[i]];

	              if (!this.isSameSelection(newSelection, facet.selection)) {
	                this.setSelectionIgnoringEvent(facet, newSelection);
	              }
	            }
	          }
	        } else {
	          var _facet2;

	          for (var _i4 = 0, _n4 = content.children.length; _i4 < _n4; ++_i4) {
	            _facet2 = content.children[_i4];

	            if (_facet2.selection) {
	              this.setSelectionIgnoringEvent(_facet2, null);
	            }
	          }
	        }
	      }

	      this.requestUpdate('selection', oldValue);
	    }
	  }], [{
	    key: "properties",
	    get: function get() {
	      return {
	        data: {
	          type: Object
	        },
	        selection: {
	          type: Object
	        }
	      };
	    }
	  }]);

	  return FacetList;
	}(FacetContainer);

	FacetList = __decorate([customElement('facet-list')], FacetList);

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get FacetPlugin () { return FacetPlugin; },
		get FacetTemplate () { return FacetTemplate; },
		get FacetElement () { return FacetElement; },
		get FacetBlueprint () { return FacetBlueprint; },
		makeIconSVG: makeIconSVG,
		get FacetHoverable () { return FacetHoverable; },
		get FacetContainer () { return FacetContainer; },
		get FacetTerms () { return FacetTerms; },
		get FacetTermsValue () { return FacetTermsValue; },
		get FacetBarsValue () { return FacetBarsValue; },
		get FacetBarsBase () { return FacetBarsBase; },
		get FacetBars () { return FacetBars; },
		get FacetBarsLabels () { return FacetBarsLabels; },
		get FacetBarsSelection () { return FacetBarsSelection; },
		get FacetTimeline () { return FacetTimeline; },
		get FacetTimelineLabels () { return FacetTimelineLabels; },
		get FacetTimelineSelection () { return FacetTimelineSelection; },
		get FacetList () { return FacetList; }
	});

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	function __decorate$1(decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	function _templateObject3$a() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject3$a = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$d() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject2$d = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$g() {
	  var data = _taggedTemplateLiteral(["\n            <div class=\"zoom-bar-container\">\n                <div class=\"zoom-bar-background\">\n                    <div class=\"zoom-bar-area\">\n                        <div class=\"zoom-bar-selection\" style=\"left:", "%;right:", "%;\"></div>\n                        <div class=\"zoom-bar-thumb\" @mousedown=\"", "\" style=\"left:", "%;right:", "%;display:", "\">\n                            <div class=\"zoom-bar-handle zoom-bar-handle-left\" @mousedown=\"", "\"></div>\n                            <div class=\"zoom-bar-handle zoom-bar-handle-right\" @mousedown=\"", "\"></div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            "]);

	  _templateObject$g = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var ZoomBarStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.zoom-bar-container {\n    width: 100%;\n    height: 10px;\n    display: flex;\n    margin-bottom: 15px;\n}\n\n.zoom-bar-background {\n    height: 100%;\n    flex-grow: 1;\n    margin: 0 14px;\n    padding: 0 10px;\n    background-color: #EAEBEC;\n    border-radius: 5px;\n    overflow: hidden;\n    display: flex;\n}\n\n.zoom-bar-area {\n    height: 100%;\n    flex-grow: 1;\n    position: relative;\n}\n\n.zoom-bar-selection {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    background-color: #A4C2FC;\n}\n\n.zoom-bar-thumb {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    background-color: #C2C3C4;\n    cursor: pointer;\n}\n\n.zoom-bar-handle {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    cursor: ew-resize;\n    background: linear-gradient(0deg, #B2B3B4 0, #B2B3B4 28%, transparent 28%, transparent 72%, #B2B3B4 72%),\n    linear-gradient(\n        90deg,\n        #B2B3B4 0,\n        #B2B3B4 30%,\n        #EAEBEC 30%,\n        #EAEBEC calc(30% + 1px),\n        #B2B3B4 calc(30% + 1px),\n        #B2B3B4 calc(70% - 1px),\n        #EAEBEC calc(70% - 1px),\n        #EAEBEC 70%,\n        #B2B3B4 70%);\n}\n\n.zoom-bar-handle-left {\n    left: -10px;\n    right: 100%;\n    border-radius: 5px 0 0 5px;\n    border-right: 1px solid white;\n}\n\n.zoom-bar-handle-right {\n    left: 100%;\n    right: -10px;\n    border-radius: 0 5px 5px 0;\n    border-left: 1px solid white;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var ZoomBar = /*#__PURE__*/function (_FacetPlugin) {
	  _inherits(ZoomBar, _FacetPlugin);

	  var _super = _createSuper(ZoomBar);

	  function ZoomBar() {
	    var _this;

	    _classCallCheck(this, ZoomBar);

	    _this = _super.apply(this, arguments);
	    _this._enabled = true;
	    _this.facet = null;
	    _this.mouseTarget = null;
	    _this.mouseX = null;
	    _this.boundMouseHandler = _this.handleMouseEvent.bind(_assertThisInitialized(_this));
	    return _this;
	  }

	  _createClass(ZoomBar, [{
	    key: "hostChanged",
	    value: function hostChanged(host) {
	      if (this.facet) {
	        this.facet.removeEventListener('mousemove', this.boundMouseHandler);
	        this.facet.removeEventListener('mouseleave', this.boundMouseHandler);
	        this.facet.removeEventListener('mouseup', this.boundMouseHandler);
	        this.facet.removeEventListener('touchstart', this.boundMouseHandler);
	        this.facet.removeEventListener('touchend', this.boundMouseHandler);
	        this.facet.removeEventListener('touchcancel', this.boundMouseHandler);
	        this.facet.removeEventListener('touchmove', this.boundMouseHandler);
	      }

	      if (host instanceof FacetBarsBase) {
	        this.facet = host;
	        this.facet.addEventListener('mousemove', this.boundMouseHandler);
	        this.facet.addEventListener('mouseleave', this.boundMouseHandler);
	        this.facet.addEventListener('mouseup', this.boundMouseHandler);
	        this.facet.addEventListener('touchstart', this.boundMouseHandler);
	        this.facet.addEventListener('touchend', this.boundMouseHandler);
	        this.facet.addEventListener('touchcancel', this.boundMouseHandler);
	        this.facet.addEventListener('touchmove', this.boundMouseHandler);
	      } else {
	        this.facet = null;
	      }
	    }
	  }, {
	    key: "hostUpdated",
	    value: function hostUpdated(changedProperties) {
	      _get(_getPrototypeOf(ZoomBar.prototype), "hostUpdated", this).call(this, changedProperties);

	      if (changedProperties.has('view') || changedProperties.has('domain') || changedProperties.has('selection')) {
	        this.requestUpdate();
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      if (this.facet) {
	        var domain = this.facet.domain;
	        var view = this.facet.view;
	        var selection = this.facet.selection;
	        var domainLength = domain[1] - domain[0];
	        var thumbLeft = ((view[0] - domain[0]) / domainLength * 100).toFixed(2);
	        var thumbRight = ((1.0 - (view[1] - domain[0]) / domainLength) * 100).toFixed(2);
	        var selectionLeft = selection ? ((selection[0] - domain[0]) / domainLength * 100).toFixed(2) : 0;
	        var selectionRight = selection ? ((1.0 - (selection[1] - domain[0]) / domainLength) * 100).toFixed(2) : 100;
	        return html$1(_templateObject$g(), selectionLeft, selectionRight, this.handleMouseEvent, thumbLeft, thumbRight, this._enabled ? 'block' : 'none', this.handleMouseEvent, this.handleMouseEvent);
	      }

	      return html$1(_templateObject2$d(), undefined);
	    }
	  }, {
	    key: "handleMouseEvent",
	    value: function handleMouseEvent(event) {
	      if (this.facet) {
	        var mouseEvent = event;
	        var domain = this.facet.domain;
	        var domainLength = domain[1] - domain[0];

	        switch (mouseEvent.type) {
	          case 'mousedown':
	          case 'touchstart':
	            if (mouseEvent.currentTarget instanceof Element) {
	              if (mouseEvent.currentTarget.className.indexOf('zoom-bar-thumb') !== -1) {
	                this.mouseTarget = 'thumb';
	                event.preventDefault();
	              } else if (mouseEvent.currentTarget.className.indexOf('zoom-bar-handle-left') !== -1) {
	                this.mouseTarget = 'left-handle';
	                event.stopPropagation();
	                event.preventDefault();
	              } else if (mouseEvent.currentTarget.className.indexOf('zoom-bar-handle-right') !== -1) {
	                this.mouseTarget = 'right-handle';
	                event.stopPropagation();
	                event.preventDefault();
	              } else {
	                this.mouseTarget = null;
	              }

	              this.mouseX = mouseEvent.pageX;
	            }

	            break;

	          case 'mouseup':
	          case 'mouseleave':
	          case 'touchcancel':
	          case 'touchend':
	            this.mouseTarget = null;
	            break;

	          case 'touchmove':
	          case 'mousemove':
	            if (this.mouseTarget) {
	              var zoomBarArea = this.renderRoot.querySelector('.zoom-bar-area');

	              if (zoomBarArea) {
	                var rangeStep = zoomBarArea.scrollWidth / (domainLength + 1);

	                if (this.mouseX !== null) {
	                  event.preventDefault();
	                  var view = this.facet.view;
	                  var distance = Math.round((mouseEvent.pageX - this.mouseX) / rangeStep);

	                  if (distance > 0) {
	                    if (this.mouseTarget === 'left-handle') {
	                      distance = Math.min(distance, view[1] - view[0] - 1);
	                    } else {
	                      distance = Math.min(distance, domain[1] - view[1]);
	                    }
	                  } else if (distance < 0) {
	                    if (this.mouseTarget === 'right-handle') {
	                      distance = Math.max(distance, view[0] - view[1] + 1);
	                    } else {
	                      distance = Math.max(distance, domain[0] - view[0]);
	                    }
	                  }

	                  if (distance) {
	                    switch (this.mouseTarget) {
	                      case 'thumb':
	                        this.facet.view = [view[0] + distance, view[1] + distance];
	                        break;

	                      case 'left-handle':
	                        this.facet.view = [view[0] + distance, view[1]];
	                        break;

	                      case 'right-handle':
	                        this.facet.view = [view[0], view[1] + distance];
	                        break;
	                    }

	                    this.mouseX += distance * rangeStep;
	                    this.requestUpdate();
	                  }
	                }
	              }
	            }

	            break;
	        }
	      }
	    }
	  }, {
	    key: "enabled",
	    get: function get() {
	      return true;
	    },
	    set: function set(value) {
	      var oldValue = this._enabled;
	      this._enabled = value;

	      if (!this._enabled) {
	        this.mouseTarget = null;
	      }

	      this.requestUpdate('enabled', oldValue);
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      return [css(_templateObject3$a(), unsafeCSS(ZoomBarStyle))];
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        enabled: {
	          type: Object
	        }
	      };
	    }
	  }]);

	  return ZoomBar;
	}(FacetPlugin);

	ZoomBar = __decorate$1([customElement('facet-plugin-zoom-bar')], ZoomBar);

	var faPlus = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, '__esModule', { value: true });
	var prefix = 'fas';
	var iconName = 'plus';
	var width = 448;
	var height = 512;
	var ligatures = [];
	var unicode = 'f067';
	var svgPathData = 'M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z';

	exports.definition = {
	  prefix: prefix,
	  iconName: iconName,
	  icon: [
	    width,
	    height,
	    ligatures,
	    unicode,
	    svgPathData
	  ]};

	exports.faPlus = exports.definition;
	exports.prefix = prefix;
	exports.iconName = iconName;
	exports.width = width;
	exports.height = height;
	exports.ligatures = ligatures;
	exports.unicode = unicode;
	exports.svgPathData = svgPathData;
	});

	var faMinus = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, '__esModule', { value: true });
	var prefix = 'fas';
	var iconName = 'minus';
	var width = 448;
	var height = 512;
	var ligatures = [];
	var unicode = 'f068';
	var svgPathData = 'M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z';

	exports.definition = {
	  prefix: prefix,
	  iconName: iconName,
	  icon: [
	    width,
	    height,
	    ligatures,
	    unicode,
	    svgPathData
	  ]};

	exports.faMinus = exports.definition;
	exports.prefix = prefix;
	exports.iconName = iconName;
	exports.width = width;
	exports.height = height;
	exports.ligatures = ligatures;
	exports.unicode = unicode;
	exports.svgPathData = svgPathData;
	});

	var faHome = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, '__esModule', { value: true });
	var prefix = 'fas';
	var iconName = 'home';
	var width = 576;
	var height = 512;
	var ligatures = [];
	var unicode = 'f015';
	var svgPathData = 'M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z';

	exports.definition = {
	  prefix: prefix,
	  iconName: iconName,
	  icon: [
	    width,
	    height,
	    ligatures,
	    unicode,
	    svgPathData
	  ]};

	exports.faHome = exports.definition;
	exports.prefix = prefix;
	exports.iconName = iconName;
	exports.width = width;
	exports.height = height;
	exports.ligatures = ligatures;
	exports.unicode = unicode;
	exports.svgPathData = svgPathData;
	});

	function _templateObject3$b() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject3$b = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$e() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject2$e = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$h() {
	  var data = _taggedTemplateLiteral(["\n            <div class=\"zoom-controls-container\">\n                <div class=\"zoom-controls-buttons\">\n                    <div class=\"zoom-controls-button\" @click=\"", "\">\n                        ", "\n                    </div>\n                    <div class=\"zoom-controls-button\" @click=\"", "\">\n                        ", "\n                    </div>\n                    <div class=\"zoom-controls-button\" @click=\"", "\">\n                        ", "\n                    </div>\n                </div>\n            </div>"]);

	  _templateObject$h = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var ZoomControlsStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.zoom-controls-container {\n    height: 100%;\n    padding: 0 5px;\n    display: flex;\n    align-items: center;\n}\n\n.zoom-controls-buttons {\n    display: flex;\n    flex-direction: column;\n}\n\n.zoom-controls-button {\n    width: 16px;\n    height: 16px;\n    border: 1px solid #A7A7A8;\n    background-color: #F0F1F2;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n}\n\n.zoom-controls-button:not(:first-child):not(:last-child) {\n    border-top: 0;\n    border-bottom: 0;\n}\n\n.zoom-controls-button:first-child {\n    border-top-right-radius: 2px;\n    border-top-left-radius: 2px;\n}\n\n.zoom-controls-button:last-child {\n    border-bottom-left-radius: 2px;\n    border-bottom-right-radius: 2px;\n}\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var WheelZoomState;

	(function (WheelZoomState) {
	  WheelZoomState[WheelZoomState["idle"] = 0] = "idle";
	  WheelZoomState[WheelZoomState["enabled"] = 1] = "enabled";
	  WheelZoomState[WheelZoomState["locked"] = 2] = "locked";
	})(WheelZoomState || (WheelZoomState = {}));

	var ZoomControls = /*#__PURE__*/function (_FacetPlugin) {
	  _inherits(ZoomControls, _FacetPlugin);

	  var _super = _createSuper(ZoomControls);

	  function ZoomControls() {
	    var _this;

	    _classCallCheck(this, ZoomControls);

	    _this = _super.apply(this, arguments);
	    _this.facet = null;
	    _this.wheelZoomState = WheelZoomState.idle;
	    _this.wheelDeltaXSum = 0;
	    _this.wheelDeltaYSum = 0;
	    _this.lastWheelTime = 0;
	    _this.wheelDeltaThreshold = 14;
	    _this.wheelTimeThreshold = 80;
	    /* ms */

	    _this.boundWheelHandler = _this.wheelHandler.bind(_assertThisInitialized(_this));
	    return _this;
	  }

	  _createClass(ZoomControls, [{
	    key: "hostChanged",
	    value: function hostChanged(host) {
	      if (this.facet) {
	        this.facet.removeEventListener('wheel', this.boundWheelHandler);
	      }

	      if (host instanceof FacetBarsBase) {
	        this.facet = host;
	        this.facet.addEventListener('wheel', this.boundWheelHandler);
	      } else {
	        this.facet = null;
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      if (this.facet) {
	        return html$1(_templateObject$h(), this.dispatchInteractionEvent.bind(this, 'plus'), makeIconSVG(faPlus.faPlus, 12, 12, '#A7A7A8'), this.dispatchInteractionEvent.bind(this, 'home'), makeIconSVG(faHome.faHome, 12, 12, '#DEDEDF'), this.dispatchInteractionEvent.bind(this, 'minus'), makeIconSVG(faMinus.faMinus, 12, 12, '#A7A7A8'));
	      }

	      return html$1(_templateObject2$e(), undefined);
	    }
	  }, {
	    key: "dispatchInteractionEvent",
	    value: function dispatchInteractionEvent(type) {
	      this.dispatchEvent(new CustomEvent('zoom-controls-interaction', {
	        bubbles: false,
	        detail: {
	          type: type
	        }
	      }));
	    }
	  }, {
	    key: "wheelHandler",
	    value: function wheelHandler(event) {
	      if (this.facet) {
	        var wheelEvent = event;
	        var timestamp = wheelEvent.timeStamp;

	        if (timestamp - this.lastWheelTime > this.wheelTimeThreshold) {
	          this.wheelDeltaXSum = wheelEvent.deltaX;
	          this.wheelDeltaYSum = wheelEvent.deltaY;
	          this.wheelZoomState = WheelZoomState.idle;
	        } else {
	          this.wheelDeltaXSum += wheelEvent.deltaX;
	          this.wheelDeltaYSum += wheelEvent.deltaY;
	          wheelEvent.preventDefault();
	        }

	        this.lastWheelTime = timestamp;

	        if (this.wheelZoomState === WheelZoomState.idle) {
	          if (Math.abs(this.wheelDeltaYSum) >= this.wheelDeltaThreshold) {
	            this.wheelZoomState = WheelZoomState.enabled;
	          } else if (Math.abs(this.wheelDeltaXSum) >= this.wheelDeltaThreshold) {
	            this.wheelZoomState = WheelZoomState.locked;
	          }
	        }

	        while (this.wheelZoomState === WheelZoomState.enabled && Math.abs(this.wheelDeltaYSum) >= this.wheelDeltaThreshold) {
	          if (this.wheelDeltaYSum > 0) {
	            this.dispatchInteractionEvent('minus');
	            this.wheelDeltaYSum -= this.wheelDeltaThreshold;
	          } else {
	            this.dispatchInteractionEvent('plus');
	            this.wheelDeltaYSum += this.wheelDeltaThreshold;
	          }
	        }
	      }
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      return [css(_templateObject3$b(), unsafeCSS(ZoomControlsStyle))];
	    }
	  }]);

	  return ZoomControls;
	}(FacetPlugin);

	ZoomControls = __decorate$1([customElement('facet-plugin-zoom-controls')], ZoomControls);

	var ClassList = /*#__PURE__*/function () {
	  function ClassList(element) {
	    _classCallCheck(this, ClassList);

	    this.classes = new Set();
	    this.changed = false;
	    this.element = element;
	    var classList = (element.getAttribute('class') || '').split(/\s+/);

	    var _iterator = _createForOfIteratorHelper(classList),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var cls = _step.value;
	        this.classes.add(cls);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  }

	  _createClass(ClassList, [{
	    key: "add",
	    value: function add(cls) {
	      this.classes.add(cls);
	      this.changed = true;
	    }
	  }, {
	    key: "remove",
	    value: function remove(cls) {
	      this.classes.delete(cls);
	      this.changed = true;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      if (this.changed) {
	        var classString = '';
	        this.classes.forEach(function (cls) {
	          return classString += cls + ' ';
	        });
	        this.element.setAttribute('class', classString);
	      }
	    }
	  }]);

	  return ClassList;
	}();
	/**
	 * Stores the ClassInfo object applied to a given AttributePart.
	 * Used to unset existing values when a new ClassInfo object is applied.
	 */


	var previousClassesCache = new WeakMap();
	/**
	 * A directive that applies CSS classes. This must be used in the `class`
	 * attribute and must be the only part used in the attribute. It takes each
	 * property in the `classInfo` argument and adds the property name to the
	 * element's `class` if the property value is truthy; if the property value is
	 * falsey, the property name is removed from the element's `class`. For example
	 * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.
	 * @param classInfo {ClassInfo}
	 */

	var classMap = directive(function (classInfo) {
	  return function (part) {
	    if (!(part instanceof AttributePart) || part instanceof PropertyPart || part.committer.name !== 'class' || part.committer.parts.length > 1) {
	      throw new Error('The `classMap` directive must be used in the `class` attribute ' + 'and must be the only part in the attribute.');
	    }

	    var committer = part.committer;
	    var element = committer.element;
	    var previousClasses = previousClassesCache.get(part);

	    if (previousClasses === undefined) {
	      // Write static classes once
	      // Use setAttribute() because className isn't a string on SVG elements
	      element.setAttribute('class', committer.strings.join(' '));
	      previousClassesCache.set(part, previousClasses = new Set());
	    }

	    var classList = element.classList || new ClassList(element); // Remove old classes that no longer apply
	    // We use forEach() instead of for-of so that re don't require down-level
	    // iteration.

	    previousClasses.forEach(function (name) {
	      if (!(name in classInfo)) {
	        classList.remove(name);
	        previousClasses.delete(name);
	      }
	    }); // Add or remove classes based on their classMap value

	    for (var name in classInfo) {
	      var value = classInfo[name];

	      if (value != previousClasses.has(name)) {
	        // We explicitly want a loose truthy check of `value` because it seems
	        // more convenient that '' and 0 are skipped.
	        if (value) {
	          classList.add(name);
	          previousClasses.add(name);
	        } else {
	          classList.remove(name);
	          previousClasses.delete(name);
	        }
	      }
	    }

	    if (typeof classList.commit === 'function') {
	      classList.commit();
	    }
	  };
	});

	function _templateObject3$c() {
	  var data = _taggedTemplateLiteral(["", ""]);

	  _templateObject3$c = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$f() {
	  var data = _taggedTemplateLiteral(["<div class=\"scrollbar-container\"></div>"]);

	  _templateObject2$f = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$i() {
	  var data = _taggedTemplateLiteral(["\n                <div class=\"scrollbar-container\">\n                    <div class=", ">\n                        <div class=\"scrollbar-area\" @mousedown=\"", "\">\n                            <div class=\"scrollbar-thumb\"\n                            @mousedown=\"", "\"\n                            dark=\"", "\"\n                            style=", "></div>\n                        </div>\n                    </div>\n                </div>\n                "]);

	  _templateObject$i = function _templateObject() {
	    return data;
	  };

	  return data;
	}
	var ScrollbarStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.scrollbar-container {\n    width: 100%;\n    height: 14px;\n    display: flex;\n}\n\n.scrollbar-background {\n    height: 100%;\n    flex-grow: 1;\n    margin: 0 -2px;\n    padding: 0 1px;\n    overflow: hidden;\n    display: flex;\n    z-index: 2;\n\n    background-color: rgb(248,248,248);\n    border-top: 1px solid rgb(231,231,231);\n    border-bottom: 1px solid rgb(231,231,231);\n\n    box-sizing: border-box;\n}\n\n.scrollbar-background-round {\n    /*margin: 0 18px;*/\n    padding: 0 3px;\n    border-radius: 6px;\n    border: none;\n    background-color: rgb(244,244,244);\n}\n\n.scrollbar-area {\n    height: 100%;\n    flex-grow: 1;\n    position: relative;\n}\n\n.scrollbar-filter {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    background-color: rgba(164,194,252,0.5);\n}\n\n.scrollbar-thumb {\n    position: absolute;\n    top: 2px;\n    bottom: 2px;\n    background-color: rgb(195,195,195);\n    cursor: pointer;\n    border-radius: 4px;\n    transition: background-color 150ms ease;\n}\n\n.scrollbar-thumb:hover,\n.scrollbar-thumb[dark=true]\n{\n    background-color: rgb(125,125,125);\n}\n\n";
	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */

	var WheelScrollState;

	(function (WheelScrollState) {
	  WheelScrollState[WheelScrollState["idle"] = 0] = "idle";
	  WheelScrollState[WheelScrollState["enabled"] = 1] = "enabled";
	  WheelScrollState[WheelScrollState["locked"] = 2] = "locked";
	})(WheelScrollState || (WheelScrollState = {}));

	var Scrollbar = /*#__PURE__*/function (_FacetPlugin) {
	  _inherits(Scrollbar, _FacetPlugin);

	  var _super = _createSuper(Scrollbar);

	  function Scrollbar() {
	    var _this;

	    _classCallCheck(this, Scrollbar);

	    _this = _super.apply(this, arguments);
	    _this.minBarWidth = 8;
	    _this.autoHide = false;
	    _this.roundCaps = false;
	    _this.facet = null;
	    _this.mouseTarget = null;
	    _this.mouseX = null;
	    _this.boundMouseHandler = _this.handleMouseEvent.bind(_assertThisInitialized(_this));
	    _this.wheelScrollState = WheelScrollState.idle;
	    _this.wheelDeltaXSum = 0;
	    _this.wheelDeltaYSum = 0;
	    _this.lastWheelTime = 0;
	    _this.wheelDeltaThreshold = 14;
	    _this.wheelTimeThreshold = 80;
	    /* ms */

	    _this.boundWheelHandler = _this.wheelHandler.bind(_assertThisInitialized(_this));
	    _this.animatedScrolling = false;
	    _this.scrollStep = 0;
	    return _this;
	  }

	  _createClass(Scrollbar, [{
	    key: "hostChanged",
	    value: function hostChanged(host) {
	      if (this.facet) {
	        this.facet.removeEventListener('wheel', this.boundWheelHandler);
	        this.facet.removeEventListener('mousedown', this.boundMouseHandler);
	        window.document.removeEventListener('mousemove', this.boundMouseHandler);
	        window.document.removeEventListener('mouseleave', this.boundMouseHandler);
	        window.document.removeEventListener('mouseup', this.boundMouseHandler);
	      }

	      if (host instanceof FacetBarsBase) {
	        this.facet = host;
	        this.facet.addEventListener('wheel', this.boundWheelHandler);
	        this.facet.addEventListener('mousedown', this.boundMouseHandler);
	        window.document.addEventListener('mousemove', this.boundMouseHandler);
	        window.document.addEventListener('mouseleave', this.boundMouseHandler);
	        window.document.addEventListener('mouseup', this.boundMouseHandler);
	        this.ensureMaxBarWidth();
	      } else {
	        this.facet = null;
	      }
	    }
	  }, {
	    key: "hostUpdated",
	    value: function hostUpdated(changedProperties) {
	      _get(_getPrototypeOf(Scrollbar.prototype), "hostUpdated", this).call(this, changedProperties);

	      this.ensureMaxBarWidth();

	      if (changedProperties.has('view') || changedProperties.has('domain') || changedProperties.has('selection') || changedProperties.has('filter') || changedProperties.has('values')) {
	        this.requestUpdate();
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      if (this.facet) {
	        var domain = this.facet.domain;
	        var view = this.facet.view;

	        if (!this.autoHide || view[0] > domain[0] || view[1] < domain[1]) {
	          var domainLength = domain[1] - domain[0];
	          var thumbLeft = ((view[0] - domain[0]) / domainLength * 100).toFixed(2);
	          var thumbRight = ((1.0 - (view[1] - domain[0]) / domainLength) * 100).toFixed(2);
	          var thumbVisibility = view[0] !== domain[0] || view[1] !== domain[1] ? 'visible' : 'hidden';
	          var thumbStyle = {
	            left: "".concat(thumbLeft, "%"),
	            right: "".concat(thumbRight, "%"),
	            visibility: thumbVisibility
	          };
	          var backgroundClasses = {
	            'scrollbar-background': true,
	            'scrollbar-background-round': this.roundCaps
	          };
	          return html$1(_templateObject$i(), classMap(backgroundClasses), this.handleMouseEvent, this.handleMouseEvent, this.mouseTarget ? 'true' : 'false', styleMap(thumbStyle));
	        }

	        return undefined;
	      }

	      return this.autoHide ? undefined : html$1(_templateObject2$f());
	    }
	  }, {
	    key: "handleMouseEvent",
	    value: function handleMouseEvent(event) {
	      if (this.facet) {
	        var mouseEvent = event;

	        switch (mouseEvent.type) {
	          case 'mousedown':
	            if (mouseEvent.currentTarget instanceof Element) {
	              if (mouseEvent.currentTarget === this.facet && mouseEvent.button === 1) {
	                this.mouseTarget = 'drag';
	                this.animatedScrolling = false;
	                event.preventDefault();
	                event.stopImmediatePropagation();
	              } else if (mouseEvent.currentTarget.className.indexOf('scrollbar-thumb') !== -1 && mouseEvent.button === 0) {
	                this.mouseTarget = 'thumb';
	                this.animatedScrolling = false;
	                event.preventDefault();
	                event.stopImmediatePropagation();
	              } else {
	                if (mouseEvent.currentTarget instanceof Element && mouseEvent.currentTarget.className.indexOf('scrollbar-area') !== -1) {
	                  if (mouseEvent.button === 0) {
	                    var scrollbarArea = this.renderRoot.querySelector('.scrollbar-area');

	                    if (scrollbarArea) {
	                      var domain = this.facet.domain;
	                      var domainLength = domain[1] - domain[0];
	                      var view = this.facet.view;
	                      var pageLength = Math.max(view[1] - view[0] - 1, 1);
	                      var scrollBB = scrollbarArea.getBoundingClientRect();
	                      var clickX = mouseEvent.clientX - scrollBB.x;
	                      var thumbLeft = (view[0] - domain[0]) / domainLength * scrollBB.width;
	                      var thumbRight = (view[1] - domain[0]) / domainLength * scrollBB.width;
	                      var distance = 0;

	                      if (clickX > thumbRight) {
	                        distance = Math.min(pageLength, domain[1] - view[1]);
	                      } else if (clickX < thumbLeft) {
	                        distance = Math.max(-pageLength, domain[0] - view[0]);
	                      }

	                      if (distance) {
	                        this.animatedScrollTo(distance);
	                      }
	                    }
	                  }

	                  event.preventDefault();
	                }

	                this.mouseTarget = null;
	              }

	              this.mouseX = mouseEvent.pageX;
	            }

	            break;

	          case 'mouseleave':
	          case 'mouseup':
	            this.mouseTarget = null;
	            this.requestUpdate();
	            break;

	          case 'mousemove':
	            if (this.mouseTarget) {
	              var _scrollbarArea = this.renderRoot.querySelector('.scrollbar-area');

	              if (_scrollbarArea) {
	                var _domain = this.facet.domain;

	                var _domainLength = _domain[1] - _domain[0];

	                var _view = this.facet.view;
	                var viewLength = _view[1] - _view[0];

	                var scrollWidth = _scrollbarArea.getBoundingClientRect().width;

	                var rangeStep;
	                var distanceMultiplier;

	                if (this.mouseTarget === 'drag') {
	                  rangeStep = scrollWidth / (viewLength + 1);
	                  distanceMultiplier = -1;
	                } else {
	                  rangeStep = scrollWidth / (_domainLength + 1);
	                  distanceMultiplier = 1;
	                }

	                if (this.mouseX !== null) {
	                  event.preventDefault();

	                  var _distance = Math.round((mouseEvent.pageX - this.mouseX) / rangeStep) * distanceMultiplier;

	                  if (_distance > 0) {
	                    _distance = Math.min(_distance, _domain[1] - _view[1]);
	                  } else if (_distance < 0) {
	                    _distance = Math.max(_distance, _domain[0] - _view[0]);
	                  }

	                  if (_distance) {
	                    this.facet.view = [_view[0] + _distance, _view[1] + _distance];
	                    this.mouseX += _distance * rangeStep * distanceMultiplier;
	                    this.requestUpdate();
	                  }
	                }
	              }
	            }

	            break;
	        }
	      }
	    }
	  }, {
	    key: "ensureMaxBarWidth",
	    value: function ensureMaxBarWidth() {
	      if (this.facet) {
	        var barArea = this.facet.barAreaElement;
	        var view = this.facet.view;

	        if (barArea) {
	          var maxBarCount = Math.floor(barArea.scrollWidth / this.minBarWidth);

	          if (view[1] - view[0] > maxBarCount) {
	            this.facet.view = [view[0], view[0] + maxBarCount];
	            this.requestUpdate();
	          }
	        }
	      }
	    }
	  }, {
	    key: "wheelHandler",
	    value: function wheelHandler(event) {
	      if (this.facet) {
	        var wheelEvent = event;
	        var timestamp = wheelEvent.timeStamp;
	        wheelEvent.preventDefault();

	        if (timestamp - this.lastWheelTime > this.wheelTimeThreshold) {
	          this.wheelDeltaXSum = wheelEvent.deltaX;
	          this.wheelDeltaYSum = wheelEvent.deltaY;
	          this.wheelScrollState = WheelScrollState.idle;
	        } else {
	          this.wheelDeltaXSum += wheelEvent.deltaX;
	          this.wheelDeltaYSum += wheelEvent.deltaY;
	        }

	        this.lastWheelTime = timestamp;
	        var viewLength = this.facet.view[1] - this.facet.view[0];
	        var deltaThreshold = this.wheelDeltaThreshold / (viewLength * 0.1);

	        if (this.wheelScrollState === WheelScrollState.idle) {
	          if (Math.abs(this.wheelDeltaXSum) >= deltaThreshold) {
	            this.wheelScrollState = WheelScrollState.enabled;
	            this.animatedScrolling = false;
	          } else if (Math.abs(this.wheelDeltaYSum) >= deltaThreshold) {
	            this.wheelScrollState = WheelScrollState.locked;
	          }
	        }

	        while (this.wheelScrollState === WheelScrollState.enabled && Math.abs(this.wheelDeltaXSum) >= deltaThreshold) {
	          var domain = this.facet.domain;
	          var view = this.facet.view;
	          var distance = void 0;

	          if (this.wheelDeltaXSum > 0) {
	            distance = Math.min(1, domain[1] - view[1]);
	            this.wheelDeltaXSum -= deltaThreshold;
	          } else {
	            distance = Math.max(-1, domain[0] - view[0]);
	            this.wheelDeltaXSum += deltaThreshold;
	          }

	          if (distance) {
	            this.facet.view = [view[0] + distance, view[1] + distance];
	            this.requestUpdate();
	          }
	        }
	      }
	    }
	  }, {
	    key: "animatedScrollTo",
	    value: function animatedScrollTo(distance) {
	      var _this2 = this;

	      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

	      if (this.facet) {
	        var startTime = performance.now();
	        var milliStep = distance / duration;
	        var start = this.facet.view;
	        this.animatedScrolling = true;
	        window.requestAnimationFrame(function (time) {
	          return _this2._animatedScrollTo(start, distance, 0, milliStep, time, time - startTime);
	        });
	      }
	    }
	  }, {
	    key: "_animatedScrollTo",
	    value: function _animatedScrollTo(start, distance, current, milliStep, time, delta) {
	      var _this3 = this;

	      if (this.facet && this.animatedScrolling && current !== distance) {
	        var newCurrent = current + milliStep * delta;

	        if (Math.abs(newCurrent) >= Math.abs(distance)) {
	          newCurrent = distance;
	        }

	        var offset = Math.floor(newCurrent);
	        var view = this.facet.view;
	        var newView = [start[0] + offset, start[1] + offset];

	        if (view[0] !== newView[0] || view[1] !== newView[1]) {
	          this.facet.view = newView;
	          this.requestUpdate();
	        }

	        window.requestAnimationFrame(function (newTime) {
	          _this3._animatedScrollTo(start, distance, newCurrent, milliStep, newTime, newTime - time);
	        });
	      } else {
	        this.animatedScrolling = false;
	      }
	    }
	  }], [{
	    key: "styles",
	    get: function get() {
	      return [css(_templateObject3$c(), unsafeCSS(ScrollbarStyle))];
	    }
	  }, {
	    key: "properties",
	    get: function get() {
	      return {
	        minBarWidth: {
	          type: Number,
	          attribute: 'min-bar-width'
	        },
	        autoHide: {
	          type: Object,
	          attribute: 'auto-hide'
	        },
	        roundCaps: {
	          type: Object,
	          attribute: 'round-caps'
	        }
	      };
	    }
	  }]);

	  return Scrollbar;
	}(FacetPlugin);

	Scrollbar = __decorate$1([customElement('facet-plugin-scrollbar')], Scrollbar);

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get ZoomBar () { return ZoomBar; },
		get ZoomControls () { return ZoomControls; },
		get Scrollbar () { return Scrollbar; }
	});

	var codemirror = createCommonjsModule(function (module, exports) {
	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE

	// This is CodeMirror (https://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .

	(function (global, factory) {
	   module.exports = factory() ;
	}(commonjsGlobal, (function () {
	  // Kludges for bugs and behavior differences that can't be feature
	  // detected are enabled based on userAgent etc sniffing.
	  var userAgent = navigator.userAgent;
	  var platform = navigator.platform;

	  var gecko = /gecko\/\d/i.test(userAgent);
	  var ie_upto10 = /MSIE \d/.test(userAgent);
	  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	  var edge = /Edge\/(\d+)/.exec(userAgent);
	  var ie = ie_upto10 || ie_11up || edge;
	  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
	  var webkit = !edge && /WebKit\//.test(userAgent);
	  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	  var chrome = !edge && /Chrome\//.test(userAgent);
	  var presto = /Opera\//.test(userAgent);
	  var safari = /Apple Computer/.test(navigator.vendor);
	  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	  var phantom = /PhantomJS/.test(userAgent);

	  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
	  var android = /Android/.test(userAgent);
	  // This is woefully incomplete. Suggestions for alternative methods welcome.
	  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	  var mac = ios || /Mac/.test(platform);
	  var chromeOS = /\bCrOS\b/.test(userAgent);
	  var windows = /win/i.test(platform);

	  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
	  if (presto_version) { presto_version = Number(presto_version[1]); }
	  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	  var captureRightClick = gecko || (ie && ie_version >= 9);

	  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

	  var rmClass = function(node, cls) {
	    var current = node.className;
	    var match = classTest(cls).exec(current);
	    if (match) {
	      var after = current.slice(match.index + match[0].length);
	      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	    }
	  };

	  function removeChildren(e) {
	    for (var count = e.childNodes.length; count > 0; --count)
	      { e.removeChild(e.firstChild); }
	    return e
	  }

	  function removeChildrenAndAdd(parent, e) {
	    return removeChildren(parent).appendChild(e)
	  }

	  function elt(tag, content, className, style) {
	    var e = document.createElement(tag);
	    if (className) { e.className = className; }
	    if (style) { e.style.cssText = style; }
	    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
	    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
	    return e
	  }
	  // wrapper for elt, which removes the elt from the accessibility tree
	  function eltP(tag, content, className, style) {
	    var e = elt(tag, content, className, style);
	    e.setAttribute("role", "presentation");
	    return e
	  }

	  var range;
	  if (document.createRange) { range = function(node, start, end, endNode) {
	    var r = document.createRange();
	    r.setEnd(endNode || node, end);
	    r.setStart(node, start);
	    return r
	  }; }
	  else { range = function(node, start, end) {
	    var r = document.body.createTextRange();
	    try { r.moveToElementText(node.parentNode); }
	    catch(e) { return r }
	    r.collapse(true);
	    r.moveEnd("character", end);
	    r.moveStart("character", start);
	    return r
	  }; }

	  function contains(parent, child) {
	    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	      { child = child.parentNode; }
	    if (parent.contains)
	      { return parent.contains(child) }
	    do {
	      if (child.nodeType == 11) { child = child.host; }
	      if (child == parent) { return true }
	    } while (child = child.parentNode)
	  }

	  function activeElt() {
	    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
	    // IE < 10 will throw when accessed while the page is loading or in an iframe.
	    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
	    var activeElement;
	    try {
	      activeElement = document.activeElement;
	    } catch(e) {
	      activeElement = document.body || null;
	    }
	    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
	      { activeElement = activeElement.shadowRoot.activeElement; }
	    return activeElement
	  }

	  function addClass(node, cls) {
	    var current = node.className;
	    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
	  }
	  function joinClasses(a, b) {
	    var as = a.split(" ");
	    for (var i = 0; i < as.length; i++)
	      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
	    return b
	  }

	  var selectInput = function(node) { node.select(); };
	  if (ios) // Mobile Safari apparently has a bug where select() is broken.
	    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
	  else if (ie) // Suppress mysterious IE10 errors
	    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

	  function bind(f) {
	    var args = Array.prototype.slice.call(arguments, 1);
	    return function(){return f.apply(null, args)}
	  }

	  function copyObj(obj, target, overwrite) {
	    if (!target) { target = {}; }
	    for (var prop in obj)
	      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	        { target[prop] = obj[prop]; } }
	    return target
	  }

	  // Counts the column offset in a string, taking tabs into account.
	  // Used mostly to find indentation.
	  function countColumn(string, end, tabSize, startIndex, startValue) {
	    if (end == null) {
	      end = string.search(/[^\s\u00a0]/);
	      if (end == -1) { end = string.length; }
	    }
	    for (var i = startIndex || 0, n = startValue || 0;;) {
	      var nextTab = string.indexOf("\t", i);
	      if (nextTab < 0 || nextTab >= end)
	        { return n + (end - i) }
	      n += nextTab - i;
	      n += tabSize - (n % tabSize);
	      i = nextTab + 1;
	    }
	  }

	  var Delayed = function() {
	    this.id = null;
	    this.f = null;
	    this.time = 0;
	    this.handler = bind(this.onTimeout, this);
	  };
	  Delayed.prototype.onTimeout = function (self) {
	    self.id = 0;
	    if (self.time <= +new Date) {
	      self.f();
	    } else {
	      setTimeout(self.handler, self.time - +new Date);
	    }
	  };
	  Delayed.prototype.set = function (ms, f) {
	    this.f = f;
	    var time = +new Date + ms;
	    if (!this.id || time < this.time) {
	      clearTimeout(this.id);
	      this.id = setTimeout(this.handler, ms);
	      this.time = time;
	    }
	  };

	  function indexOf(array, elt) {
	    for (var i = 0; i < array.length; ++i)
	      { if (array[i] == elt) { return i } }
	    return -1
	  }

	  // Number of pixels added to scroller and sizer to hide scrollbar
	  var scrollerGap = 50;

	  // Returned or thrown by various protocols to signal 'I'm not
	  // handling this'.
	  var Pass = {toString: function(){return "CodeMirror.Pass"}};

	  // Reused option objects for setSelection & friends
	  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

	  // The inverse of countColumn -- find the offset that corresponds to
	  // a particular column.
	  function findColumn(string, goal, tabSize) {
	    for (var pos = 0, col = 0;;) {
	      var nextTab = string.indexOf("\t", pos);
	      if (nextTab == -1) { nextTab = string.length; }
	      var skipped = nextTab - pos;
	      if (nextTab == string.length || col + skipped >= goal)
	        { return pos + Math.min(skipped, goal - col) }
	      col += nextTab - pos;
	      col += tabSize - (col % tabSize);
	      pos = nextTab + 1;
	      if (col >= goal) { return pos }
	    }
	  }

	  var spaceStrs = [""];
	  function spaceStr(n) {
	    while (spaceStrs.length <= n)
	      { spaceStrs.push(lst(spaceStrs) + " "); }
	    return spaceStrs[n]
	  }

	  function lst(arr) { return arr[arr.length-1] }

	  function map(array, f) {
	    var out = [];
	    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
	    return out
	  }

	  function insertSorted(array, value, score) {
	    var pos = 0, priority = score(value);
	    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
	    array.splice(pos, 0, value);
	  }

	  function nothing() {}

	  function createObj(base, props) {
	    var inst;
	    if (Object.create) {
	      inst = Object.create(base);
	    } else {
	      nothing.prototype = base;
	      inst = new nothing();
	    }
	    if (props) { copyObj(props, inst); }
	    return inst
	  }

	  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	  function isWordCharBasic(ch) {
	    return /\w/.test(ch) || ch > "\x80" &&
	      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
	  }
	  function isWordChar(ch, helper) {
	    if (!helper) { return isWordCharBasic(ch) }
	    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
	    return helper.test(ch)
	  }

	  function isEmpty(obj) {
	    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
	    return true
	  }

	  // Extending unicode characters. A series of a non-extending char +
	  // any number of extending chars is treated as a single unit as far
	  // as editing and measuring is concerned. This is not fully correct,
	  // since some scripts/fonts/browsers also treat other configurations
	  // of code points as a group.
	  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

	  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
	  function skipExtendingChars(str, pos, dir) {
	    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
	    return pos
	  }

	  // Returns the value from the range [`from`; `to`] that satisfies
	  // `pred` and is closest to `from`. Assumes that at least `to`
	  // satisfies `pred`. Supports `from` being greater than `to`.
	  function findFirst(pred, from, to) {
	    // At any point we are certain `to` satisfies `pred`, don't know
	    // whether `from` does.
	    var dir = from > to ? -1 : 1;
	    for (;;) {
	      if (from == to) { return from }
	      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
	      if (mid == from) { return pred(mid) ? from : to }
	      if (pred(mid)) { to = mid; }
	      else { from = mid + dir; }
	    }
	  }

	  // BIDI HELPERS

	  function iterateBidiSections(order, from, to, f) {
	    if (!order) { return f(from, to, "ltr", 0) }
	    var found = false;
	    for (var i = 0; i < order.length; ++i) {
	      var part = order[i];
	      if (part.from < to && part.to > from || from == to && part.to == from) {
	        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
	        found = true;
	      }
	    }
	    if (!found) { f(from, to, "ltr"); }
	  }

	  var bidiOther = null;
	  function getBidiPartAt(order, ch, sticky) {
	    var found;
	    bidiOther = null;
	    for (var i = 0; i < order.length; ++i) {
	      var cur = order[i];
	      if (cur.from < ch && cur.to > ch) { return i }
	      if (cur.to == ch) {
	        if (cur.from != cur.to && sticky == "before") { found = i; }
	        else { bidiOther = i; }
	      }
	      if (cur.from == ch) {
	        if (cur.from != cur.to && sticky != "before") { found = i; }
	        else { bidiOther = i; }
	      }
	    }
	    return found != null ? found : bidiOther
	  }

	  // Bidirectional ordering algorithm
	  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	  // that this (partially) implements.

	  // One-char codes used for character types:
	  // L (L):   Left-to-Right
	  // R (R):   Right-to-Left
	  // r (AL):  Right-to-Left Arabic
	  // 1 (EN):  European Number
	  // + (ES):  European Number Separator
	  // % (ET):  European Number Terminator
	  // n (AN):  Arabic Number
	  // , (CS):  Common Number Separator
	  // m (NSM): Non-Spacing Mark
	  // b (BN):  Boundary Neutral
	  // s (B):   Paragraph Separator
	  // t (S):   Segment Separator
	  // w (WS):  Whitespace
	  // N (ON):  Other Neutrals

	  // Returns null if characters are ordered as they appear
	  // (left-to-right), or an array of sections ({from, to, level}
	  // objects) in the order in which they occur visually.
	  var bidiOrdering = (function() {
	    // Character types for codepoints 0 to 0xff
	    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	    // Character types for codepoints 0x600 to 0x6f9
	    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
	    function charType(code) {
	      if (code <= 0xf7) { return lowTypes.charAt(code) }
	      else if (0x590 <= code && code <= 0x5f4) { return "R" }
	      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
	      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
	      else if (0x2000 <= code && code <= 0x200b) { return "w" }
	      else if (code == 0x200c) { return "b" }
	      else { return "L" }
	    }

	    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

	    function BidiSpan(level, from, to) {
	      this.level = level;
	      this.from = from; this.to = to;
	    }

	    return function(str, direction) {
	      var outerType = direction == "ltr" ? "L" : "R";

	      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
	      var len = str.length, types = [];
	      for (var i = 0; i < len; ++i)
	        { types.push(charType(str.charCodeAt(i))); }

	      // W1. Examine each non-spacing mark (NSM) in the level run, and
	      // change the type of the NSM to the type of the previous
	      // character. If the NSM is at the start of the level run, it will
	      // get the type of sor.
	      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
	        var type = types[i$1];
	        if (type == "m") { types[i$1] = prev; }
	        else { prev = type; }
	      }

	      // W2. Search backwards from each instance of a European number
	      // until the first strong type (R, L, AL, or sor) is found. If an
	      // AL is found, change the type of the European number to Arabic
	      // number.
	      // W3. Change all ALs to R.
	      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
	        var type$1 = types[i$2];
	        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
	        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
	      }

	      // W4. A single European separator between two European numbers
	      // changes to a European number. A single common separator between
	      // two numbers of the same type changes to that type.
	      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
	        var type$2 = types[i$3];
	        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
	        else if (type$2 == "," && prev$1 == types[i$3+1] &&
	                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
	        prev$1 = type$2;
	      }

	      // W5. A sequence of European terminators adjacent to European
	      // numbers changes to all European numbers.
	      // W6. Otherwise, separators and terminators change to Other
	      // Neutral.
	      for (var i$4 = 0; i$4 < len; ++i$4) {
	        var type$3 = types[i$4];
	        if (type$3 == ",") { types[i$4] = "N"; }
	        else if (type$3 == "%") {
	          var end = (void 0);
	          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
	          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	          for (var j = i$4; j < end; ++j) { types[j] = replace; }
	          i$4 = end - 1;
	        }
	      }

	      // W7. Search backwards from each instance of a European number
	      // until the first strong type (R, L, or sor) is found. If an L is
	      // found, then change the type of the European number to L.
	      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
	        var type$4 = types[i$5];
	        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
	        else if (isStrong.test(type$4)) { cur$1 = type$4; }
	      }

	      // N1. A sequence of neutrals takes the direction of the
	      // surrounding strong text if the text on both sides has the same
	      // direction. European and Arabic numbers act as if they were R in
	      // terms of their influence on neutrals. Start-of-level-run (sor)
	      // and end-of-level-run (eor) are used at level run boundaries.
	      // N2. Any remaining neutrals take the embedding direction.
	      for (var i$6 = 0; i$6 < len; ++i$6) {
	        if (isNeutral.test(types[i$6])) {
	          var end$1 = (void 0);
	          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
	          var before = (i$6 ? types[i$6-1] : outerType) == "L";
	          var after = (end$1 < len ? types[end$1] : outerType) == "L";
	          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
	          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
	          i$6 = end$1 - 1;
	        }
	      }

	      // Here we depart from the documented algorithm, in order to avoid
	      // building up an actual levels array. Since there are only three
	      // levels (0, 1, 2) in an implementation that doesn't take
	      // explicit embedding into account, we can build up the order on
	      // the fly, without following the level-based algorithm.
	      var order = [], m;
	      for (var i$7 = 0; i$7 < len;) {
	        if (countsAsLeft.test(types[i$7])) {
	          var start = i$7;
	          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
	          order.push(new BidiSpan(0, start, i$7));
	        } else {
	          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
	          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
	          for (var j$2 = pos; j$2 < i$7;) {
	            if (countsAsNum.test(types[j$2])) {
	              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
	              var nstart = j$2;
	              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
	              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
	              at += isRTL;
	              pos = j$2;
	            } else { ++j$2; }
	          }
	          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
	        }
	      }
	      if (direction == "ltr") {
	        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	          order[0].from = m[0].length;
	          order.unshift(new BidiSpan(0, 0, m[0].length));
	        }
	        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	          lst(order).to -= m[0].length;
	          order.push(new BidiSpan(0, len - m[0].length, len));
	        }
	      }

	      return direction == "rtl" ? order.reverse() : order
	    }
	  })();

	  // Get the bidi ordering for the given line (and cache it). Returns
	  // false for lines that are fully left-to-right, and an array of
	  // BidiSpan objects otherwise.
	  function getOrder(line, direction) {
	    var order = line.order;
	    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
	    return order
	  }

	  // EVENT HANDLING

	  // Lightweight event framework. on/off also work on DOM nodes,
	  // registering native DOM handlers.

	  var noHandlers = [];

	  var on = function(emitter, type, f) {
	    if (emitter.addEventListener) {
	      emitter.addEventListener(type, f, false);
	    } else if (emitter.attachEvent) {
	      emitter.attachEvent("on" + type, f);
	    } else {
	      var map = emitter._handlers || (emitter._handlers = {});
	      map[type] = (map[type] || noHandlers).concat(f);
	    }
	  };

	  function getHandlers(emitter, type) {
	    return emitter._handlers && emitter._handlers[type] || noHandlers
	  }

	  function off(emitter, type, f) {
	    if (emitter.removeEventListener) {
	      emitter.removeEventListener(type, f, false);
	    } else if (emitter.detachEvent) {
	      emitter.detachEvent("on" + type, f);
	    } else {
	      var map = emitter._handlers, arr = map && map[type];
	      if (arr) {
	        var index = indexOf(arr, f);
	        if (index > -1)
	          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
	      }
	    }
	  }

	  function signal(emitter, type /*, values...*/) {
	    var handlers = getHandlers(emitter, type);
	    if (!handlers.length) { return }
	    var args = Array.prototype.slice.call(arguments, 2);
	    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
	  }

	  // The DOM events that CodeMirror handles can be overridden by
	  // registering a (non-DOM) handler on the editor for the event name,
	  // and preventDefault-ing the event in that handler.
	  function signalDOMEvent(cm, e, override) {
	    if (typeof e == "string")
	      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
	    signal(cm, override || e.type, cm, e);
	    return e_defaultPrevented(e) || e.codemirrorIgnore
	  }

	  function signalCursorActivity(cm) {
	    var arr = cm._handlers && cm._handlers.cursorActivity;
	    if (!arr) { return }
	    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
	      { set.push(arr[i]); } }
	  }

	  function hasHandler(emitter, type) {
	    return getHandlers(emitter, type).length > 0
	  }

	  // Add on and off methods to a constructor's prototype, to make
	  // registering events on such objects more convenient.
	  function eventMixin(ctor) {
	    ctor.prototype.on = function(type, f) {on(this, type, f);};
	    ctor.prototype.off = function(type, f) {off(this, type, f);};
	  }

	  // Due to the fact that we still support jurassic IE versions, some
	  // compatibility wrappers are needed.

	  function e_preventDefault(e) {
	    if (e.preventDefault) { e.preventDefault(); }
	    else { e.returnValue = false; }
	  }
	  function e_stopPropagation(e) {
	    if (e.stopPropagation) { e.stopPropagation(); }
	    else { e.cancelBubble = true; }
	  }
	  function e_defaultPrevented(e) {
	    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
	  }
	  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

	  function e_target(e) {return e.target || e.srcElement}
	  function e_button(e) {
	    var b = e.which;
	    if (b == null) {
	      if (e.button & 1) { b = 1; }
	      else if (e.button & 2) { b = 3; }
	      else if (e.button & 4) { b = 2; }
	    }
	    if (mac && e.ctrlKey && b == 1) { b = 3; }
	    return b
	  }

	  // Detect drag-and-drop
	  var dragAndDrop = function() {
	    // There is *some* kind of drag-and-drop support in IE6-8, but I
	    // couldn't get it to work yet.
	    if (ie && ie_version < 9) { return false }
	    var div = elt('div');
	    return "draggable" in div || "dragDrop" in div
	  }();

	  var zwspSupported;
	  function zeroWidthElement(measure) {
	    if (zwspSupported == null) {
	      var test = elt("span", "\u200b");
	      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	      if (measure.firstChild.offsetHeight != 0)
	        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
	    }
	    var node = zwspSupported ? elt("span", "\u200b") :
	      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	    node.setAttribute("cm-text", "");
	    return node
	  }

	  // Feature-detect IE's crummy client rect reporting for bidi text
	  var badBidiRects;
	  function hasBadBidiRects(measure) {
	    if (badBidiRects != null) { return badBidiRects }
	    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	    var r0 = range(txt, 0, 1).getBoundingClientRect();
	    var r1 = range(txt, 1, 2).getBoundingClientRect();
	    removeChildren(measure);
	    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
	    return badBidiRects = (r1.right - r0.right < 3)
	  }

	  // See if "".split is the broken IE version, if so, provide an
	  // alternative way to split lines.
	  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
	    var pos = 0, result = [], l = string.length;
	    while (pos <= l) {
	      var nl = string.indexOf("\n", pos);
	      if (nl == -1) { nl = string.length; }
	      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	      var rt = line.indexOf("\r");
	      if (rt != -1) {
	        result.push(line.slice(0, rt));
	        pos += rt + 1;
	      } else {
	        result.push(line);
	        pos = nl + 1;
	      }
	    }
	    return result
	  } : function (string) { return string.split(/\r\n?|\n/); };

	  var hasSelection = window.getSelection ? function (te) {
	    try { return te.selectionStart != te.selectionEnd }
	    catch(e) { return false }
	  } : function (te) {
	    var range;
	    try {range = te.ownerDocument.selection.createRange();}
	    catch(e) {}
	    if (!range || range.parentElement() != te) { return false }
	    return range.compareEndPoints("StartToEnd", range) != 0
	  };

	  var hasCopyEvent = (function () {
	    var e = elt("div");
	    if ("oncopy" in e) { return true }
	    e.setAttribute("oncopy", "return;");
	    return typeof e.oncopy == "function"
	  })();

	  var badZoomedRects = null;
	  function hasBadZoomedRects(measure) {
	    if (badZoomedRects != null) { return badZoomedRects }
	    var node = removeChildrenAndAdd(measure, elt("span", "x"));
	    var normal = node.getBoundingClientRect();
	    var fromRange = range(node, 0, 1).getBoundingClientRect();
	    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
	  }

	  // Known modes, by name and by MIME
	  var modes = {}, mimeModes = {};

	  // Extra arguments are stored as the mode's dependencies, which is
	  // used by (legacy) mechanisms like loadmode.js to automatically
	  // load a mode. (Preferred mechanism is the require/define calls.)
	  function defineMode(name, mode) {
	    if (arguments.length > 2)
	      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
	    modes[name] = mode;
	  }

	  function defineMIME(mime, spec) {
	    mimeModes[mime] = spec;
	  }

	  // Given a MIME type, a {name, ...options} config object, or a name
	  // string, return a mode config object.
	  function resolveMode(spec) {
	    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	      spec = mimeModes[spec];
	    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	      var found = mimeModes[spec.name];
	      if (typeof found == "string") { found = {name: found}; }
	      spec = createObj(found, spec);
	      spec.name = found.name;
	    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	      return resolveMode("application/xml")
	    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	      return resolveMode("application/json")
	    }
	    if (typeof spec == "string") { return {name: spec} }
	    else { return spec || {name: "null"} }
	  }

	  // Given a mode spec (anything that resolveMode accepts), find and
	  // initialize an actual mode object.
	  function getMode(options, spec) {
	    spec = resolveMode(spec);
	    var mfactory = modes[spec.name];
	    if (!mfactory) { return getMode(options, "text/plain") }
	    var modeObj = mfactory(options, spec);
	    if (modeExtensions.hasOwnProperty(spec.name)) {
	      var exts = modeExtensions[spec.name];
	      for (var prop in exts) {
	        if (!exts.hasOwnProperty(prop)) { continue }
	        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
	        modeObj[prop] = exts[prop];
	      }
	    }
	    modeObj.name = spec.name;
	    if (spec.helperType) { modeObj.helperType = spec.helperType; }
	    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
	      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

	    return modeObj
	  }

	  // This can be used to attach properties to mode objects from
	  // outside the actual mode definition.
	  var modeExtensions = {};
	  function extendMode(mode, properties) {
	    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	    copyObj(properties, exts);
	  }

	  function copyState(mode, state) {
	    if (state === true) { return state }
	    if (mode.copyState) { return mode.copyState(state) }
	    var nstate = {};
	    for (var n in state) {
	      var val = state[n];
	      if (val instanceof Array) { val = val.concat([]); }
	      nstate[n] = val;
	    }
	    return nstate
	  }

	  // Given a mode and a state (for that mode), find the inner mode and
	  // state at the position that the state refers to.
	  function innerMode(mode, state) {
	    var info;
	    while (mode.innerMode) {
	      info = mode.innerMode(state);
	      if (!info || info.mode == mode) { break }
	      state = info.state;
	      mode = info.mode;
	    }
	    return info || {mode: mode, state: state}
	  }

	  function startState(mode, a1, a2) {
	    return mode.startState ? mode.startState(a1, a2) : true
	  }

	  // STRING STREAM

	  // Fed to the mode parsers, provides helper functions to make
	  // parsers more succinct.

	  var StringStream = function(string, tabSize, lineOracle) {
	    this.pos = this.start = 0;
	    this.string = string;
	    this.tabSize = tabSize || 8;
	    this.lastColumnPos = this.lastColumnValue = 0;
	    this.lineStart = 0;
	    this.lineOracle = lineOracle;
	  };

	  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
	  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
	  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
	  StringStream.prototype.next = function () {
	    if (this.pos < this.string.length)
	      { return this.string.charAt(this.pos++) }
	  };
	  StringStream.prototype.eat = function (match) {
	    var ch = this.string.charAt(this.pos);
	    var ok;
	    if (typeof match == "string") { ok = ch == match; }
	    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
	    if (ok) {++this.pos; return ch}
	  };
	  StringStream.prototype.eatWhile = function (match) {
	    var start = this.pos;
	    while (this.eat(match)){}
	    return this.pos > start
	  };
	  StringStream.prototype.eatSpace = function () {
	    var start = this.pos;
	    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
	    return this.pos > start
	  };
	  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
	  StringStream.prototype.skipTo = function (ch) {
	    var found = this.string.indexOf(ch, this.pos);
	    if (found > -1) {this.pos = found; return true}
	  };
	  StringStream.prototype.backUp = function (n) {this.pos -= n;};
	  StringStream.prototype.column = function () {
	    if (this.lastColumnPos < this.start) {
	      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	      this.lastColumnPos = this.start;
	    }
	    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	  };
	  StringStream.prototype.indentation = function () {
	    return countColumn(this.string, null, this.tabSize) -
	      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	  };
	  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
	    if (typeof pattern == "string") {
	      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
	      var substr = this.string.substr(this.pos, pattern.length);
	      if (cased(substr) == cased(pattern)) {
	        if (consume !== false) { this.pos += pattern.length; }
	        return true
	      }
	    } else {
	      var match = this.string.slice(this.pos).match(pattern);
	      if (match && match.index > 0) { return null }
	      if (match && consume !== false) { this.pos += match[0].length; }
	      return match
	    }
	  };
	  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
	  StringStream.prototype.hideFirstChars = function (n, inner) {
	    this.lineStart += n;
	    try { return inner() }
	    finally { this.lineStart -= n; }
	  };
	  StringStream.prototype.lookAhead = function (n) {
	    var oracle = this.lineOracle;
	    return oracle && oracle.lookAhead(n)
	  };
	  StringStream.prototype.baseToken = function () {
	    var oracle = this.lineOracle;
	    return oracle && oracle.baseToken(this.pos)
	  };

	  // Find the line object corresponding to the given line number.
	  function getLine(doc, n) {
	    n -= doc.first;
	    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
	    var chunk = doc;
	    while (!chunk.lines) {
	      for (var i = 0;; ++i) {
	        var child = chunk.children[i], sz = child.chunkSize();
	        if (n < sz) { chunk = child; break }
	        n -= sz;
	      }
	    }
	    return chunk.lines[n]
	  }

	  // Get the part of a document between two positions, as an array of
	  // strings.
	  function getBetween(doc, start, end) {
	    var out = [], n = start.line;
	    doc.iter(start.line, end.line + 1, function (line) {
	      var text = line.text;
	      if (n == end.line) { text = text.slice(0, end.ch); }
	      if (n == start.line) { text = text.slice(start.ch); }
	      out.push(text);
	      ++n;
	    });
	    return out
	  }
	  // Get the lines between from and to, as array of strings.
	  function getLines(doc, from, to) {
	    var out = [];
	    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
	    return out
	  }

	  // Update the height of a line, propagating the height change
	  // upwards to parent nodes.
	  function updateLineHeight(line, height) {
	    var diff = height - line.height;
	    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
	  }

	  // Given a line object, find its line number by walking up through
	  // its parent links.
	  function lineNo(line) {
	    if (line.parent == null) { return null }
	    var cur = line.parent, no = indexOf(cur.lines, line);
	    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	      for (var i = 0;; ++i) {
	        if (chunk.children[i] == cur) { break }
	        no += chunk.children[i].chunkSize();
	      }
	    }
	    return no + cur.first
	  }

	  // Find the line at the given vertical position, using the height
	  // information in the document tree.
	  function lineAtHeight(chunk, h) {
	    var n = chunk.first;
	    outer: do {
	      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
	        var child = chunk.children[i$1], ch = child.height;
	        if (h < ch) { chunk = child; continue outer }
	        h -= ch;
	        n += child.chunkSize();
	      }
	      return n
	    } while (!chunk.lines)
	    var i = 0;
	    for (; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i], lh = line.height;
	      if (h < lh) { break }
	      h -= lh;
	    }
	    return n + i
	  }

	  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

	  function lineNumberFor(options, i) {
	    return String(options.lineNumberFormatter(i + options.firstLineNumber))
	  }

	  // A Pos instance represents a position within the text.
	  function Pos(line, ch, sticky) {
	    if ( sticky === void 0 ) sticky = null;

	    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
	    this.line = line;
	    this.ch = ch;
	    this.sticky = sticky;
	  }

	  // Compare two positions, return 0 if they are the same, a negative
	  // number when a is less, and a positive number otherwise.
	  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

	  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

	  function copyPos(x) {return Pos(x.line, x.ch)}
	  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
	  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

	  // Most of the external API clips given positions to make sure they
	  // actually exist within the document.
	  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
	  function clipPos(doc, pos) {
	    if (pos.line < doc.first) { return Pos(doc.first, 0) }
	    var last = doc.first + doc.size - 1;
	    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
	    return clipToLen(pos, getLine(doc, pos.line).text.length)
	  }
	  function clipToLen(pos, linelen) {
	    var ch = pos.ch;
	    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
	    else if (ch < 0) { return Pos(pos.line, 0) }
	    else { return pos }
	  }
	  function clipPosArray(doc, array) {
	    var out = [];
	    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
	    return out
	  }

	  var SavedContext = function(state, lookAhead) {
	    this.state = state;
	    this.lookAhead = lookAhead;
	  };

	  var Context = function(doc, state, line, lookAhead) {
	    this.state = state;
	    this.doc = doc;
	    this.line = line;
	    this.maxLookAhead = lookAhead || 0;
	    this.baseTokens = null;
	    this.baseTokenPos = 1;
	  };

	  Context.prototype.lookAhead = function (n) {
	    var line = this.doc.getLine(this.line + n);
	    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
	    return line
	  };

	  Context.prototype.baseToken = function (n) {
	    if (!this.baseTokens) { return null }
	    while (this.baseTokens[this.baseTokenPos] <= n)
	      { this.baseTokenPos += 2; }
	    var type = this.baseTokens[this.baseTokenPos + 1];
	    return {type: type && type.replace(/( |^)overlay .*/, ""),
	            size: this.baseTokens[this.baseTokenPos] - n}
	  };

	  Context.prototype.nextLine = function () {
	    this.line++;
	    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
	  };

	  Context.fromSaved = function (doc, saved, line) {
	    if (saved instanceof SavedContext)
	      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
	    else
	      { return new Context(doc, copyState(doc.mode, saved), line) }
	  };

	  Context.prototype.save = function (copy) {
	    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
	    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
	  };


	  // Compute a style array (an array starting with a mode generation
	  // -- for invalidation -- followed by pairs of end positions and
	  // style strings), which is used to highlight the tokens on the
	  // line.
	  function highlightLine(cm, line, context, forceToEnd) {
	    // A styles array always starts with a number identifying the
	    // mode/overlays that it is based on (for easy invalidation).
	    var st = [cm.state.modeGen], lineClasses = {};
	    // Compute the base array of styles
	    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
	            lineClasses, forceToEnd);
	    var state = context.state;

	    // Run overlays, adjust style array.
	    var loop = function ( o ) {
	      context.baseTokens = st;
	      var overlay = cm.state.overlays[o], i = 1, at = 0;
	      context.state = true;
	      runMode(cm, line.text, overlay.mode, context, function (end, style) {
	        var start = i;
	        // Ensure there's a token end at the current position, and that i points at it
	        while (at < end) {
	          var i_end = st[i];
	          if (i_end > end)
	            { st.splice(i, 1, end, st[i+1], i_end); }
	          i += 2;
	          at = Math.min(end, i_end);
	        }
	        if (!style) { return }
	        if (overlay.opaque) {
	          st.splice(start, i - start, end, "overlay " + style);
	          i = start + 2;
	        } else {
	          for (; start < i; start += 2) {
	            var cur = st[start+1];
	            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
	          }
	        }
	      }, lineClasses);
	      context.state = state;
	      context.baseTokens = null;
	      context.baseTokenPos = 1;
	    };

	    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

	    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
	  }

	  function getLineStyles(cm, line, updateFrontier) {
	    if (!line.styles || line.styles[0] != cm.state.modeGen) {
	      var context = getContextBefore(cm, lineNo(line));
	      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
	      var result = highlightLine(cm, line, context);
	      if (resetState) { context.state = resetState; }
	      line.stateAfter = context.save(!resetState);
	      line.styles = result.styles;
	      if (result.classes) { line.styleClasses = result.classes; }
	      else if (line.styleClasses) { line.styleClasses = null; }
	      if (updateFrontier === cm.doc.highlightFrontier)
	        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
	    }
	    return line.styles
	  }

	  function getContextBefore(cm, n, precise) {
	    var doc = cm.doc, display = cm.display;
	    if (!doc.mode.startState) { return new Context(doc, true, n) }
	    var start = findStartLine(cm, n, precise);
	    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
	    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

	    doc.iter(start, n, function (line) {
	      processLine(cm, line.text, context);
	      var pos = context.line;
	      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
	      context.nextLine();
	    });
	    if (precise) { doc.modeFrontier = context.line; }
	    return context
	  }

	  // Lightweight form of highlight -- proceed over this line and
	  // update state, but don't save a style array. Used for lines that
	  // aren't currently visible.
	  function processLine(cm, text, context, startAt) {
	    var mode = cm.doc.mode;
	    var stream = new StringStream(text, cm.options.tabSize, context);
	    stream.start = stream.pos = startAt || 0;
	    if (text == "") { callBlankLine(mode, context.state); }
	    while (!stream.eol()) {
	      readToken(mode, stream, context.state);
	      stream.start = stream.pos;
	    }
	  }

	  function callBlankLine(mode, state) {
	    if (mode.blankLine) { return mode.blankLine(state) }
	    if (!mode.innerMode) { return }
	    var inner = innerMode(mode, state);
	    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
	  }

	  function readToken(mode, stream, state, inner) {
	    for (var i = 0; i < 10; i++) {
	      if (inner) { inner[0] = innerMode(mode, state).mode; }
	      var style = mode.token(stream, state);
	      if (stream.pos > stream.start) { return style }
	    }
	    throw new Error("Mode " + mode.name + " failed to advance stream.")
	  }

	  var Token = function(stream, type, state) {
	    this.start = stream.start; this.end = stream.pos;
	    this.string = stream.current();
	    this.type = type || null;
	    this.state = state;
	  };

	  // Utility for getTokenAt and getLineTokens
	  function takeToken(cm, pos, precise, asArray) {
	    var doc = cm.doc, mode = doc.mode, style;
	    pos = clipPos(doc, pos);
	    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
	    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
	    if (asArray) { tokens = []; }
	    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	      stream.start = stream.pos;
	      style = readToken(mode, stream, context.state);
	      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
	    }
	    return asArray ? tokens : new Token(stream, style, context.state)
	  }

	  function extractLineClasses(type, output) {
	    if (type) { for (;;) {
	      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	      if (!lineClass) { break }
	      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	      var prop = lineClass[1] ? "bgClass" : "textClass";
	      if (output[prop] == null)
	        { output[prop] = lineClass[2]; }
	      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
	        { output[prop] += " " + lineClass[2]; }
	    } }
	    return type
	  }

	  // Run the given mode's parser over a line, calling f for each token.
	  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
	    var flattenSpans = mode.flattenSpans;
	    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
	    var curStart = 0, curStyle = null;
	    var stream = new StringStream(text, cm.options.tabSize, context), style;
	    var inner = cm.options.addModeClass && [null];
	    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
	    while (!stream.eol()) {
	      if (stream.pos > cm.options.maxHighlightLength) {
	        flattenSpans = false;
	        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
	        stream.pos = text.length;
	        style = null;
	      } else {
	        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
	      }
	      if (inner) {
	        var mName = inner[0].name;
	        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
	      }
	      if (!flattenSpans || curStyle != style) {
	        while (curStart < stream.start) {
	          curStart = Math.min(stream.start, curStart + 5000);
	          f(curStart, curStyle);
	        }
	        curStyle = style;
	      }
	      stream.start = stream.pos;
	    }
	    while (curStart < stream.pos) {
	      // Webkit seems to refuse to render text nodes longer than 57444
	      // characters, and returns inaccurate measurements in nodes
	      // starting around 5000 chars.
	      var pos = Math.min(stream.pos, curStart + 5000);
	      f(pos, curStyle);
	      curStart = pos;
	    }
	  }

	  // Finds the line to start with when starting a parse. Tries to
	  // find a line with a stateAfter, so that it can start with a
	  // valid state. If that fails, it returns the line with the
	  // smallest indentation, which tends to need the least context to
	  // parse correctly.
	  function findStartLine(cm, n, precise) {
	    var minindent, minline, doc = cm.doc;
	    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	    for (var search = n; search > lim; --search) {
	      if (search <= doc.first) { return doc.first }
	      var line = getLine(doc, search - 1), after = line.stateAfter;
	      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
	        { return search }
	      var indented = countColumn(line.text, null, cm.options.tabSize);
	      if (minline == null || minindent > indented) {
	        minline = search - 1;
	        minindent = indented;
	      }
	    }
	    return minline
	  }

	  function retreatFrontier(doc, n) {
	    doc.modeFrontier = Math.min(doc.modeFrontier, n);
	    if (doc.highlightFrontier < n - 10) { return }
	    var start = doc.first;
	    for (var line = n - 1; line > start; line--) {
	      var saved = getLine(doc, line).stateAfter;
	      // change is on 3
	      // state on line 1 looked ahead 2 -- so saw 3
	      // test 1 + 2 < 3 should cover this
	      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
	        start = line + 1;
	        break
	      }
	    }
	    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
	  }

	  // Optimize some code when these features are not used.
	  var sawReadOnlySpans = false, sawCollapsedSpans = false;

	  function seeReadOnlySpans() {
	    sawReadOnlySpans = true;
	  }

	  function seeCollapsedSpans() {
	    sawCollapsedSpans = true;
	  }

	  // TEXTMARKER SPANS

	  function MarkedSpan(marker, from, to) {
	    this.marker = marker;
	    this.from = from; this.to = to;
	  }

	  // Search an array of spans for a span matching the given marker.
	  function getMarkedSpanFor(spans, marker) {
	    if (spans) { for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.marker == marker) { return span }
	    } }
	  }
	  // Remove a span from an array, returning undefined if no spans are
	  // left (we don't store arrays for lines without spans).
	  function removeMarkedSpan(spans, span) {
	    var r;
	    for (var i = 0; i < spans.length; ++i)
	      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
	    return r
	  }
	  // Add a span to a line.
	  function addMarkedSpan(line, span) {
	    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	    span.marker.attachLine(line);
	  }

	  // Used for the algorithm that adjusts markers for a change in the
	  // document. These functions cut an array of spans at a given
	  // character position, returning an array of remaining chunks (or
	  // undefined if nothing remains).
	  function markedSpansBefore(old, startCh, isInsert) {
	    var nw;
	    if (old) { for (var i = 0; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
	        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	      }
	    } }
	    return nw
	  }
	  function markedSpansAfter(old, endCh, isInsert) {
	    var nw;
	    if (old) { for (var i = 0; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
	        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                              span.to == null ? null : span.to - endCh));
	      }
	    } }
	    return nw
	  }

	  // Given a change object, compute the new set of marker spans that
	  // cover the line in which the change took place. Removes spans
	  // entirely within the change, reconnects spans belonging to the
	  // same marker that appear on both sides of the change, and cuts off
	  // spans partially within the change. Returns an array of span
	  // arrays with one element for each line in (after) the change.
	  function stretchSpansOverChange(doc, change) {
	    if (change.full) { return null }
	    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	    if (!oldFirst && !oldLast) { return null }

	    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	    // Get the spans that 'stick out' on both sides
	    var first = markedSpansBefore(oldFirst, startCh, isInsert);
	    var last = markedSpansAfter(oldLast, endCh, isInsert);

	    // Next, merge those two ends
	    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	    if (first) {
	      // Fix up .to properties of first
	      for (var i = 0; i < first.length; ++i) {
	        var span = first[i];
	        if (span.to == null) {
	          var found = getMarkedSpanFor(last, span.marker);
	          if (!found) { span.to = startCh; }
	          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
	        }
	      }
	    }
	    if (last) {
	      // Fix up .from in last (or move them into first in case of sameLine)
	      for (var i$1 = 0; i$1 < last.length; ++i$1) {
	        var span$1 = last[i$1];
	        if (span$1.to != null) { span$1.to += offset; }
	        if (span$1.from == null) {
	          var found$1 = getMarkedSpanFor(first, span$1.marker);
	          if (!found$1) {
	            span$1.from = offset;
	            if (sameLine) { (first || (first = [])).push(span$1); }
	          }
	        } else {
	          span$1.from += offset;
	          if (sameLine) { (first || (first = [])).push(span$1); }
	        }
	      }
	    }
	    // Make sure we didn't create any zero-length spans
	    if (first) { first = clearEmptySpans(first); }
	    if (last && last != first) { last = clearEmptySpans(last); }

	    var newMarkers = [first];
	    if (!sameLine) {
	      // Fill gap with whole-line-spans
	      var gap = change.text.length - 2, gapMarkers;
	      if (gap > 0 && first)
	        { for (var i$2 = 0; i$2 < first.length; ++i$2)
	          { if (first[i$2].to == null)
	            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
	      for (var i$3 = 0; i$3 < gap; ++i$3)
	        { newMarkers.push(gapMarkers); }
	      newMarkers.push(last);
	    }
	    return newMarkers
	  }

	  // Remove spans that are empty and don't have a clearWhenEmpty
	  // option of false.
	  function clearEmptySpans(spans) {
	    for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	        { spans.splice(i--, 1); }
	    }
	    if (!spans.length) { return null }
	    return spans
	  }

	  // Used to 'clip' out readOnly ranges when making a change.
	  function removeReadOnlyRanges(doc, from, to) {
	    var markers = null;
	    doc.iter(from.line, to.line + 1, function (line) {
	      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	        var mark = line.markedSpans[i].marker;
	        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	          { (markers || (markers = [])).push(mark); }
	      } }
	    });
	    if (!markers) { return null }
	    var parts = [{from: from, to: to}];
	    for (var i = 0; i < markers.length; ++i) {
	      var mk = markers[i], m = mk.find(0);
	      for (var j = 0; j < parts.length; ++j) {
	        var p = parts[j];
	        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
	        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	          { newParts.push({from: p.from, to: m.from}); }
	        if (dto > 0 || !mk.inclusiveRight && !dto)
	          { newParts.push({from: m.to, to: p.to}); }
	        parts.splice.apply(parts, newParts);
	        j += newParts.length - 3;
	      }
	    }
	    return parts
	  }

	  // Connect or disconnect spans from a line.
	  function detachMarkedSpans(line) {
	    var spans = line.markedSpans;
	    if (!spans) { return }
	    for (var i = 0; i < spans.length; ++i)
	      { spans[i].marker.detachLine(line); }
	    line.markedSpans = null;
	  }
	  function attachMarkedSpans(line, spans) {
	    if (!spans) { return }
	    for (var i = 0; i < spans.length; ++i)
	      { spans[i].marker.attachLine(line); }
	    line.markedSpans = spans;
	  }

	  // Helpers used when computing which overlapping collapsed span
	  // counts as the larger one.
	  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
	  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

	  // Returns a number indicating which of two overlapping collapsed
	  // spans is larger (and thus includes the other). Falls back to
	  // comparing ids when the spans cover exactly the same range.
	  function compareCollapsedMarkers(a, b) {
	    var lenDiff = a.lines.length - b.lines.length;
	    if (lenDiff != 0) { return lenDiff }
	    var aPos = a.find(), bPos = b.find();
	    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	    if (fromCmp) { return -fromCmp }
	    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	    if (toCmp) { return toCmp }
	    return b.id - a.id
	  }

	  // Find out whether a line ends or starts in a collapsed span. If
	  // so, return the marker for that span.
	  function collapsedSpanAtSide(line, start) {
	    var sps = sawCollapsedSpans && line.markedSpans, found;
	    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	        { found = sp.marker; }
	    } }
	    return found
	  }
	  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
	  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

	  function collapsedSpanAround(line, ch) {
	    var sps = sawCollapsedSpans && line.markedSpans, found;
	    if (sps) { for (var i = 0; i < sps.length; ++i) {
	      var sp = sps[i];
	      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
	          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
	    } }
	    return found
	  }

	  // Test whether there exists a collapsed span that partially
	  // overlaps (covers the start or end, but not both) of a new span.
	  // Such overlap is not allowed.
	  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
	    var line = getLine(doc, lineNo);
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) { for (var i = 0; i < sps.length; ++i) {
	      var sp = sps[i];
	      if (!sp.marker.collapsed) { continue }
	      var found = sp.marker.find(0);
	      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
	      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	        { return true }
	    } }
	  }

	  // A visual line is a line as drawn on the screen. Folding, for
	  // example, can cause multiple logical lines to appear on the same
	  // visual line. This finds the start of the visual line that the
	  // given line is part of (usually that is the line itself).
	  function visualLine(line) {
	    var merged;
	    while (merged = collapsedSpanAtStart(line))
	      { line = merged.find(-1, true).line; }
	    return line
	  }

	  function visualLineEnd(line) {
	    var merged;
	    while (merged = collapsedSpanAtEnd(line))
	      { line = merged.find(1, true).line; }
	    return line
	  }

	  // Returns an array of logical lines that continue the visual line
	  // started by the argument, or undefined if there are no such lines.
	  function visualLineContinued(line) {
	    var merged, lines;
	    while (merged = collapsedSpanAtEnd(line)) {
	      line = merged.find(1, true).line
	      ;(lines || (lines = [])).push(line);
	    }
	    return lines
	  }

	  // Get the line number of the start of the visual line that the
	  // given line number is part of.
	  function visualLineNo(doc, lineN) {
	    var line = getLine(doc, lineN), vis = visualLine(line);
	    if (line == vis) { return lineN }
	    return lineNo(vis)
	  }

	  // Get the line number of the start of the next visual line after
	  // the given line.
	  function visualLineEndNo(doc, lineN) {
	    if (lineN > doc.lastLine()) { return lineN }
	    var line = getLine(doc, lineN), merged;
	    if (!lineIsHidden(doc, line)) { return lineN }
	    while (merged = collapsedSpanAtEnd(line))
	      { line = merged.find(1, true).line; }
	    return lineNo(line) + 1
	  }

	  // Compute whether a line is hidden. Lines count as hidden when they
	  // are part of a visual line that starts with another line, or when
	  // they are entirely covered by collapsed, non-widget span.
	  function lineIsHidden(doc, line) {
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (!sp.marker.collapsed) { continue }
	      if (sp.from == null) { return true }
	      if (sp.marker.widgetNode) { continue }
	      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	        { return true }
	    } }
	  }
	  function lineIsHiddenInner(doc, line, span) {
	    if (span.to == null) {
	      var end = span.marker.find(1, true);
	      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
	    }
	    if (span.marker.inclusiveRight && span.to == line.text.length)
	      { return true }
	    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
	      sp = line.markedSpans[i];
	      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	          (sp.to == null || sp.to != span.from) &&
	          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	          lineIsHiddenInner(doc, line, sp)) { return true }
	    }
	  }

	  // Find the height above the given line.
	  function heightAtLine(lineObj) {
	    lineObj = visualLine(lineObj);

	    var h = 0, chunk = lineObj.parent;
	    for (var i = 0; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i];
	      if (line == lineObj) { break }
	      else { h += line.height; }
	    }
	    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
	        var cur = p.children[i$1];
	        if (cur == chunk) { break }
	        else { h += cur.height; }
	      }
	    }
	    return h
	  }

	  // Compute the character length of a line, taking into account
	  // collapsed ranges (see markText) that might hide parts, and join
	  // other lines onto it.
	  function lineLength(line) {
	    if (line.height == 0) { return 0 }
	    var len = line.text.length, merged, cur = line;
	    while (merged = collapsedSpanAtStart(cur)) {
	      var found = merged.find(0, true);
	      cur = found.from.line;
	      len += found.from.ch - found.to.ch;
	    }
	    cur = line;
	    while (merged = collapsedSpanAtEnd(cur)) {
	      var found$1 = merged.find(0, true);
	      len -= cur.text.length - found$1.from.ch;
	      cur = found$1.to.line;
	      len += cur.text.length - found$1.to.ch;
	    }
	    return len
	  }

	  // Find the longest line in the document.
	  function findMaxLine(cm) {
	    var d = cm.display, doc = cm.doc;
	    d.maxLine = getLine(doc, doc.first);
	    d.maxLineLength = lineLength(d.maxLine);
	    d.maxLineChanged = true;
	    doc.iter(function (line) {
	      var len = lineLength(line);
	      if (len > d.maxLineLength) {
	        d.maxLineLength = len;
	        d.maxLine = line;
	      }
	    });
	  }

	  // LINE DATA STRUCTURE

	  // Line objects. These hold state related to a line, including
	  // highlighting info (the styles array).
	  var Line = function(text, markedSpans, estimateHeight) {
	    this.text = text;
	    attachMarkedSpans(this, markedSpans);
	    this.height = estimateHeight ? estimateHeight(this) : 1;
	  };

	  Line.prototype.lineNo = function () { return lineNo(this) };
	  eventMixin(Line);

	  // Change the content (text, markers) of a line. Automatically
	  // invalidates cached information and tries to re-estimate the
	  // line's height.
	  function updateLine(line, text, markedSpans, estimateHeight) {
	    line.text = text;
	    if (line.stateAfter) { line.stateAfter = null; }
	    if (line.styles) { line.styles = null; }
	    if (line.order != null) { line.order = null; }
	    detachMarkedSpans(line);
	    attachMarkedSpans(line, markedSpans);
	    var estHeight = estimateHeight ? estimateHeight(line) : 1;
	    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	  }

	  // Detach a line from the document tree and its markers.
	  function cleanUpLine(line) {
	    line.parent = null;
	    detachMarkedSpans(line);
	  }

	  // Convert a style as returned by a mode (either null, or a string
	  // containing one or more styles) to a CSS style. This is cached,
	  // and also looks for line-wide styles.
	  var styleToClassCache = {}, styleToClassCacheWithMode = {};
	  function interpretTokenStyle(style, options) {
	    if (!style || /^\s*$/.test(style)) { return null }
	    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	    return cache[style] ||
	      (cache[style] = style.replace(/\S+/g, "cm-$&"))
	  }

	  // Render the DOM representation of the text of a line. Also builds
	  // up a 'line map', which points at the DOM nodes that represent
	  // specific stretches of text, and is used by the measuring code.
	  // The returned object contains the DOM node, this map, and
	  // information about line-wide styles that were set by the mode.
	  function buildLineContent(cm, lineView) {
	    // The padding-right forces the element to have a 'border', which
	    // is needed on Webkit to be able to get line-level bounding
	    // rectangles for it (in measureChar).
	    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
	    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
	                   col: 0, pos: 0, cm: cm,
	                   trailingSpace: false,
	                   splitSpaces: cm.getOption("lineWrapping")};
	    lineView.measure = {};

	    // Iterate over the logical lines that make up this visual line.
	    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
	      builder.pos = 0;
	      builder.addToken = buildToken;
	      // Optionally wire in some hacks into the token-rendering
	      // algorithm, to deal with browser quirks.
	      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
	        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
	      builder.map = [];
	      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	      if (line.styleClasses) {
	        if (line.styleClasses.bgClass)
	          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
	        if (line.styleClasses.textClass)
	          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
	      }

	      // Ensure at least a single node is present, for measuring.
	      if (builder.map.length == 0)
	        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

	      // Store the map and a cache object for the current logical line
	      if (i == 0) {
	        lineView.measure.map = builder.map;
	        lineView.measure.cache = {};
	      } else {
	  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
	        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
	      }
	    }

	    // See issue #2901
	    if (webkit) {
	      var last = builder.content.lastChild;
	      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	        { builder.content.className = "cm-tab-wrap-hack"; }
	    }

	    signal(cm, "renderLine", cm, lineView.line, builder.pre);
	    if (builder.pre.className)
	      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

	    return builder
	  }

	  function defaultSpecialCharPlaceholder(ch) {
	    var token = elt("span", "\u2022", "cm-invalidchar");
	    token.title = "\\u" + ch.charCodeAt(0).toString(16);
	    token.setAttribute("aria-label", token.title);
	    return token
	  }

	  // Build up the DOM representation for a single token, and add it to
	  // the line map. Takes care to render special characters separately.
	  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
	    if (!text) { return }
	    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
	    var special = builder.cm.state.specialChars, mustWrap = false;
	    var content;
	    if (!special.test(text)) {
	      builder.col += text.length;
	      content = document.createTextNode(displayText);
	      builder.map.push(builder.pos, builder.pos + text.length, content);
	      if (ie && ie_version < 9) { mustWrap = true; }
	      builder.pos += text.length;
	    } else {
	      content = document.createDocumentFragment();
	      var pos = 0;
	      while (true) {
	        special.lastIndex = pos;
	        var m = special.exec(text);
	        var skipped = m ? m.index - pos : text.length - pos;
	        if (skipped) {
	          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
	          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
	          else { content.appendChild(txt); }
	          builder.map.push(builder.pos, builder.pos + skipped, txt);
	          builder.col += skipped;
	          builder.pos += skipped;
	        }
	        if (!m) { break }
	        pos += skipped + 1;
	        var txt$1 = (void 0);
	        if (m[0] == "\t") {
	          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	          txt$1.setAttribute("role", "presentation");
	          txt$1.setAttribute("cm-text", "\t");
	          builder.col += tabWidth;
	        } else if (m[0] == "\r" || m[0] == "\n") {
	          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	          txt$1.setAttribute("cm-text", m[0]);
	          builder.col += 1;
	        } else {
	          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
	          txt$1.setAttribute("cm-text", m[0]);
	          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
	          else { content.appendChild(txt$1); }
	          builder.col += 1;
	        }
	        builder.map.push(builder.pos, builder.pos + 1, txt$1);
	        builder.pos++;
	      }
	    }
	    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
	    if (style || startStyle || endStyle || mustWrap || css) {
	      var fullStyle = style || "";
	      if (startStyle) { fullStyle += startStyle; }
	      if (endStyle) { fullStyle += endStyle; }
	      var token = elt("span", [content], fullStyle, css);
	      if (attributes) {
	        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
	          { token.setAttribute(attr, attributes[attr]); } }
	      }
	      return builder.content.appendChild(token)
	    }
	    builder.content.appendChild(content);
	  }

	  // Change some spaces to NBSP to prevent the browser from collapsing
	  // trailing spaces at the end of a line when rendering text (issue #1362).
	  function splitSpaces(text, trailingBefore) {
	    if (text.length > 1 && !/  /.test(text)) { return text }
	    var spaceBefore = trailingBefore, result = "";
	    for (var i = 0; i < text.length; i++) {
	      var ch = text.charAt(i);
	      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	        { ch = "\u00a0"; }
	      result += ch;
	      spaceBefore = ch == " ";
	    }
	    return result
	  }

	  // Work around nonsense dimensions being reported for stretches of
	  // right-to-left text.
	  function buildTokenBadBidi(inner, order) {
	    return function (builder, text, style, startStyle, endStyle, css, attributes) {
	      style = style ? style + " cm-force-border" : "cm-force-border";
	      var start = builder.pos, end = start + text.length;
	      for (;;) {
	        // Find the part that overlaps with the start of this text
	        var part = (void 0);
	        for (var i = 0; i < order.length; i++) {
	          part = order[i];
	          if (part.to > start && part.from <= start) { break }
	        }
	        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
	        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
	        startStyle = null;
	        text = text.slice(part.to - start);
	        start = part.to;
	      }
	    }
	  }

	  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	    var widget = !ignoreWidget && marker.widgetNode;
	    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
	    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	      if (!widget)
	        { widget = builder.content.appendChild(document.createElement("span")); }
	      widget.setAttribute("cm-marker", marker.id);
	    }
	    if (widget) {
	      builder.cm.display.input.setUneditable(widget);
	      builder.content.appendChild(widget);
	    }
	    builder.pos += size;
	    builder.trailingSpace = false;
	  }

	  // Outputs a number of spans to make up a line, taking highlighting
	  // and marked text into account.
	  function insertLineContent(line, builder, styles) {
	    var spans = line.markedSpans, allText = line.text, at = 0;
	    if (!spans) {
	      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
	        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
	      return
	    }

	    var len = allText.length, pos = 0, i = 1, text = "", style, css;
	    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
	    for (;;) {
	      if (nextChange == pos) { // Update current marker set
	        spanStyle = spanEndStyle = spanStartStyle = css = "";
	        attributes = null;
	        collapsed = null; nextChange = Infinity;
	        var foundBookmarks = [], endStyles = (void 0);
	        for (var j = 0; j < spans.length; ++j) {
	          var sp = spans[j], m = sp.marker;
	          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	            foundBookmarks.push(m);
	          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	              nextChange = sp.to;
	              spanEndStyle = "";
	            }
	            if (m.className) { spanStyle += " " + m.className; }
	            if (m.css) { css = (css ? css + ";" : "") + m.css; }
	            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
	            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
	            // support for the old title property
	            // https://github.com/codemirror/CodeMirror/pull/5673
	            if (m.title) { (attributes || (attributes = {})).title = m.title; }
	            if (m.attributes) {
	              for (var attr in m.attributes)
	                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
	            }
	            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	              { collapsed = sp; }
	          } else if (sp.from > pos && nextChange > sp.from) {
	            nextChange = sp.from;
	          }
	        }
	        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
	          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

	        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
	          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
	        if (collapsed && (collapsed.from || 0) == pos) {
	          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                             collapsed.marker, collapsed.from == null);
	          if (collapsed.to == null) { return }
	          if (collapsed.to == pos) { collapsed = false; }
	        }
	      }
	      if (pos >= len) { break }

	      var upto = Math.min(len, nextChange);
	      while (true) {
	        if (text) {
	          var end = pos + text.length;
	          if (!collapsed) {
	            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
	          }
	          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
	          pos = end;
	          spanStartStyle = "";
	        }
	        text = allText.slice(at, at = styles[i++]);
	        style = interpretTokenStyle(styles[i++], builder.cm.options);
	      }
	    }
	  }


	  // These objects are used to represent the visible (currently drawn)
	  // part of the document. A LineView may correspond to multiple
	  // logical lines, if those are connected by collapsed ranges.
	  function LineView(doc, line, lineN) {
	    // The starting line
	    this.line = line;
	    // Continuing lines, if any
	    this.rest = visualLineContinued(line);
	    // Number of logical lines in this visual line
	    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	    this.node = this.text = null;
	    this.hidden = lineIsHidden(doc, line);
	  }

	  // Create a range of LineView objects for the given lines.
	  function buildViewArray(cm, from, to) {
	    var array = [], nextPos;
	    for (var pos = from; pos < to; pos = nextPos) {
	      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	      nextPos = pos + view.size;
	      array.push(view);
	    }
	    return array
	  }

	  var operationGroup = null;

	  function pushOperation(op) {
	    if (operationGroup) {
	      operationGroup.ops.push(op);
	    } else {
	      op.ownsGroup = operationGroup = {
	        ops: [op],
	        delayedCallbacks: []
	      };
	    }
	  }

	  function fireCallbacksForOps(group) {
	    // Calls delayed callbacks and cursorActivity handlers until no
	    // new ones appear
	    var callbacks = group.delayedCallbacks, i = 0;
	    do {
	      for (; i < callbacks.length; i++)
	        { callbacks[i].call(null); }
	      for (var j = 0; j < group.ops.length; j++) {
	        var op = group.ops[j];
	        if (op.cursorActivityHandlers)
	          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
	      }
	    } while (i < callbacks.length)
	  }

	  function finishOperation(op, endCb) {
	    var group = op.ownsGroup;
	    if (!group) { return }

	    try { fireCallbacksForOps(group); }
	    finally {
	      operationGroup = null;
	      endCb(group);
	    }
	  }

	  var orphanDelayedCallbacks = null;

	  // Often, we want to signal events at a point where we are in the
	  // middle of some work, but don't want the handler to start calling
	  // other methods on the editor, which might be in an inconsistent
	  // state or simply not expect any other events to happen.
	  // signalLater looks whether there are any handlers, and schedules
	  // them to be executed when the last operation ends, or, if no
	  // operation is active, when a timeout fires.
	  function signalLater(emitter, type /*, values...*/) {
	    var arr = getHandlers(emitter, type);
	    if (!arr.length) { return }
	    var args = Array.prototype.slice.call(arguments, 2), list;
	    if (operationGroup) {
	      list = operationGroup.delayedCallbacks;
	    } else if (orphanDelayedCallbacks) {
	      list = orphanDelayedCallbacks;
	    } else {
	      list = orphanDelayedCallbacks = [];
	      setTimeout(fireOrphanDelayed, 0);
	    }
	    var loop = function ( i ) {
	      list.push(function () { return arr[i].apply(null, args); });
	    };

	    for (var i = 0; i < arr.length; ++i)
	      loop( i );
	  }

	  function fireOrphanDelayed() {
	    var delayed = orphanDelayedCallbacks;
	    orphanDelayedCallbacks = null;
	    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
	  }

	  // When an aspect of a line changes, a string is added to
	  // lineView.changes. This updates the relevant part of the line's
	  // DOM structure.
	  function updateLineForChanges(cm, lineView, lineN, dims) {
	    for (var j = 0; j < lineView.changes.length; j++) {
	      var type = lineView.changes[j];
	      if (type == "text") { updateLineText(cm, lineView); }
	      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
	      else if (type == "class") { updateLineClasses(cm, lineView); }
	      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
	    }
	    lineView.changes = null;
	  }

	  // Lines with gutter elements, widgets or a background class need to
	  // be wrapped, and have the extra elements added to the wrapper div
	  function ensureLineWrapped(lineView) {
	    if (lineView.node == lineView.text) {
	      lineView.node = elt("div", null, null, "position: relative");
	      if (lineView.text.parentNode)
	        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
	      lineView.node.appendChild(lineView.text);
	      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
	    }
	    return lineView.node
	  }

	  function updateLineBackground(cm, lineView) {
	    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	    if (cls) { cls += " CodeMirror-linebackground"; }
	    if (lineView.background) {
	      if (cls) { lineView.background.className = cls; }
	      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	    } else if (cls) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	      cm.display.input.setUneditable(lineView.background);
	    }
	  }

	  // Wrapper around buildLineContent which will reuse the structure
	  // in display.externalMeasured when possible.
	  function getLineContent(cm, lineView) {
	    var ext = cm.display.externalMeasured;
	    if (ext && ext.line == lineView.line) {
	      cm.display.externalMeasured = null;
	      lineView.measure = ext.measure;
	      return ext.built
	    }
	    return buildLineContent(cm, lineView)
	  }

	  // Redraw the line's text. Interacts with the background and text
	  // classes because the mode may output tokens that influence these
	  // classes.
	  function updateLineText(cm, lineView) {
	    var cls = lineView.text.className;
	    var built = getLineContent(cm, lineView);
	    if (lineView.text == lineView.node) { lineView.node = built.pre; }
	    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	    lineView.text = built.pre;
	    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	      lineView.bgClass = built.bgClass;
	      lineView.textClass = built.textClass;
	      updateLineClasses(cm, lineView);
	    } else if (cls) {
	      lineView.text.className = cls;
	    }
	  }

	  function updateLineClasses(cm, lineView) {
	    updateLineBackground(cm, lineView);
	    if (lineView.line.wrapClass)
	      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
	    else if (lineView.node != lineView.text)
	      { lineView.node.className = ""; }
	    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	    lineView.text.className = textClass || "";
	  }

	  function updateLineGutter(cm, lineView, lineN, dims) {
	    if (lineView.gutter) {
	      lineView.node.removeChild(lineView.gutter);
	      lineView.gutter = null;
	    }
	    if (lineView.gutterBackground) {
	      lineView.node.removeChild(lineView.gutterBackground);
	      lineView.gutterBackground = null;
	    }
	    if (lineView.line.gutterClass) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
	      cm.display.input.setUneditable(lineView.gutterBackground);
	      wrap.insertBefore(lineView.gutterBackground, lineView.text);
	    }
	    var markers = lineView.line.gutterMarkers;
	    if (cm.options.lineNumbers || markers) {
	      var wrap$1 = ensureLineWrapped(lineView);
	      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
	      cm.display.input.setUneditable(gutterWrap);
	      wrap$1.insertBefore(gutterWrap, lineView.text);
	      if (lineView.line.gutterClass)
	        { gutterWrap.className += " " + lineView.line.gutterClass; }
	      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	        { lineView.lineNumber = gutterWrap.appendChild(
	          elt("div", lineNumberFor(cm.options, lineN),
	              "CodeMirror-linenumber CodeMirror-gutter-elt",
	              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
	      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
	        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
	        if (found)
	          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
	                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
	      } }
	    }
	  }

	  function updateLineWidgets(cm, lineView, dims) {
	    if (lineView.alignable) { lineView.alignable = null; }
	    var isWidget = classTest("CodeMirror-linewidget");
	    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
	      next = node.nextSibling;
	      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
	    }
	    insertLineWidgets(cm, lineView, dims);
	  }

	  // Build a line's DOM representation from scratch
	  function buildLineElement(cm, lineView, lineN, dims) {
	    var built = getLineContent(cm, lineView);
	    lineView.text = lineView.node = built.pre;
	    if (built.bgClass) { lineView.bgClass = built.bgClass; }
	    if (built.textClass) { lineView.textClass = built.textClass; }

	    updateLineClasses(cm, lineView);
	    updateLineGutter(cm, lineView, lineN, dims);
	    insertLineWidgets(cm, lineView, dims);
	    return lineView.node
	  }

	  // A lineView may contain multiple logical lines (when merged by
	  // collapsed spans). The widgets for all of them need to be drawn.
	  function insertLineWidgets(cm, lineView, dims) {
	    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
	    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
	  }

	  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	    if (!line.widgets) { return }
	    var wrap = ensureLineWrapped(lineView);
	    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
	      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
	      positionLineWidget(widget, node, lineView, dims);
	      cm.display.input.setUneditable(node);
	      if (allowAbove && widget.above)
	        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
	      else
	        { wrap.appendChild(node); }
	      signalLater(widget, "redraw");
	    }
	  }

	  function positionLineWidget(widget, node, lineView, dims) {
	    if (widget.noHScroll) {
	  (lineView.alignable || (lineView.alignable = [])).push(node);
	      var width = dims.wrapperWidth;
	      node.style.left = dims.fixedPos + "px";
	      if (!widget.coverGutter) {
	        width -= dims.gutterTotalWidth;
	        node.style.paddingLeft = dims.gutterTotalWidth + "px";
	      }
	      node.style.width = width + "px";
	    }
	    if (widget.coverGutter) {
	      node.style.zIndex = 5;
	      node.style.position = "relative";
	      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
	    }
	  }

	  function widgetHeight(widget) {
	    if (widget.height != null) { return widget.height }
	    var cm = widget.doc.cm;
	    if (!cm) { return 0 }
	    if (!contains(document.body, widget.node)) {
	      var parentStyle = "position: relative;";
	      if (widget.coverGutter)
	        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
	      if (widget.noHScroll)
	        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
	      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	    }
	    return widget.height = widget.node.parentNode.offsetHeight
	  }

	  // Return true when the given mouse event happened in a widget
	  function eventInWidget(display, e) {
	    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	          (n.parentNode == display.sizer && n != display.mover))
	        { return true }
	    }
	  }

	  // POSITION MEASUREMENT

	  function paddingTop(display) {return display.lineSpace.offsetTop}
	  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
	  function paddingH(display) {
	    if (display.cachedPaddingH) { return display.cachedPaddingH }
	    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
	    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
	    return data
	  }

	  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
	  function displayWidth(cm) {
	    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
	  }
	  function displayHeight(cm) {
	    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
	  }

	  // Ensure the lineView.wrapping.heights array is populated. This is
	  // an array of bottom offsets for the lines that make up a drawn
	  // line. When lineWrapping is on, there might be more than one
	  // height.
	  function ensureLineHeights(cm, lineView, rect) {
	    var wrapping = cm.options.lineWrapping;
	    var curWidth = wrapping && displayWidth(cm);
	    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	      var heights = lineView.measure.heights = [];
	      if (wrapping) {
	        lineView.measure.width = curWidth;
	        var rects = lineView.text.firstChild.getClientRects();
	        for (var i = 0; i < rects.length - 1; i++) {
	          var cur = rects[i], next = rects[i + 1];
	          if (Math.abs(cur.bottom - next.bottom) > 2)
	            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
	        }
	      }
	      heights.push(rect.bottom - rect.top);
	    }
	  }

	  // Find a line map (mapping character offsets to text nodes) and a
	  // measurement cache for the given line number. (A line view might
	  // contain multiple lines when collapsed ranges are present.)
	  function mapFromLineView(lineView, line, lineN) {
	    if (lineView.line == line)
	      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
	    for (var i = 0; i < lineView.rest.length; i++)
	      { if (lineView.rest[i] == line)
	        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
	    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
	      { if (lineNo(lineView.rest[i$1]) > lineN)
	        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
	  }

	  // Render a line into the hidden node display.externalMeasured. Used
	  // when measurement is needed for a line that's not in the viewport.
	  function updateExternalMeasurement(cm, line) {
	    line = visualLine(line);
	    var lineN = lineNo(line);
	    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	    view.lineN = lineN;
	    var built = view.built = buildLineContent(cm, view);
	    view.text = built.pre;
	    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	    return view
	  }

	  // Get a {top, bottom, left, right} box (in line-local coordinates)
	  // for a given character.
	  function measureChar(cm, line, ch, bias) {
	    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
	  }

	  // Find a line view that corresponds to the given line number.
	  function findViewForLine(cm, lineN) {
	    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	      { return cm.display.view[findViewIndex(cm, lineN)] }
	    var ext = cm.display.externalMeasured;
	    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	      { return ext }
	  }

	  // Measurement can be split in two steps, the set-up work that
	  // applies to the whole line, and the measurement of the actual
	  // character. Functions like coordsChar, that need to do a lot of
	  // measurements in a row, can thus ensure that the set-up work is
	  // only done once.
	  function prepareMeasureForLine(cm, line) {
	    var lineN = lineNo(line);
	    var view = findViewForLine(cm, lineN);
	    if (view && !view.text) {
	      view = null;
	    } else if (view && view.changes) {
	      updateLineForChanges(cm, view, lineN, getDimensions(cm));
	      cm.curOp.forceUpdate = true;
	    }
	    if (!view)
	      { view = updateExternalMeasurement(cm, line); }

	    var info = mapFromLineView(view, line, lineN);
	    return {
	      line: line, view: view, rect: null,
	      map: info.map, cache: info.cache, before: info.before,
	      hasHeights: false
	    }
	  }

	  // Given a prepared measurement object, measures the position of an
	  // actual character (or fetches it from the cache).
	  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	    if (prepared.before) { ch = -1; }
	    var key = ch + (bias || ""), found;
	    if (prepared.cache.hasOwnProperty(key)) {
	      found = prepared.cache[key];
	    } else {
	      if (!prepared.rect)
	        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
	      if (!prepared.hasHeights) {
	        ensureLineHeights(cm, prepared.view, prepared.rect);
	        prepared.hasHeights = true;
	      }
	      found = measureCharInner(cm, prepared, ch, bias);
	      if (!found.bogus) { prepared.cache[key] = found; }
	    }
	    return {left: found.left, right: found.right,
	            top: varHeight ? found.rtop : found.top,
	            bottom: varHeight ? found.rbottom : found.bottom}
	  }

	  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

	  function nodeAndOffsetInLineMap(map, ch, bias) {
	    var node, start, end, collapse, mStart, mEnd;
	    // First, search the line map for the text node corresponding to,
	    // or closest to, the target character.
	    for (var i = 0; i < map.length; i += 3) {
	      mStart = map[i];
	      mEnd = map[i + 1];
	      if (ch < mStart) {
	        start = 0; end = 1;
	        collapse = "left";
	      } else if (ch < mEnd) {
	        start = ch - mStart;
	        end = start + 1;
	      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
	        end = mEnd - mStart;
	        start = end - 1;
	        if (ch >= mEnd) { collapse = "right"; }
	      }
	      if (start != null) {
	        node = map[i + 2];
	        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	          { collapse = bias; }
	        if (bias == "left" && start == 0)
	          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
	            node = map[(i -= 3) + 2];
	            collapse = "left";
	          } }
	        if (bias == "right" && start == mEnd - mStart)
	          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
	            node = map[(i += 3) + 2];
	            collapse = "right";
	          } }
	        break
	      }
	    }
	    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
	  }

	  function getUsefulRect(rects, bias) {
	    var rect = nullRect;
	    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
	      if ((rect = rects[i]).left != rect.right) { break }
	    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
	      if ((rect = rects[i$1]).left != rect.right) { break }
	    } }
	    return rect
	  }

	  function measureCharInner(cm, prepared, ch, bias) {
	    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

	    var rect;
	    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
	        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
	        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	          { rect = node.parentNode.getBoundingClientRect(); }
	        else
	          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
	        if (rect.left || rect.right || start == 0) { break }
	        end = start;
	        start = start - 1;
	        collapse = "right";
	      }
	      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
	    } else { // If it is a widget, simply get the box for the whole widget.
	      if (start > 0) { collapse = bias = "right"; }
	      var rects;
	      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
	      else
	        { rect = node.getBoundingClientRect(); }
	    }
	    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	      var rSpan = node.parentNode.getClientRects()[0];
	      if (rSpan)
	        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
	      else
	        { rect = nullRect; }
	    }

	    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	    var mid = (rtop + rbot) / 2;
	    var heights = prepared.view.measure.heights;
	    var i = 0;
	    for (; i < heights.length - 1; i++)
	      { if (mid < heights[i]) { break } }
	    var top = i ? heights[i - 1] : 0, bot = heights[i];
	    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                  top: top, bottom: bot};
	    if (!rect.left && !rect.right) { result.bogus = true; }
	    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

	    return result
	  }

	  // Work around problem with bounding client rects on ranges being
	  // returned incorrectly when zoomed on IE10 and below.
	  function maybeUpdateRectForZooming(measure, rect) {
	    if (!window.screen || screen.logicalXDPI == null ||
	        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	      { return rect }
	    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	    return {left: rect.left * scaleX, right: rect.right * scaleX,
	            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
	  }

	  function clearLineMeasurementCacheFor(lineView) {
	    if (lineView.measure) {
	      lineView.measure.cache = {};
	      lineView.measure.heights = null;
	      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	        { lineView.measure.caches[i] = {}; } }
	    }
	  }

	  function clearLineMeasurementCache(cm) {
	    cm.display.externalMeasure = null;
	    removeChildren(cm.display.lineMeasure);
	    for (var i = 0; i < cm.display.view.length; i++)
	      { clearLineMeasurementCacheFor(cm.display.view[i]); }
	  }

	  function clearCaches(cm) {
	    clearLineMeasurementCache(cm);
	    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
	    cm.display.lineNumChars = null;
	  }

	  function pageScrollX() {
	    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
	    // which causes page_Offset and bounding client rects to use
	    // different reference viewports and invalidate our calculations.
	    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
	    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
	  }
	  function pageScrollY() {
	    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
	    return window.pageYOffset || (document.documentElement || document.body).scrollTop
	  }

	  function widgetTopHeight(lineObj) {
	    var height = 0;
	    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
	      { height += widgetHeight(lineObj.widgets[i]); } } }
	    return height
	  }

	  // Converts a {top, bottom, left, right} box from line-local
	  // coordinates into another coordinate system. Context may be one of
	  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
	  // or "page".
	  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
	    if (!includeWidgets) {
	      var height = widgetTopHeight(lineObj);
	      rect.top += height; rect.bottom += height;
	    }
	    if (context == "line") { return rect }
	    if (!context) { context = "local"; }
	    var yOff = heightAtLine(lineObj);
	    if (context == "local") { yOff += paddingTop(cm.display); }
	    else { yOff -= cm.display.viewOffset; }
	    if (context == "page" || context == "window") {
	      var lOff = cm.display.lineSpace.getBoundingClientRect();
	      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	      rect.left += xOff; rect.right += xOff;
	    }
	    rect.top += yOff; rect.bottom += yOff;
	    return rect
	  }

	  // Coverts a box from "div" coords to another coordinate system.
	  // Context may be "window", "page", "div", or "local"./null.
	  function fromCoordSystem(cm, coords, context) {
	    if (context == "div") { return coords }
	    var left = coords.left, top = coords.top;
	    // First move into "page" coordinate system
	    if (context == "page") {
	      left -= pageScrollX();
	      top -= pageScrollY();
	    } else if (context == "local" || !context) {
	      var localBox = cm.display.sizer.getBoundingClientRect();
	      left += localBox.left;
	      top += localBox.top;
	    }

	    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
	  }

	  function charCoords(cm, pos, context, lineObj, bias) {
	    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
	    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
	  }

	  // Returns a box for a given cursor position, which may have an
	  // 'other' property containing the position of the secondary cursor
	  // on a bidi boundary.
	  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
	  // and after `char - 1` in writing order of `char - 1`
	  // A cursor Pos(line, char, "after") is on the same visual line as `char`
	  // and before `char` in writing order of `char`
	  // Examples (upper-case letters are RTL, lower-case are LTR):
	  //     Pos(0, 1, ...)
	  //     before   after
	  // ab     a|b     a|b
	  // aB     a|B     aB|
	  // Ab     |Ab     A|b
	  // AB     B|A     B|A
	  // Every position after the last character on a line is considered to stick
	  // to the last character on the line.
	  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	    lineObj = lineObj || getLine(cm.doc, pos.line);
	    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	    function get(ch, right) {
	      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	      if (right) { m.left = m.right; } else { m.right = m.left; }
	      return intoCoordSystem(cm, lineObj, m, context)
	    }
	    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
	    if (ch >= lineObj.text.length) {
	      ch = lineObj.text.length;
	      sticky = "before";
	    } else if (ch <= 0) {
	      ch = 0;
	      sticky = "after";
	    }
	    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

	    function getBidi(ch, partPos, invert) {
	      var part = order[partPos], right = part.level == 1;
	      return get(invert ? ch - 1 : ch, right != invert)
	    }
	    var partPos = getBidiPartAt(order, ch, sticky);
	    var other = bidiOther;
	    var val = getBidi(ch, partPos, sticky == "before");
	    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
	    return val
	  }

	  // Used to cheaply estimate the coordinates for a position. Used for
	  // intermediate scroll updates.
	  function estimateCoords(cm, pos) {
	    var left = 0;
	    pos = clipPos(cm.doc, pos);
	    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
	    var lineObj = getLine(cm.doc, pos.line);
	    var top = heightAtLine(lineObj) + paddingTop(cm.display);
	    return {left: left, right: left, top: top, bottom: top + lineObj.height}
	  }

	  // Positions returned by coordsChar contain some extra information.
	  // xRel is the relative x position of the input coordinates compared
	  // to the found position (so xRel > 0 means the coordinates are to
	  // the right of the character position, for example). When outside
	  // is true, that means the coordinates lie outside the line's
	  // vertical range.
	  function PosWithInfo(line, ch, sticky, outside, xRel) {
	    var pos = Pos(line, ch, sticky);
	    pos.xRel = xRel;
	    if (outside) { pos.outside = outside; }
	    return pos
	  }

	  // Compute the character position closest to the given coordinates.
	  // Input must be lineSpace-local ("div" coordinate system).
	  function coordsChar(cm, x, y) {
	    var doc = cm.doc;
	    y += cm.display.viewOffset;
	    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
	    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	    if (lineN > last)
	      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
	    if (x < 0) { x = 0; }

	    var lineObj = getLine(doc, lineN);
	    for (;;) {
	      var found = coordsCharInner(cm, lineObj, lineN, x, y);
	      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
	      if (!collapsed) { return found }
	      var rangeEnd = collapsed.find(1);
	      if (rangeEnd.line == lineN) { return rangeEnd }
	      lineObj = getLine(doc, lineN = rangeEnd.line);
	    }
	  }

	  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
	    y -= widgetTopHeight(lineObj);
	    var end = lineObj.text.length;
	    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
	    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
	    return {begin: begin, end: end}
	  }

	  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
	    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
	    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
	  }

	  // Returns true if the given side of a box is after the given
	  // coordinates, in top-to-bottom, left-to-right order.
	  function boxIsAfter(box, x, y, left) {
	    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
	  }

	  function coordsCharInner(cm, lineObj, lineNo, x, y) {
	    // Move y into line-local coordinate space
	    y -= heightAtLine(lineObj);
	    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
	    // When directly calling `measureCharPrepared`, we have to adjust
	    // for the widgets at this line.
	    var widgetHeight = widgetTopHeight(lineObj);
	    var begin = 0, end = lineObj.text.length, ltr = true;

	    var order = getOrder(lineObj, cm.doc.direction);
	    // If the line isn't plain left-to-right text, first figure out
	    // which bidi section the coordinates fall into.
	    if (order) {
	      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
	                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
	      ltr = part.level != 1;
	      // The awkward -1 offsets are needed because findFirst (called
	      // on these below) will treat its first bound as inclusive,
	      // second as exclusive, but we want to actually address the
	      // characters in the part's range
	      begin = ltr ? part.from : part.to - 1;
	      end = ltr ? part.to : part.from - 1;
	    }

	    // A binary search to find the first character whose bounding box
	    // starts after the coordinates. If we run across any whose box wrap
	    // the coordinates, store that.
	    var chAround = null, boxAround = null;
	    var ch = findFirst(function (ch) {
	      var box = measureCharPrepared(cm, preparedMeasure, ch);
	      box.top += widgetHeight; box.bottom += widgetHeight;
	      if (!boxIsAfter(box, x, y, false)) { return false }
	      if (box.top <= y && box.left <= x) {
	        chAround = ch;
	        boxAround = box;
	      }
	      return true
	    }, begin, end);

	    var baseX, sticky, outside = false;
	    // If a box around the coordinates was found, use that
	    if (boxAround) {
	      // Distinguish coordinates nearer to the left or right side of the box
	      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
	      ch = chAround + (atStart ? 0 : 1);
	      sticky = atStart ? "after" : "before";
	      baseX = atLeft ? boxAround.left : boxAround.right;
	    } else {
	      // (Adjust for extended bound, if necessary.)
	      if (!ltr && (ch == end || ch == begin)) { ch++; }
	      // To determine which side to associate with, get the box to the
	      // left of the character and compare it's vertical position to the
	      // coordinates
	      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
	        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
	        "after" : "before";
	      // Now get accurate coordinates for this place, in order to get a
	      // base X position
	      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
	      baseX = coords.left;
	      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
	    }

	    ch = skipExtendingChars(lineObj.text, ch, 1);
	    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
	  }

	  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
	    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
	    // situation, we can take this ordering to correspond to the visual
	    // ordering. This finds the first part whose end is after the given
	    // coordinates.
	    var index = findFirst(function (i) {
	      var part = order[i], ltr = part.level != 1;
	      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
	                                     "line", lineObj, preparedMeasure), x, y, true)
	    }, 0, order.length - 1);
	    var part = order[index];
	    // If this isn't the first part, the part's start is also after
	    // the coordinates, and the coordinates aren't on the same line as
	    // that start, move one part back.
	    if (index > 0) {
	      var ltr = part.level != 1;
	      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
	                               "line", lineObj, preparedMeasure);
	      if (boxIsAfter(start, x, y, true) && start.top > y)
	        { part = order[index - 1]; }
	    }
	    return part
	  }

	  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
	    // In a wrapped line, rtl text on wrapping boundaries can do things
	    // that don't correspond to the ordering in our `order` array at
	    // all, so a binary search doesn't work, and we want to return a
	    // part that only spans one line so that the binary search in
	    // coordsCharInner is safe. As such, we first find the extent of the
	    // wrapped line, and then do a flat search in which we discard any
	    // spans that aren't on the line.
	    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
	    var begin = ref.begin;
	    var end = ref.end;
	    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
	    var part = null, closestDist = null;
	    for (var i = 0; i < order.length; i++) {
	      var p = order[i];
	      if (p.from >= end || p.to <= begin) { continue }
	      var ltr = p.level != 1;
	      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
	      // Weigh against spans ending before this, so that they are only
	      // picked if nothing ends after
	      var dist = endX < x ? x - endX + 1e9 : endX - x;
	      if (!part || closestDist > dist) {
	        part = p;
	        closestDist = dist;
	      }
	    }
	    if (!part) { part = order[order.length - 1]; }
	    // Clip the part to the wrapped line.
	    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
	    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
	    return part
	  }

	  var measureText;
	  // Compute the default text height.
	  function textHeight(display) {
	    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
	    if (measureText == null) {
	      measureText = elt("pre", null, "CodeMirror-line-like");
	      // Measure a bunch of lines, for browsers that compute
	      // fractional heights.
	      for (var i = 0; i < 49; ++i) {
	        measureText.appendChild(document.createTextNode("x"));
	        measureText.appendChild(elt("br"));
	      }
	      measureText.appendChild(document.createTextNode("x"));
	    }
	    removeChildrenAndAdd(display.measure, measureText);
	    var height = measureText.offsetHeight / 50;
	    if (height > 3) { display.cachedTextHeight = height; }
	    removeChildren(display.measure);
	    return height || 1
	  }

	  // Compute the default character width.
	  function charWidth(display) {
	    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
	    var anchor = elt("span", "xxxxxxxxxx");
	    var pre = elt("pre", [anchor], "CodeMirror-line-like");
	    removeChildrenAndAdd(display.measure, pre);
	    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	    if (width > 2) { display.cachedCharWidth = width; }
	    return width || 10
	  }

	  // Do a bulk-read of the DOM positions and sizes needed to draw the
	  // view, so that we don't interleave reading and writing to the DOM.
	  function getDimensions(cm) {
	    var d = cm.display, left = {}, width = {};
	    var gutterLeft = d.gutters.clientLeft;
	    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	      var id = cm.display.gutterSpecs[i].className;
	      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
	      width[id] = n.clientWidth;
	    }
	    return {fixedPos: compensateForHScroll(d),
	            gutterTotalWidth: d.gutters.offsetWidth,
	            gutterLeft: left,
	            gutterWidth: width,
	            wrapperWidth: d.wrapper.clientWidth}
	  }

	  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	  // but using getBoundingClientRect to get a sub-pixel-accurate
	  // result.
	  function compensateForHScroll(display) {
	    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
	  }

	  // Returns a function that estimates the height of a line, to use as
	  // first approximation until the line becomes visible (and is thus
	  // properly measurable).
	  function estimateHeight(cm) {
	    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	    return function (line) {
	      if (lineIsHidden(cm.doc, line)) { return 0 }

	      var widgetsHeight = 0;
	      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
	        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
	      } }

	      if (wrapping)
	        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
	      else
	        { return widgetsHeight + th }
	    }
	  }

	  function estimateLineHeights(cm) {
	    var doc = cm.doc, est = estimateHeight(cm);
	    doc.iter(function (line) {
	      var estHeight = est(line);
	      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	    });
	  }

	  // Given a mouse event, find the corresponding position. If liberal
	  // is false, it checks whether a gutter or scrollbar was clicked,
	  // and returns null if it was. forRect is used by rectangular
	  // selections, and tries to estimate a character position even for
	  // coordinates beyond the right of the text.
	  function posFromMouse(cm, e, liberal, forRect) {
	    var display = cm.display;
	    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

	    var x, y, space = display.lineSpace.getBoundingClientRect();
	    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	    try { x = e.clientX - space.left; y = e.clientY - space.top; }
	    catch (e$1) { return null }
	    var coords = coordsChar(cm, x, y), line;
	    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	    }
	    return coords
	  }

	  // Find the view element corresponding to a given line. Return null
	  // when the line isn't visible.
	  function findViewIndex(cm, n) {
	    if (n >= cm.display.viewTo) { return null }
	    n -= cm.display.viewFrom;
	    if (n < 0) { return null }
	    var view = cm.display.view;
	    for (var i = 0; i < view.length; i++) {
	      n -= view[i].size;
	      if (n < 0) { return i }
	    }
	  }

	  // Updates the display.view data structure for a given change to the
	  // document. From and to are in pre-change coordinates. Lendiff is
	  // the amount of lines added or subtracted by the change. This is
	  // used for changes that span multiple lines, or change the way
	  // lines are divided into visual lines. regLineChange (below)
	  // registers single-line changes.
	  function regChange(cm, from, to, lendiff) {
	    if (from == null) { from = cm.doc.first; }
	    if (to == null) { to = cm.doc.first + cm.doc.size; }
	    if (!lendiff) { lendiff = 0; }

	    var display = cm.display;
	    if (lendiff && to < display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers > from))
	      { display.updateLineNumbers = from; }

	    cm.curOp.viewChanged = true;

	    if (from >= display.viewTo) { // Change after
	      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	        { resetView(cm); }
	    } else if (to <= display.viewFrom) { // Change before
	      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	        resetView(cm);
	      } else {
	        display.viewFrom += lendiff;
	        display.viewTo += lendiff;
	      }
	    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	      resetView(cm);
	    } else if (from <= display.viewFrom) { // Top overlap
	      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cut) {
	        display.view = display.view.slice(cut.index);
	        display.viewFrom = cut.lineN;
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    } else if (to >= display.viewTo) { // Bottom overlap
	      var cut$1 = viewCuttingPoint(cm, from, from, -1);
	      if (cut$1) {
	        display.view = display.view.slice(0, cut$1.index);
	        display.viewTo = cut$1.lineN;
	      } else {
	        resetView(cm);
	      }
	    } else { // Gap in the middle
	      var cutTop = viewCuttingPoint(cm, from, from, -1);
	      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cutTop && cutBot) {
	        display.view = display.view.slice(0, cutTop.index)
	          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	          .concat(display.view.slice(cutBot.index));
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    }

	    var ext = display.externalMeasured;
	    if (ext) {
	      if (to < ext.lineN)
	        { ext.lineN += lendiff; }
	      else if (from < ext.lineN + ext.size)
	        { display.externalMeasured = null; }
	    }
	  }

	  // Register a change to a single line. Type must be one of "text",
	  // "gutter", "class", "widget"
	  function regLineChange(cm, line, type) {
	    cm.curOp.viewChanged = true;
	    var display = cm.display, ext = cm.display.externalMeasured;
	    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	      { display.externalMeasured = null; }

	    if (line < display.viewFrom || line >= display.viewTo) { return }
	    var lineView = display.view[findViewIndex(cm, line)];
	    if (lineView.node == null) { return }
	    var arr = lineView.changes || (lineView.changes = []);
	    if (indexOf(arr, type) == -1) { arr.push(type); }
	  }

	  // Clear the view.
	  function resetView(cm) {
	    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	    cm.display.view = [];
	    cm.display.viewOffset = 0;
	  }

	  function viewCuttingPoint(cm, oldN, newN, dir) {
	    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	      { return {index: index, lineN: newN} }
	    var n = cm.display.viewFrom;
	    for (var i = 0; i < index; i++)
	      { n += view[i].size; }
	    if (n != oldN) {
	      if (dir > 0) {
	        if (index == view.length - 1) { return null }
	        diff = (n + view[index].size) - oldN;
	        index++;
	      } else {
	        diff = n - oldN;
	      }
	      oldN += diff; newN += diff;
	    }
	    while (visualLineNo(cm.doc, newN) != newN) {
	      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
	      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	      index += dir;
	    }
	    return {index: index, lineN: newN}
	  }

	  // Force the view to cover a given range, adding empty view element
	  // or clipping off existing ones as needed.
	  function adjustView(cm, from, to) {
	    var display = cm.display, view = display.view;
	    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	      display.view = buildViewArray(cm, from, to);
	      display.viewFrom = from;
	    } else {
	      if (display.viewFrom > from)
	        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
	      else if (display.viewFrom < from)
	        { display.view = display.view.slice(findViewIndex(cm, from)); }
	      display.viewFrom = from;
	      if (display.viewTo < to)
	        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
	      else if (display.viewTo > to)
	        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
	    }
	    display.viewTo = to;
	  }

	  // Count the number of lines in the view whose DOM representation is
	  // out of date (or nonexistent).
	  function countDirtyView(cm) {
	    var view = cm.display.view, dirty = 0;
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
	    }
	    return dirty
	  }

	  function updateSelection(cm) {
	    cm.display.input.showSelection(cm.display.input.prepareSelection());
	  }

	  function prepareSelection(cm, primary) {
	    if ( primary === void 0 ) primary = true;

	    var doc = cm.doc, result = {};
	    var curFragment = result.cursors = document.createDocumentFragment();
	    var selFragment = result.selection = document.createDocumentFragment();

	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      if (!primary && i == doc.sel.primIndex) { continue }
	      var range = doc.sel.ranges[i];
	      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
	      var collapsed = range.empty();
	      if (collapsed || cm.options.showCursorWhenSelecting)
	        { drawSelectionCursor(cm, range.head, curFragment); }
	      if (!collapsed)
	        { drawSelectionRange(cm, range, selFragment); }
	    }
	    return result
	  }

	  // Draws a cursor for the given range
	  function drawSelectionCursor(cm, head, output) {
	    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

	    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	    cursor.style.left = pos.left + "px";
	    cursor.style.top = pos.top + "px";
	    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

	    if (pos.other) {
	      // Secondary cursor, shown when on a 'jump' in bi-directional text
	      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	      otherCursor.style.display = "";
	      otherCursor.style.left = pos.other.left + "px";
	      otherCursor.style.top = pos.other.top + "px";
	      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	    }
	  }

	  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

	  // Draws the given range as a highlighted selection
	  function drawSelectionRange(cm, range, output) {
	    var display = cm.display, doc = cm.doc;
	    var fragment = document.createDocumentFragment();
	    var padding = paddingH(cm.display), leftSide = padding.left;
	    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
	    var docLTR = doc.direction == "ltr";

	    function add(left, top, width, bottom) {
	      if (top < 0) { top = 0; }
	      top = Math.round(top);
	      bottom = Math.round(bottom);
	      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
	    }

	    function drawForLine(line, fromArg, toArg) {
	      var lineObj = getLine(doc, line);
	      var lineLen = lineObj.text.length;
	      var start, end;
	      function coords(ch, bias) {
	        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
	      }

	      function wrapX(pos, dir, side) {
	        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
	        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
	        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
	        return coords(ch, prop)[prop]
	      }

	      var order = getOrder(lineObj, doc.direction);
	      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
	        var ltr = dir == "ltr";
	        var fromPos = coords(from, ltr ? "left" : "right");
	        var toPos = coords(to - 1, ltr ? "right" : "left");

	        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
	        var first = i == 0, last = !order || i == order.length - 1;
	        if (toPos.top - fromPos.top <= 3) { // Single line
	          var openLeft = (docLTR ? openStart : openEnd) && first;
	          var openRight = (docLTR ? openEnd : openStart) && last;
	          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
	          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
	          add(left, fromPos.top, right - left, fromPos.bottom);
	        } else { // Multiple lines
	          var topLeft, topRight, botLeft, botRight;
	          if (ltr) {
	            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
	            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
	            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
	            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
	          } else {
	            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
	            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
	            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
	            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
	          }
	          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
	          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
	          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
	        }

	        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
	        if (cmpCoords(toPos, start) < 0) { start = toPos; }
	        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
	        if (cmpCoords(toPos, end) < 0) { end = toPos; }
	      });
	      return {start: start, end: end}
	    }

	    var sFrom = range.from(), sTo = range.to();
	    if (sFrom.line == sTo.line) {
	      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	    } else {
	      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	      var singleVLine = visualLine(fromLine) == visualLine(toLine);
	      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	      if (singleVLine) {
	        if (leftEnd.top < rightStart.top - 2) {
	          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	        } else {
	          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	        }
	      }
	      if (leftEnd.bottom < rightStart.top)
	        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
	    }

	    output.appendChild(fragment);
	  }

	  // Cursor-blinking
	  function restartBlink(cm) {
	    if (!cm.state.focused) { return }
	    var display = cm.display;
	    clearInterval(display.blinker);
	    var on = true;
	    display.cursorDiv.style.visibility = "";
	    if (cm.options.cursorBlinkRate > 0)
	      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
	        cm.options.cursorBlinkRate); }
	    else if (cm.options.cursorBlinkRate < 0)
	      { display.cursorDiv.style.visibility = "hidden"; }
	  }

	  function ensureFocus(cm) {
	    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
	  }

	  function delayBlurEvent(cm) {
	    cm.state.delayingBlurEvent = true;
	    setTimeout(function () { if (cm.state.delayingBlurEvent) {
	      cm.state.delayingBlurEvent = false;
	      onBlur(cm);
	    } }, 100);
	  }

	  function onFocus(cm, e) {
	    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

	    if (cm.options.readOnly == "nocursor") { return }
	    if (!cm.state.focused) {
	      signal(cm, "focus", cm, e);
	      cm.state.focused = true;
	      addClass(cm.display.wrapper, "CodeMirror-focused");
	      // This test prevents this from firing when a context
	      // menu is closed (since the input reset would kill the
	      // select-all detection hack)
	      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	        cm.display.input.reset();
	        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
	      }
	      cm.display.input.receivedFocus();
	    }
	    restartBlink(cm);
	  }
	  function onBlur(cm, e) {
	    if (cm.state.delayingBlurEvent) { return }

	    if (cm.state.focused) {
	      signal(cm, "blur", cm, e);
	      cm.state.focused = false;
	      rmClass(cm.display.wrapper, "CodeMirror-focused");
	    }
	    clearInterval(cm.display.blinker);
	    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
	  }

	  // Read the actual heights of the rendered lines, and update their
	  // stored heights to match.
	  function updateHeightsInViewport(cm) {
	    var display = cm.display;
	    var prevBottom = display.lineDiv.offsetTop;
	    for (var i = 0; i < display.view.length; i++) {
	      var cur = display.view[i], wrapping = cm.options.lineWrapping;
	      var height = (void 0), width = 0;
	      if (cur.hidden) { continue }
	      if (ie && ie_version < 8) {
	        var bot = cur.node.offsetTop + cur.node.offsetHeight;
	        height = bot - prevBottom;
	        prevBottom = bot;
	      } else {
	        var box = cur.node.getBoundingClientRect();
	        height = box.bottom - box.top;
	        // Check that lines don't extend past the right of the current
	        // editor width
	        if (!wrapping && cur.text.firstChild)
	          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
	      }
	      var diff = cur.line.height - height;
	      if (diff > .005 || diff < -.005) {
	        updateLineHeight(cur.line, height);
	        updateWidgetHeight(cur.line);
	        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
	          { updateWidgetHeight(cur.rest[j]); } }
	      }
	      if (width > cm.display.sizerWidth) {
	        var chWidth = Math.ceil(width / charWidth(cm.display));
	        if (chWidth > cm.display.maxLineLength) {
	          cm.display.maxLineLength = chWidth;
	          cm.display.maxLine = cur.line;
	          cm.display.maxLineChanged = true;
	        }
	      }
	    }
	  }

	  // Read and store the height of line widgets associated with the
	  // given line.
	  function updateWidgetHeight(line) {
	    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
	      var w = line.widgets[i], parent = w.node.parentNode;
	      if (parent) { w.height = parent.offsetHeight; }
	    } }
	  }

	  // Compute the lines that are visible in a given viewport (defaults
	  // the the current scroll position). viewport may contain top,
	  // height, and ensure (see op.scrollToPos) properties.
	  function visibleLines(display, doc, viewport) {
	    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	    top = Math.floor(top - paddingTop(display));
	    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

	    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	    // forces those lines into the viewport (if possible).
	    if (viewport && viewport.ensure) {
	      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	      if (ensureFrom < from) {
	        from = ensureFrom;
	        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	        to = ensureTo;
	      }
	    }
	    return {from: from, to: Math.max(to, from + 1)}
	  }

	  // SCROLLING THINGS INTO VIEW

	  // If an editor sits on the top or bottom of the window, partially
	  // scrolled out of view, this ensures that the cursor is visible.
	  function maybeScrollWindow(cm, rect) {
	    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

	    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	    if (rect.top + box.top < 0) { doScroll = true; }
	    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
	    if (doScroll != null && !phantom) {
	      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
	      cm.display.lineSpace.appendChild(scrollNode);
	      scrollNode.scrollIntoView(doScroll);
	      cm.display.lineSpace.removeChild(scrollNode);
	    }
	  }

	  // Scroll a given position into view (immediately), verifying that
	  // it actually became visible (as line heights are accurately
	  // measured, the position of something may 'drift' during drawing).
	  function scrollPosIntoView(cm, pos, end, margin) {
	    if (margin == null) { margin = 0; }
	    var rect;
	    if (!cm.options.lineWrapping && pos == end) {
	      // Set pos and end to the cursor positions around the character pos sticks to
	      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
	      // If pos == Pos(_, 0, "before"), pos and end are unchanged
	      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
	      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
	    }
	    for (var limit = 0; limit < 5; limit++) {
	      var changed = false;
	      var coords = cursorCoords(cm, pos);
	      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	      rect = {left: Math.min(coords.left, endCoords.left),
	              top: Math.min(coords.top, endCoords.top) - margin,
	              right: Math.max(coords.left, endCoords.left),
	              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
	      var scrollPos = calculateScrollPos(cm, rect);
	      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	      if (scrollPos.scrollTop != null) {
	        updateScrollTop(cm, scrollPos.scrollTop);
	        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
	      }
	      if (scrollPos.scrollLeft != null) {
	        setScrollLeft(cm, scrollPos.scrollLeft);
	        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
	      }
	      if (!changed) { break }
	    }
	    return rect
	  }

	  // Scroll a given set of coordinates into view (immediately).
	  function scrollIntoView(cm, rect) {
	    var scrollPos = calculateScrollPos(cm, rect);
	    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
	    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
	  }

	  // Calculate a new scroll position needed to scroll the given
	  // rectangle into view. Returns an object with scrollTop and
	  // scrollLeft properties. When these are undefined, the
	  // vertical/horizontal position does not need to be adjusted.
	  function calculateScrollPos(cm, rect) {
	    var display = cm.display, snapMargin = textHeight(cm.display);
	    if (rect.top < 0) { rect.top = 0; }
	    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	    var screen = displayHeight(cm), result = {};
	    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
	    var docBottom = cm.doc.height + paddingVert(display);
	    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
	    if (rect.top < screentop) {
	      result.scrollTop = atTop ? 0 : rect.top;
	    } else if (rect.bottom > screentop + screen) {
	      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
	      if (newTop != screentop) { result.scrollTop = newTop; }
	    }

	    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	    var tooWide = rect.right - rect.left > screenw;
	    if (tooWide) { rect.right = rect.left + screenw; }
	    if (rect.left < 10)
	      { result.scrollLeft = 0; }
	    else if (rect.left < screenleft)
	      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
	    else if (rect.right > screenw + screenleft - 3)
	      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
	    return result
	  }

	  // Store a relative adjustment to the scroll position in the current
	  // operation (to be applied when the operation finishes).
	  function addToScrollTop(cm, top) {
	    if (top == null) { return }
	    resolveScrollToPos(cm);
	    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	  }

	  // Make sure that at the end of the operation the current cursor is
	  // shown.
	  function ensureCursorVisible(cm) {
	    resolveScrollToPos(cm);
	    var cur = cm.getCursor();
	    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
	  }

	  function scrollToCoords(cm, x, y) {
	    if (x != null || y != null) { resolveScrollToPos(cm); }
	    if (x != null) { cm.curOp.scrollLeft = x; }
	    if (y != null) { cm.curOp.scrollTop = y; }
	  }

	  function scrollToRange(cm, range) {
	    resolveScrollToPos(cm);
	    cm.curOp.scrollToPos = range;
	  }

	  // When an operation has its scrollToPos property set, and another
	  // scroll action is applied before the end of the operation, this
	  // 'simulates' scrolling that position into view in a cheap way, so
	  // that the effect of intermediate scroll commands is not ignored.
	  function resolveScrollToPos(cm) {
	    var range = cm.curOp.scrollToPos;
	    if (range) {
	      cm.curOp.scrollToPos = null;
	      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
	      scrollToCoordsRange(cm, from, to, range.margin);
	    }
	  }

	  function scrollToCoordsRange(cm, from, to, margin) {
	    var sPos = calculateScrollPos(cm, {
	      left: Math.min(from.left, to.left),
	      top: Math.min(from.top, to.top) - margin,
	      right: Math.max(from.right, to.right),
	      bottom: Math.max(from.bottom, to.bottom) + margin
	    });
	    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
	  }

	  // Sync the scrollable area and scrollbars, ensure the viewport
	  // covers the visible area.
	  function updateScrollTop(cm, val) {
	    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
	    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
	    setScrollTop(cm, val, true);
	    if (gecko) { updateDisplaySimple(cm); }
	    startWorker(cm, 100);
	  }

	  function setScrollTop(cm, val, forceScroll) {
	    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
	    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
	    cm.doc.scrollTop = val;
	    cm.display.scrollbars.setScrollTop(val);
	    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
	  }

	  // Sync scroller and scrollbar, ensure the gutter elements are
	  // aligned.
	  function setScrollLeft(cm, val, isScroller, forceScroll) {
	    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
	    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
	    cm.doc.scrollLeft = val;
	    alignHorizontally(cm);
	    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
	    cm.display.scrollbars.setScrollLeft(val);
	  }

	  // SCROLLBARS

	  // Prepare DOM reads needed to update the scrollbars. Done in one
	  // shot to minimize update/measure roundtrips.
	  function measureForScrollbars(cm) {
	    var d = cm.display, gutterW = d.gutters.offsetWidth;
	    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	    return {
	      clientHeight: d.scroller.clientHeight,
	      viewHeight: d.wrapper.clientHeight,
	      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	      viewWidth: d.wrapper.clientWidth,
	      barLeft: cm.options.fixedGutter ? gutterW : 0,
	      docHeight: docH,
	      scrollHeight: docH + scrollGap(cm) + d.barHeight,
	      nativeBarWidth: d.nativeBarWidth,
	      gutterWidth: gutterW
	    }
	  }

	  var NativeScrollbars = function(place, scroll, cm) {
	    this.cm = cm;
	    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	    vert.tabIndex = horiz.tabIndex = -1;
	    place(vert); place(horiz);

	    on(vert, "scroll", function () {
	      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
	    });
	    on(horiz, "scroll", function () {
	      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
	    });

	    this.checkedZeroWidth = false;
	    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
	  };

	  NativeScrollbars.prototype.update = function (measure) {
	    var needsH = measure.scrollWidth > measure.clientWidth + 1;
	    var needsV = measure.scrollHeight > measure.clientHeight + 1;
	    var sWidth = measure.nativeBarWidth;

	    if (needsV) {
	      this.vert.style.display = "block";
	      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	      // A bug in IE8 can cause this value to be negative, so guard it.
	      this.vert.firstChild.style.height =
	        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	    } else {
	      this.vert.style.display = "";
	      this.vert.firstChild.style.height = "0";
	    }

	    if (needsH) {
	      this.horiz.style.display = "block";
	      this.horiz.style.right = needsV ? sWidth + "px" : "0";
	      this.horiz.style.left = measure.barLeft + "px";
	      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	      this.horiz.firstChild.style.width =
	        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	    } else {
	      this.horiz.style.display = "";
	      this.horiz.firstChild.style.width = "0";
	    }

	    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	      if (sWidth == 0) { this.zeroWidthHack(); }
	      this.checkedZeroWidth = true;
	    }

	    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
	  };

	  NativeScrollbars.prototype.setScrollLeft = function (pos) {
	    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
	    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
	  };

	  NativeScrollbars.prototype.setScrollTop = function (pos) {
	    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
	    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
	  };

	  NativeScrollbars.prototype.zeroWidthHack = function () {
	    var w = mac && !mac_geMountainLion ? "12px" : "18px";
	    this.horiz.style.height = this.vert.style.width = w;
	    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	    this.disableHoriz = new Delayed;
	    this.disableVert = new Delayed;
	  };

	  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
	    bar.style.pointerEvents = "auto";
	    function maybeDisable() {
	      // To find out whether the scrollbar is still visible, we
	      // check whether the element under the pixel in the bottom
	      // right corner of the scrollbar box is the scrollbar box
	      // itself (when the bar is still visible) or its filler child
	      // (when the bar is hidden). If it is still visible, we keep
	      // it enabled, if it's hidden, we disable pointer events.
	      var box = bar.getBoundingClientRect();
	      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
	          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
	      if (elt != bar) { bar.style.pointerEvents = "none"; }
	      else { delay.set(1000, maybeDisable); }
	    }
	    delay.set(1000, maybeDisable);
	  };

	  NativeScrollbars.prototype.clear = function () {
	    var parent = this.horiz.parentNode;
	    parent.removeChild(this.horiz);
	    parent.removeChild(this.vert);
	  };

	  var NullScrollbars = function () {};

	  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
	  NullScrollbars.prototype.setScrollLeft = function () {};
	  NullScrollbars.prototype.setScrollTop = function () {};
	  NullScrollbars.prototype.clear = function () {};

	  function updateScrollbars(cm, measure) {
	    if (!measure) { measure = measureForScrollbars(cm); }
	    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	    updateScrollbarsInner(cm, measure);
	    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	        { updateHeightsInViewport(cm); }
	      updateScrollbarsInner(cm, measureForScrollbars(cm));
	      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	    }
	  }

	  // Re-synchronize the fake scrollbars with the actual size of the
	  // content.
	  function updateScrollbarsInner(cm, measure) {
	    var d = cm.display;
	    var sizes = d.scrollbars.update(measure);

	    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

	    if (sizes.right && sizes.bottom) {
	      d.scrollbarFiller.style.display = "block";
	      d.scrollbarFiller.style.height = sizes.bottom + "px";
	      d.scrollbarFiller.style.width = sizes.right + "px";
	    } else { d.scrollbarFiller.style.display = ""; }
	    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	      d.gutterFiller.style.display = "block";
	      d.gutterFiller.style.height = sizes.bottom + "px";
	      d.gutterFiller.style.width = measure.gutterWidth + "px";
	    } else { d.gutterFiller.style.display = ""; }
	  }

	  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

	  function initScrollbars(cm) {
	    if (cm.display.scrollbars) {
	      cm.display.scrollbars.clear();
	      if (cm.display.scrollbars.addClass)
	        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	    }

	    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
	      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	      // Prevent clicks in the scrollbars from killing focus
	      on(node, "mousedown", function () {
	        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
	      });
	      node.setAttribute("cm-not-content", "true");
	    }, function (pos, axis) {
	      if (axis == "horizontal") { setScrollLeft(cm, pos); }
	      else { updateScrollTop(cm, pos); }
	    }, cm);
	    if (cm.display.scrollbars.addClass)
	      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	  }

	  // Operations are used to wrap a series of changes to the editor
	  // state in such a way that each change won't have to update the
	  // cursor and display (which would be awkward, slow, and
	  // error-prone). Instead, display updates are batched and then all
	  // combined and executed at once.

	  var nextOpId = 0;
	  // Start a new operation.
	  function startOperation(cm) {
	    cm.curOp = {
	      cm: cm,
	      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	      startHeight: cm.doc.height, // Used to detect need to update scrollbar
	      forceUpdate: false,      // Used to force a redraw
	      updateInput: 0,       // Whether to reset the input textarea
	      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	      changeObjs: null,        // Accumulated changes, for firing change events
	      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	      selectionChanged: false, // Whether the selection needs to be redrawn
	      updateMaxLine: false,    // Set when the widest line needs to be determined anew
	      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	      scrollToPos: null,       // Used to scroll to a specific position
	      focus: false,
	      id: ++nextOpId           // Unique ID
	    };
	    pushOperation(cm.curOp);
	  }

	  // Finish an operation, updating the display and signalling delayed events
	  function endOperation(cm) {
	    var op = cm.curOp;
	    if (op) { finishOperation(op, function (group) {
	      for (var i = 0; i < group.ops.length; i++)
	        { group.ops[i].cm.curOp = null; }
	      endOperations(group);
	    }); }
	  }

	  // The DOM updates done when an operation finishes are batched so
	  // that the minimum number of relayouts are required.
	  function endOperations(group) {
	    var ops = group.ops;
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      { endOperation_R1(ops[i]); }
	    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
	      { endOperation_W1(ops[i$1]); }
	    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
	      { endOperation_R2(ops[i$2]); }
	    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
	      { endOperation_W2(ops[i$3]); }
	    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
	      { endOperation_finish(ops[i$4]); }
	  }

	  function endOperation_R1(op) {
	    var cm = op.cm, display = cm.display;
	    maybeClipScrollbars(cm);
	    if (op.updateMaxLine) { findMaxLine(cm); }

	    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                         op.scrollToPos.to.line >= display.viewTo) ||
	      display.maxLineChanged && cm.options.lineWrapping;
	    op.update = op.mustUpdate &&
	      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	  }

	  function endOperation_W1(op) {
	    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	  }

	  function endOperation_R2(op) {
	    var cm = op.cm, display = cm.display;
	    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

	    op.barMeasure = measureForScrollbars(cm);

	    // If the max line changed since it was last measured, measure it,
	    // and ensure the document's width matches it.
	    // updateDisplay_W2 will use these properties to do the actual resizing
	    if (display.maxLineChanged && !cm.options.lineWrapping) {
	      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	      cm.display.sizerWidth = op.adjustWidthTo;
	      op.barMeasure.scrollWidth =
	        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	    }

	    if (op.updatedDisplay || op.selectionChanged)
	      { op.preparedSelection = display.input.prepareSelection(); }
	  }

	  function endOperation_W2(op) {
	    var cm = op.cm;

	    if (op.adjustWidthTo != null) {
	      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	      if (op.maxScrollLeft < cm.doc.scrollLeft)
	        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
	      cm.display.maxLineChanged = false;
	    }

	    var takeFocus = op.focus && op.focus == activeElt();
	    if (op.preparedSelection)
	      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
	    if (op.updatedDisplay || op.startHeight != cm.doc.height)
	      { updateScrollbars(cm, op.barMeasure); }
	    if (op.updatedDisplay)
	      { setDocumentHeight(cm, op.barMeasure); }

	    if (op.selectionChanged) { restartBlink(cm); }

	    if (cm.state.focused && op.updateInput)
	      { cm.display.input.reset(op.typing); }
	    if (takeFocus) { ensureFocus(op.cm); }
	  }

	  function endOperation_finish(op) {
	    var cm = op.cm, display = cm.display, doc = cm.doc;

	    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

	    // Abort mouse wheel delta measurement, when scrolling explicitly
	    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	      { display.wheelStartX = display.wheelStartY = null; }

	    // Propagate the scroll position to the actual DOM scroller
	    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

	    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
	    // If we need to scroll a specific position into view, do so.
	    if (op.scrollToPos) {
	      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	      maybeScrollWindow(cm, rect);
	    }

	    // Fire events for markers that are hidden/unidden by editing or
	    // undoing
	    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	    if (hidden) { for (var i = 0; i < hidden.length; ++i)
	      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
	    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
	      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

	    if (display.wrapper.offsetHeight)
	      { doc.scrollTop = cm.display.scroller.scrollTop; }

	    // Fire change events, and delayed event handlers
	    if (op.changeObjs)
	      { signal(cm, "changes", cm, op.changeObjs); }
	    if (op.update)
	      { op.update.finish(); }
	  }

	  // Run the given function in an operation
	  function runInOp(cm, f) {
	    if (cm.curOp) { return f() }
	    startOperation(cm);
	    try { return f() }
	    finally { endOperation(cm); }
	  }
	  // Wraps a function in an operation. Returns the wrapped function.
	  function operation(cm, f) {
	    return function() {
	      if (cm.curOp) { return f.apply(cm, arguments) }
	      startOperation(cm);
	      try { return f.apply(cm, arguments) }
	      finally { endOperation(cm); }
	    }
	  }
	  // Used to add methods to editor and doc instances, wrapping them in
	  // operations.
	  function methodOp(f) {
	    return function() {
	      if (this.curOp) { return f.apply(this, arguments) }
	      startOperation(this);
	      try { return f.apply(this, arguments) }
	      finally { endOperation(this); }
	    }
	  }
	  function docMethodOp(f) {
	    return function() {
	      var cm = this.cm;
	      if (!cm || cm.curOp) { return f.apply(this, arguments) }
	      startOperation(cm);
	      try { return f.apply(this, arguments) }
	      finally { endOperation(cm); }
	    }
	  }

	  // HIGHLIGHT WORKER

	  function startWorker(cm, time) {
	    if (cm.doc.highlightFrontier < cm.display.viewTo)
	      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
	  }

	  function highlightWorker(cm) {
	    var doc = cm.doc;
	    if (doc.highlightFrontier >= cm.display.viewTo) { return }
	    var end = +new Date + cm.options.workTime;
	    var context = getContextBefore(cm, doc.highlightFrontier);
	    var changedLines = [];

	    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
	      if (context.line >= cm.display.viewFrom) { // Visible
	        var oldStyles = line.styles;
	        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
	        var highlighted = highlightLine(cm, line, context, true);
	        if (resetState) { context.state = resetState; }
	        line.styles = highlighted.styles;
	        var oldCls = line.styleClasses, newCls = highlighted.classes;
	        if (newCls) { line.styleClasses = newCls; }
	        else if (oldCls) { line.styleClasses = null; }
	        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
	        if (ischange) { changedLines.push(context.line); }
	        line.stateAfter = context.save();
	        context.nextLine();
	      } else {
	        if (line.text.length <= cm.options.maxHighlightLength)
	          { processLine(cm, line.text, context); }
	        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
	        context.nextLine();
	      }
	      if (+new Date > end) {
	        startWorker(cm, cm.options.workDelay);
	        return true
	      }
	    });
	    doc.highlightFrontier = context.line;
	    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
	    if (changedLines.length) { runInOp(cm, function () {
	      for (var i = 0; i < changedLines.length; i++)
	        { regLineChange(cm, changedLines[i], "text"); }
	    }); }
	  }

	  // DISPLAY DRAWING

	  var DisplayUpdate = function(cm, viewport, force) {
	    var display = cm.display;

	    this.viewport = viewport;
	    // Store some values that we'll need later (but don't want to force a relayout for)
	    this.visible = visibleLines(display, cm.doc, viewport);
	    this.editorIsHidden = !display.wrapper.offsetWidth;
	    this.wrapperHeight = display.wrapper.clientHeight;
	    this.wrapperWidth = display.wrapper.clientWidth;
	    this.oldDisplayWidth = displayWidth(cm);
	    this.force = force;
	    this.dims = getDimensions(cm);
	    this.events = [];
	  };

	  DisplayUpdate.prototype.signal = function (emitter, type) {
	    if (hasHandler(emitter, type))
	      { this.events.push(arguments); }
	  };
	  DisplayUpdate.prototype.finish = function () {
	    for (var i = 0; i < this.events.length; i++)
	      { signal.apply(null, this.events[i]); }
	  };

	  function maybeClipScrollbars(cm) {
	    var display = cm.display;
	    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	      display.heightForcer.style.height = scrollGap(cm) + "px";
	      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	      display.scrollbarsClipped = true;
	    }
	  }

	  function selectionSnapshot(cm) {
	    if (cm.hasFocus()) { return null }
	    var active = activeElt();
	    if (!active || !contains(cm.display.lineDiv, active)) { return null }
	    var result = {activeElt: active};
	    if (window.getSelection) {
	      var sel = window.getSelection();
	      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
	        result.anchorNode = sel.anchorNode;
	        result.anchorOffset = sel.anchorOffset;
	        result.focusNode = sel.focusNode;
	        result.focusOffset = sel.focusOffset;
	      }
	    }
	    return result
	  }

	  function restoreSelection(snapshot) {
	    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
	    snapshot.activeElt.focus();
	    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
	        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
	      var sel = window.getSelection(), range = document.createRange();
	      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
	      range.collapse(false);
	      sel.removeAllRanges();
	      sel.addRange(range);
	      sel.extend(snapshot.focusNode, snapshot.focusOffset);
	    }
	  }

	  // Does the actual updating of the line display. Bails out
	  // (returning false) when there is nothing to be done and forced is
	  // false.
	  function updateDisplayIfNeeded(cm, update) {
	    var display = cm.display, doc = cm.doc;

	    if (update.editorIsHidden) {
	      resetView(cm);
	      return false
	    }

	    // Bail out if the visible area is already rendered and nothing changed.
	    if (!update.force &&
	        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	        display.renderedView == display.view && countDirtyView(cm) == 0)
	      { return false }

	    if (maybeUpdateLineNumberWidth(cm)) {
	      resetView(cm);
	      update.dims = getDimensions(cm);
	    }

	    // Compute a suitable new viewport (from & to)
	    var end = doc.first + doc.size;
	    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
	    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
	    if (sawCollapsedSpans) {
	      from = visualLineNo(cm.doc, from);
	      to = visualLineEndNo(cm.doc, to);
	    }

	    var different = from != display.viewFrom || to != display.viewTo ||
	      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	    adjustView(cm, from, to);

	    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	    // Position the mover div to align with the current scroll position
	    cm.display.mover.style.top = display.viewOffset + "px";

	    var toUpdate = countDirtyView(cm);
	    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	      { return false }

	    // For big changes, we hide the enclosing element during the
	    // update, since that speeds up the operations on most browsers.
	    var selSnapshot = selectionSnapshot(cm);
	    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
	    patchDisplay(cm, display.updateLineNumbers, update.dims);
	    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
	    display.renderedView = display.view;
	    // There might have been a widget with a focused element that got
	    // hidden or updated, if so re-focus it.
	    restoreSelection(selSnapshot);

	    // Prevent selection and cursors from interfering with the scroll
	    // width and height.
	    removeChildren(display.cursorDiv);
	    removeChildren(display.selectionDiv);
	    display.gutters.style.height = display.sizer.style.minHeight = 0;

	    if (different) {
	      display.lastWrapHeight = update.wrapperHeight;
	      display.lastWrapWidth = update.wrapperWidth;
	      startWorker(cm, 400);
	    }

	    display.updateLineNumbers = null;

	    return true
	  }

	  function postUpdateDisplay(cm, update) {
	    var viewport = update.viewport;

	    for (var first = true;; first = false) {
	      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	        // Clip forced viewport to actual scrollable area.
	        if (viewport && viewport.top != null)
	          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
	        // Updated line heights might result in the drawn area not
	        // actually covering the viewport. Keep looping until it does.
	        update.visible = visibleLines(cm.display, cm.doc, viewport);
	        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	          { break }
	      } else if (first) {
	        update.visible = visibleLines(cm.display, cm.doc, viewport);
	      }
	      if (!updateDisplayIfNeeded(cm, update)) { break }
	      updateHeightsInViewport(cm);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      updateScrollbars(cm, barMeasure);
	      setDocumentHeight(cm, barMeasure);
	      update.force = false;
	    }

	    update.signal(cm, "update", cm);
	    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	    }
	  }

	  function updateDisplaySimple(cm, viewport) {
	    var update = new DisplayUpdate(cm, viewport);
	    if (updateDisplayIfNeeded(cm, update)) {
	      updateHeightsInViewport(cm);
	      postUpdateDisplay(cm, update);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      updateScrollbars(cm, barMeasure);
	      setDocumentHeight(cm, barMeasure);
	      update.finish();
	    }
	  }

	  // Sync the actual display DOM structure with display.view, removing
	  // nodes for lines that are no longer in view, and creating the ones
	  // that are not there yet, and updating the ones that are out of
	  // date.
	  function patchDisplay(cm, updateNumbersFrom, dims) {
	    var display = cm.display, lineNumbers = cm.options.lineNumbers;
	    var container = display.lineDiv, cur = container.firstChild;

	    function rm(node) {
	      var next = node.nextSibling;
	      // Works around a throw-scroll bug in OS X Webkit
	      if (webkit && mac && cm.display.currentWheelTarget == node)
	        { node.style.display = "none"; }
	      else
	        { node.parentNode.removeChild(node); }
	      return next
	    }

	    var view = display.view, lineN = display.viewFrom;
	    // Loop over the elements in the view, syncing cur (the DOM nodes
	    // in display.lineDiv) with the view as we go.
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	        var node = buildLineElement(cm, lineView, lineN, dims);
	        container.insertBefore(node, cur);
	      } else { // Already drawn
	        while (cur != lineView.node) { cur = rm(cur); }
	        var updateNumber = lineNumbers && updateNumbersFrom != null &&
	          updateNumbersFrom <= lineN && lineView.lineNumber;
	        if (lineView.changes) {
	          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
	          updateLineForChanges(cm, lineView, lineN, dims);
	        }
	        if (updateNumber) {
	          removeChildren(lineView.lineNumber);
	          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	        }
	        cur = lineView.node.nextSibling;
	      }
	      lineN += lineView.size;
	    }
	    while (cur) { cur = rm(cur); }
	  }

	  function updateGutterSpace(display) {
	    var width = display.gutters.offsetWidth;
	    display.sizer.style.marginLeft = width + "px";
	  }

	  function setDocumentHeight(cm, measure) {
	    cm.display.sizer.style.minHeight = measure.docHeight + "px";
	    cm.display.heightForcer.style.top = measure.docHeight + "px";
	    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
	  }

	  // Re-align line numbers and gutter marks to compensate for
	  // horizontal scrolling.
	  function alignHorizontally(cm) {
	    var display = cm.display, view = display.view;
	    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
	    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	    var gutterW = display.gutters.offsetWidth, left = comp + "px";
	    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
	      if (cm.options.fixedGutter) {
	        if (view[i].gutter)
	          { view[i].gutter.style.left = left; }
	        if (view[i].gutterBackground)
	          { view[i].gutterBackground.style.left = left; }
	      }
	      var align = view[i].alignable;
	      if (align) { for (var j = 0; j < align.length; j++)
	        { align[j].style.left = left; } }
	    } }
	    if (cm.options.fixedGutter)
	      { display.gutters.style.left = (comp + gutterW) + "px"; }
	  }

	  // Used to ensure that the line number gutter is still the right
	  // size for the current document size. Returns true when an update
	  // is needed.
	  function maybeUpdateLineNumberWidth(cm) {
	    if (!cm.options.lineNumbers) { return false }
	    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	    if (last.length != display.lineNumChars) {
	      var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
	      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	      display.lineGutter.style.width = "";
	      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	      display.lineNumWidth = display.lineNumInnerWidth + padding;
	      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	      display.lineGutter.style.width = display.lineNumWidth + "px";
	      updateGutterSpace(cm.display);
	      return true
	    }
	    return false
	  }

	  function getGutters(gutters, lineNumbers) {
	    var result = [], sawLineNumbers = false;
	    for (var i = 0; i < gutters.length; i++) {
	      var name = gutters[i], style = null;
	      if (typeof name != "string") { style = name.style; name = name.className; }
	      if (name == "CodeMirror-linenumbers") {
	        if (!lineNumbers) { continue }
	        else { sawLineNumbers = true; }
	      }
	      result.push({className: name, style: style});
	    }
	    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
	    return result
	  }

	  // Rebuild the gutter elements, ensure the margin to the left of the
	  // code matches their width.
	  function renderGutters(display) {
	    var gutters = display.gutters, specs = display.gutterSpecs;
	    removeChildren(gutters);
	    display.lineGutter = null;
	    for (var i = 0; i < specs.length; ++i) {
	      var ref = specs[i];
	      var className = ref.className;
	      var style = ref.style;
	      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
	      if (style) { gElt.style.cssText = style; }
	      if (className == "CodeMirror-linenumbers") {
	        display.lineGutter = gElt;
	        gElt.style.width = (display.lineNumWidth || 1) + "px";
	      }
	    }
	    gutters.style.display = specs.length ? "" : "none";
	    updateGutterSpace(display);
	  }

	  function updateGutters(cm) {
	    renderGutters(cm.display);
	    regChange(cm);
	    alignHorizontally(cm);
	  }

	  // The display handles the DOM integration, both for input reading
	  // and content drawing. It holds references to DOM nodes and
	  // display-related state.

	  function Display(place, doc, input, options) {
	    var d = this;
	    this.input = input;

	    // Covers bottom-right square when both scrollbars are present.
	    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	    d.scrollbarFiller.setAttribute("cm-not-content", "true");
	    // Covers bottom of gutter when coverGutterNextToScrollbar is on
	    // and h scrollbar is present.
	    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	    d.gutterFiller.setAttribute("cm-not-content", "true");
	    // Will contain the actual code, positioned to cover the viewport.
	    d.lineDiv = eltP("div", null, "CodeMirror-code");
	    // Elements are added to these to represent selection and cursors.
	    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	    // A visibility: hidden element used to find the size of things.
	    d.measure = elt("div", null, "CodeMirror-measure");
	    // When lines outside of the viewport are measured, they are drawn in this.
	    d.lineMeasure = elt("div", null, "CodeMirror-measure");
	    // Wraps everything that needs to exist inside the vertically-padded coordinate system
	    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                      null, "position: relative; outline: none");
	    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
	    // Moved around its parent to cover visible view.
	    d.mover = elt("div", [lines], null, "position: relative");
	    // Set to the height of the document, allowing scrolling.
	    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	    d.sizerWidth = null;
	    // Behavior of elts with overflow: auto and padding is
	    // inconsistent across browsers. This is used to ensure the
	    // scrollable area is big enough.
	    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	    // Will contain the gutters, if any.
	    d.gutters = elt("div", null, "CodeMirror-gutters");
	    d.lineGutter = null;
	    // Actual scrollable element.
	    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	    d.scroller.setAttribute("tabIndex", "-1");
	    // The element in which the editor lives.
	    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

	    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

	    if (place) {
	      if (place.appendChild) { place.appendChild(d.wrapper); }
	      else { place(d.wrapper); }
	    }

	    // Current rendered range (may be bigger than the view window).
	    d.viewFrom = d.viewTo = doc.first;
	    d.reportedViewFrom = d.reportedViewTo = doc.first;
	    // Information about the rendered lines.
	    d.view = [];
	    d.renderedView = null;
	    // Holds info about a single rendered line when it was rendered
	    // for measurement, while not in view.
	    d.externalMeasured = null;
	    // Empty space (in pixels) above the view
	    d.viewOffset = 0;
	    d.lastWrapHeight = d.lastWrapWidth = 0;
	    d.updateLineNumbers = null;

	    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	    d.scrollbarsClipped = false;

	    // Used to only resize the line number gutter when necessary (when
	    // the amount of lines crosses a boundary that makes its width change)
	    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	    // Set to true when a non-horizontal-scrolling line widget is
	    // added. As an optimization, line widget aligning is skipped when
	    // this is false.
	    d.alignWidgets = false;

	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

	    // Tracks the maximum line length so that the horizontal scrollbar
	    // can be kept static when scrolling.
	    d.maxLine = null;
	    d.maxLineLength = 0;
	    d.maxLineChanged = false;

	    // Used for measuring wheel scrolling granularity
	    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

	    // True when shift is held down.
	    d.shift = false;

	    // Used to track whether anything happened since the context menu
	    // was opened.
	    d.selForContextMenu = null;

	    d.activeTouch = null;

	    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
	    renderGutters(d);

	    input.init(d);
	  }

	  // Since the delta values reported on mouse wheel events are
	  // unstandardized between browsers and even browser versions, and
	  // generally horribly unpredictable, this code starts by measuring
	  // the scroll effect that the first few mouse wheel events have,
	  // and, from that, detects the way it can convert deltas to pixel
	  // offsets afterwards.
	  //
	  // The reason we want to know the amount a wheel event will scroll
	  // is that it gives us a chance to update the display before the
	  // actual scrolling happens, reducing flickering.

	  var wheelSamples = 0, wheelPixelsPerUnit = null;
	  // Fill in a browser-detected starting value on browsers where we
	  // know one. These don't have to be accurate -- the result of them
	  // being wrong would just be a slight flicker on the first wheel
	  // scroll (if it is large enough).
	  if (ie) { wheelPixelsPerUnit = -.53; }
	  else if (gecko) { wheelPixelsPerUnit = 15; }
	  else if (chrome) { wheelPixelsPerUnit = -.7; }
	  else if (safari) { wheelPixelsPerUnit = -1/3; }

	  function wheelEventDelta(e) {
	    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
	    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
	    else if (dy == null) { dy = e.wheelDelta; }
	    return {x: dx, y: dy}
	  }
	  function wheelEventPixels(e) {
	    var delta = wheelEventDelta(e);
	    delta.x *= wheelPixelsPerUnit;
	    delta.y *= wheelPixelsPerUnit;
	    return delta
	  }

	  function onScrollWheel(cm, e) {
	    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

	    var display = cm.display, scroll = display.scroller;
	    // Quit if there's nothing to scroll here
	    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
	    if (!(dx && canScrollX || dy && canScrollY)) { return }

	    // Webkit browsers on OS X abort momentum scrolls when the target
	    // of the scroll event is removed from the scrollable element.
	    // This hack (see related code in patchDisplay) makes sure the
	    // element is kept around.
	    if (dy && mac && webkit) {
	      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	        for (var i = 0; i < view.length; i++) {
	          if (view[i].node == cur) {
	            cm.display.currentWheelTarget = cur;
	            break outer
	          }
	        }
	      }
	    }

	    // On some browsers, horizontal scrolling will cause redraws to
	    // happen before the gutter has been realigned, causing it to
	    // wriggle around in a most unseemly way. When we have an
	    // estimated pixels/delta value, we just handle horizontal
	    // scrolling entirely here. It'll be slightly off from native, but
	    // better than glitching out.
	    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	      if (dy && canScrollY)
	        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
	      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
	      // Only prevent default scrolling if vertical scrolling is
	      // actually possible. Otherwise, it causes vertical scroll
	      // jitter on OSX trackpads when deltaX is small and deltaY
	      // is large (issue #3579)
	      if (!dy || (dy && canScrollY))
	        { e_preventDefault(e); }
	      display.wheelStartX = null; // Abort measurement, if in progress
	      return
	    }

	    // 'Project' the visible viewport to cover the area that is being
	    // scrolled into view (if we know enough to estimate it).
	    if (dy && wheelPixelsPerUnit != null) {
	      var pixels = dy * wheelPixelsPerUnit;
	      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
	      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
	      updateDisplaySimple(cm, {top: top, bottom: bot});
	    }

	    if (wheelSamples < 20) {
	      if (display.wheelStartX == null) {
	        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	        display.wheelDX = dx; display.wheelDY = dy;
	        setTimeout(function () {
	          if (display.wheelStartX == null) { return }
	          var movedX = scroll.scrollLeft - display.wheelStartX;
	          var movedY = scroll.scrollTop - display.wheelStartY;
	          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	            (movedX && display.wheelDX && movedX / display.wheelDX);
	          display.wheelStartX = display.wheelStartY = null;
	          if (!sample) { return }
	          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	          ++wheelSamples;
	        }, 200);
	      } else {
	        display.wheelDX += dx; display.wheelDY += dy;
	      }
	    }
	  }

	  // Selection objects are immutable. A new one is created every time
	  // the selection changes. A selection is one or more non-overlapping
	  // (and non-touching) ranges, sorted, and an integer that indicates
	  // which one is the primary selection (the one that's scrolled into
	  // view, that getCursor returns, etc).
	  var Selection = function(ranges, primIndex) {
	    this.ranges = ranges;
	    this.primIndex = primIndex;
	  };

	  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

	  Selection.prototype.equals = function (other) {
	    if (other == this) { return true }
	    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
	    for (var i = 0; i < this.ranges.length; i++) {
	      var here = this.ranges[i], there = other.ranges[i];
	      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
	    }
	    return true
	  };

	  Selection.prototype.deepCopy = function () {
	    var out = [];
	    for (var i = 0; i < this.ranges.length; i++)
	      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
	    return new Selection(out, this.primIndex)
	  };

	  Selection.prototype.somethingSelected = function () {
	    for (var i = 0; i < this.ranges.length; i++)
	      { if (!this.ranges[i].empty()) { return true } }
	    return false
	  };

	  Selection.prototype.contains = function (pos, end) {
	    if (!end) { end = pos; }
	    for (var i = 0; i < this.ranges.length; i++) {
	      var range = this.ranges[i];
	      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	        { return i }
	    }
	    return -1
	  };

	  var Range = function(anchor, head) {
	    this.anchor = anchor; this.head = head;
	  };

	  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
	  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
	  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

	  // Take an unsorted, potentially overlapping set of ranges, and
	  // build a selection out of it. 'Consumes' ranges array (modifying
	  // it).
	  function normalizeSelection(cm, ranges, primIndex) {
	    var mayTouch = cm && cm.options.selectionsMayTouch;
	    var prim = ranges[primIndex];
	    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
	    primIndex = indexOf(ranges, prim);
	    for (var i = 1; i < ranges.length; i++) {
	      var cur = ranges[i], prev = ranges[i - 1];
	      var diff = cmp(prev.to(), cur.from());
	      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
	        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	        if (i <= primIndex) { --primIndex; }
	        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	      }
	    }
	    return new Selection(ranges, primIndex)
	  }

	  function simpleSelection(anchor, head) {
	    return new Selection([new Range(anchor, head || anchor)], 0)
	  }

	  // Compute the position of the end of a change (its 'to' property
	  // refers to the pre-change end).
	  function changeEnd(change) {
	    if (!change.text) { return change.to }
	    return Pos(change.from.line + change.text.length - 1,
	               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
	  }

	  // Adjust a position to refer to the post-change position of the
	  // same text, or the end of the change if the change covers it.
	  function adjustForChange(pos, change) {
	    if (cmp(pos, change.from) < 0) { return pos }
	    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

	    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
	    return Pos(line, ch)
	  }

	  function computeSelAfterChange(doc, change) {
	    var out = [];
	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      var range = doc.sel.ranges[i];
	      out.push(new Range(adjustForChange(range.anchor, change),
	                         adjustForChange(range.head, change)));
	    }
	    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
	  }

	  function offsetPos(pos, old, nw) {
	    if (pos.line == old.line)
	      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
	    else
	      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
	  }

	  // Used by replaceSelections to allow moving the selection to the
	  // start or around the replaced test. Hint may be "start" or "around".
	  function computeReplacedSel(doc, changes, hint) {
	    var out = [];
	    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	    for (var i = 0; i < changes.length; i++) {
	      var change = changes[i];
	      var from = offsetPos(change.from, oldPrev, newPrev);
	      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	      oldPrev = change.to;
	      newPrev = to;
	      if (hint == "around") {
	        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	        out[i] = new Range(inv ? to : from, inv ? from : to);
	      } else {
	        out[i] = new Range(from, from);
	      }
	    }
	    return new Selection(out, doc.sel.primIndex)
	  }

	  // Used to get the editor into a consistent state again when options change.

	  function loadMode(cm) {
	    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
	    resetModeState(cm);
	  }

	  function resetModeState(cm) {
	    cm.doc.iter(function (line) {
	      if (line.stateAfter) { line.stateAfter = null; }
	      if (line.styles) { line.styles = null; }
	    });
	    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
	    startWorker(cm, 100);
	    cm.state.modeGen++;
	    if (cm.curOp) { regChange(cm); }
	  }

	  // DOCUMENT DATA STRUCTURE

	  // By default, updates that start and end at the beginning of a line
	  // are treated specially, in order to make the association of line
	  // widgets and marker elements with the text behave more intuitive.
	  function isWholeLineUpdate(doc, change) {
	    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
	  }

	  // Perform a change on the document data structure.
	  function updateDoc(doc, change, markedSpans, estimateHeight) {
	    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
	    function update(line, text, spans) {
	      updateLine(line, text, spans, estimateHeight);
	      signalLater(line, "change", line, change);
	    }
	    function linesFor(start, end) {
	      var result = [];
	      for (var i = start; i < end; ++i)
	        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
	      return result
	    }

	    var from = change.from, to = change.to, text = change.text;
	    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

	    // Adjust the line structure
	    if (change.full) {
	      doc.insert(0, linesFor(0, text.length));
	      doc.remove(text.length, doc.size - text.length);
	    } else if (isWholeLineUpdate(doc, change)) {
	      // This is a whole-line replace. Treated specially to make
	      // sure line objects move the way they are supposed to.
	      var added = linesFor(0, text.length - 1);
	      update(lastLine, lastLine.text, lastSpans);
	      if (nlines) { doc.remove(from.line, nlines); }
	      if (added.length) { doc.insert(from.line, added); }
	    } else if (firstLine == lastLine) {
	      if (text.length == 1) {
	        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	      } else {
	        var added$1 = linesFor(1, text.length - 1);
	        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
	        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	        doc.insert(from.line + 1, added$1);
	      }
	    } else if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	      doc.remove(from.line + 1, nlines);
	    } else {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	      var added$2 = linesFor(1, text.length - 1);
	      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
	      doc.insert(from.line + 1, added$2);
	    }

	    signalLater(doc, "change", doc, change);
	  }

	  // Call f for all linked documents.
	  function linkedDocs(doc, f, sharedHistOnly) {
	    function propagate(doc, skip, sharedHist) {
	      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
	        var rel = doc.linked[i];
	        if (rel.doc == skip) { continue }
	        var shared = sharedHist && rel.sharedHist;
	        if (sharedHistOnly && !shared) { continue }
	        f(rel.doc, shared);
	        propagate(rel.doc, doc, shared);
	      } }
	    }
	    propagate(doc, null, true);
	  }

	  // Attach a document to an editor.
	  function attachDoc(cm, doc) {
	    if (doc.cm) { throw new Error("This document is already in use.") }
	    cm.doc = doc;
	    doc.cm = cm;
	    estimateLineHeights(cm);
	    loadMode(cm);
	    setDirectionClass(cm);
	    if (!cm.options.lineWrapping) { findMaxLine(cm); }
	    cm.options.mode = doc.modeOption;
	    regChange(cm);
	  }

	  function setDirectionClass(cm) {
	  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
	  }

	  function directionChanged(cm) {
	    runInOp(cm, function () {
	      setDirectionClass(cm);
	      regChange(cm);
	    });
	  }

	  function History(startGen) {
	    // Arrays of change events and selections. Doing something adds an
	    // event to done and clears undo. Undoing moves events from done
	    // to undone, redoing moves them in the other direction.
	    this.done = []; this.undone = [];
	    this.undoDepth = Infinity;
	    // Used to track when changes can be merged into a single undo
	    // event
	    this.lastModTime = this.lastSelTime = 0;
	    this.lastOp = this.lastSelOp = null;
	    this.lastOrigin = this.lastSelOrigin = null;
	    // Used by the isClean() method
	    this.generation = this.maxGeneration = startGen || 1;
	  }

	  // Create a history change event from an updateDoc-style change
	  // object.
	  function historyChangeFromChange(doc, change) {
	    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
	    return histChange
	  }

	  // Pop all selection events off the end of a history array. Stop at
	  // a change event.
	  function clearSelectionEvents(array) {
	    while (array.length) {
	      var last = lst(array);
	      if (last.ranges) { array.pop(); }
	      else { break }
	    }
	  }

	  // Find the top change event in the history. Pop off selection
	  // events that are in the way.
	  function lastChangeEvent(hist, force) {
	    if (force) {
	      clearSelectionEvents(hist.done);
	      return lst(hist.done)
	    } else if (hist.done.length && !lst(hist.done).ranges) {
	      return lst(hist.done)
	    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	      hist.done.pop();
	      return lst(hist.done)
	    }
	  }

	  // Register a change in the history. Merges changes that are within
	  // a single operation, or are close together with an origin that
	  // allows merging (starting with "+") into a single event.
	  function addChangeToHistory(doc, change, selAfter, opId) {
	    var hist = doc.history;
	    hist.undone.length = 0;
	    var time = +new Date, cur;
	    var last;

	    if ((hist.lastOp == opId ||
	         hist.lastOrigin == change.origin && change.origin &&
	         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
	          change.origin.charAt(0) == "*")) &&
	        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	      // Merge this change into the last event
	      last = lst(cur.changes);
	      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	        // Optimized case for simple insertion -- don't want to add
	        // new changesets for every character typed
	        last.to = changeEnd(change);
	      } else {
	        // Add new sub-event
	        cur.changes.push(historyChangeFromChange(doc, change));
	      }
	    } else {
	      // Can not be merged, start a new event.
	      var before = lst(hist.done);
	      if (!before || !before.ranges)
	        { pushSelectionToHistory(doc.sel, hist.done); }
	      cur = {changes: [historyChangeFromChange(doc, change)],
	             generation: hist.generation};
	      hist.done.push(cur);
	      while (hist.done.length > hist.undoDepth) {
	        hist.done.shift();
	        if (!hist.done[0].ranges) { hist.done.shift(); }
	      }
	    }
	    hist.done.push(selAfter);
	    hist.generation = ++hist.maxGeneration;
	    hist.lastModTime = hist.lastSelTime = time;
	    hist.lastOp = hist.lastSelOp = opId;
	    hist.lastOrigin = hist.lastSelOrigin = change.origin;

	    if (!last) { signal(doc, "historyAdded"); }
	  }

	  function selectionEventCanBeMerged(doc, origin, prev, sel) {
	    var ch = origin.charAt(0);
	    return ch == "*" ||
	      ch == "+" &&
	      prev.ranges.length == sel.ranges.length &&
	      prev.somethingSelected() == sel.somethingSelected() &&
	      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
	  }

	  // Called whenever the selection changes, sets the new selection as
	  // the pending selection in the history, and pushes the old pending
	  // selection into the 'done' array when it was significantly
	  // different (in number of selected ranges, emptiness, or time).
	  function addSelectionToHistory(doc, sel, opId, options) {
	    var hist = doc.history, origin = options && options.origin;

	    // A new event is started when the previous origin does not match
	    // the current, or the origins don't allow matching. Origins
	    // starting with * are always merged, those starting with + are
	    // merged when similar and close together in time.
	    if (opId == hist.lastSelOp ||
	        (origin && hist.lastSelOrigin == origin &&
	         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	      { hist.done[hist.done.length - 1] = sel; }
	    else
	      { pushSelectionToHistory(sel, hist.done); }

	    hist.lastSelTime = +new Date;
	    hist.lastSelOrigin = origin;
	    hist.lastSelOp = opId;
	    if (options && options.clearRedo !== false)
	      { clearSelectionEvents(hist.undone); }
	  }

	  function pushSelectionToHistory(sel, dest) {
	    var top = lst(dest);
	    if (!(top && top.ranges && top.equals(sel)))
	      { dest.push(sel); }
	  }

	  // Used to store marked span information in the history.
	  function attachLocalSpans(doc, change, from, to) {
	    var existing = change["spans_" + doc.id], n = 0;
	    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
	      if (line.markedSpans)
	        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
	      ++n;
	    });
	  }

	  // When un/re-doing restores text containing marked spans, those
	  // that have been explicitly cleared should not be restored.
	  function removeClearedSpans(spans) {
	    if (!spans) { return null }
	    var out;
	    for (var i = 0; i < spans.length; ++i) {
	      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
	      else if (out) { out.push(spans[i]); }
	    }
	    return !out ? spans : out.length ? out : null
	  }

	  // Retrieve and filter the old marked spans stored in a change event.
	  function getOldSpans(doc, change) {
	    var found = change["spans_" + doc.id];
	    if (!found) { return null }
	    var nw = [];
	    for (var i = 0; i < change.text.length; ++i)
	      { nw.push(removeClearedSpans(found[i])); }
	    return nw
	  }

	  // Used for un/re-doing changes from the history. Combines the
	  // result of computing the existing spans with the set of spans that
	  // existed in the history (so that deleting around a span and then
	  // undoing brings back the span).
	  function mergeOldSpans(doc, change) {
	    var old = getOldSpans(doc, change);
	    var stretched = stretchSpansOverChange(doc, change);
	    if (!old) { return stretched }
	    if (!stretched) { return old }

	    for (var i = 0; i < old.length; ++i) {
	      var oldCur = old[i], stretchCur = stretched[i];
	      if (oldCur && stretchCur) {
	        spans: for (var j = 0; j < stretchCur.length; ++j) {
	          var span = stretchCur[j];
	          for (var k = 0; k < oldCur.length; ++k)
	            { if (oldCur[k].marker == span.marker) { continue spans } }
	          oldCur.push(span);
	        }
	      } else if (stretchCur) {
	        old[i] = stretchCur;
	      }
	    }
	    return old
	  }

	  // Used both to provide a JSON-safe object in .getHistory, and, when
	  // detaching a document, to split the history in two
	  function copyHistoryArray(events, newGroup, instantiateSel) {
	    var copy = [];
	    for (var i = 0; i < events.length; ++i) {
	      var event = events[i];
	      if (event.ranges) {
	        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	        continue
	      }
	      var changes = event.changes, newChanges = [];
	      copy.push({changes: newChanges});
	      for (var j = 0; j < changes.length; ++j) {
	        var change = changes[j], m = (void 0);
	        newChanges.push({from: change.from, to: change.to, text: change.text});
	        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
	          if (indexOf(newGroup, Number(m[1])) > -1) {
	            lst(newChanges)[prop] = change[prop];
	            delete change[prop];
	          }
	        } } }
	      }
	    }
	    return copy
	  }

	  // The 'scroll' parameter given to many of these indicated whether
	  // the new cursor position should be scrolled into view after
	  // modifying the selection.

	  // If shift is held or the extend flag is set, extends a range to
	  // include a given position (and optionally a second position).
	  // Otherwise, simply returns the range between the given positions.
	  // Used for cursor motion and such.
	  function extendRange(range, head, other, extend) {
	    if (extend) {
	      var anchor = range.anchor;
	      if (other) {
	        var posBefore = cmp(head, anchor) < 0;
	        if (posBefore != (cmp(other, anchor) < 0)) {
	          anchor = head;
	          head = other;
	        } else if (posBefore != (cmp(head, other) < 0)) {
	          head = other;
	        }
	      }
	      return new Range(anchor, head)
	    } else {
	      return new Range(other || head, head)
	    }
	  }

	  // Extend the primary selection range, discard the rest.
	  function extendSelection(doc, head, other, options, extend) {
	    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
	    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
	  }

	  // Extend all selections (pos is an array of selections with length
	  // equal the number of selections)
	  function extendSelections(doc, heads, options) {
	    var out = [];
	    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
	    for (var i = 0; i < doc.sel.ranges.length; i++)
	      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
	    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
	    setSelection(doc, newSel, options);
	  }

	  // Updates a single range in the selection.
	  function replaceOneSelection(doc, i, range, options) {
	    var ranges = doc.sel.ranges.slice(0);
	    ranges[i] = range;
	    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
	  }

	  // Reset the selection to a single range.
	  function setSimpleSelection(doc, anchor, head, options) {
	    setSelection(doc, simpleSelection(anchor, head), options);
	  }

	  // Give beforeSelectionChange handlers a change to influence a
	  // selection update.
	  function filterSelectionChange(doc, sel, options) {
	    var obj = {
	      ranges: sel.ranges,
	      update: function(ranges) {
	        this.ranges = [];
	        for (var i = 0; i < ranges.length; i++)
	          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                     clipPos(doc, ranges[i].head)); }
	      },
	      origin: options && options.origin
	    };
	    signal(doc, "beforeSelectionChange", doc, obj);
	    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
	    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
	    else { return sel }
	  }

	  function setSelectionReplaceHistory(doc, sel, options) {
	    var done = doc.history.done, last = lst(done);
	    if (last && last.ranges) {
	      done[done.length - 1] = sel;
	      setSelectionNoUndo(doc, sel, options);
	    } else {
	      setSelection(doc, sel, options);
	    }
	  }

	  // Set a new selection.
	  function setSelection(doc, sel, options) {
	    setSelectionNoUndo(doc, sel, options);
	    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	  }

	  function setSelectionNoUndo(doc, sel, options) {
	    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	      { sel = filterSelectionChange(doc, sel, options); }

	    var bias = options && options.bias ||
	      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

	    if (!(options && options.scroll === false) && doc.cm)
	      { ensureCursorVisible(doc.cm); }
	  }

	  function setSelectionInner(doc, sel) {
	    if (sel.equals(doc.sel)) { return }

	    doc.sel = sel;

	    if (doc.cm) {
	      doc.cm.curOp.updateInput = 1;
	      doc.cm.curOp.selectionChanged = true;
	      signalCursorActivity(doc.cm);
	    }
	    signalLater(doc, "cursorActivity", doc);
	  }

	  // Verify that the selection does not partially select any atomic
	  // marked ranges.
	  function reCheckSelection(doc) {
	    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
	  }

	  // Return a selection that does not partially select any atomic
	  // ranges.
	  function skipAtomicInSelection(doc, sel, bias, mayClear) {
	    var out;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range = sel.ranges[i];
	      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
	      if (out || newAnchor != range.anchor || newHead != range.head) {
	        if (!out) { out = sel.ranges.slice(0, i); }
	        out[i] = new Range(newAnchor, newHead);
	      }
	    }
	    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
	  }

	  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	    var line = getLine(doc, pos.line);
	    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	      var sp = line.markedSpans[i], m = sp.marker;

	      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
	      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
	      // is with selectLeft/Right
	      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
	      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

	      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	        if (mayClear) {
	          signal(m, "beforeCursorEnter");
	          if (m.explicitlyCleared) {
	            if (!line.markedSpans) { break }
	            else {--i; continue}
	          }
	        }
	        if (!m.atomic) { continue }

	        if (oldPos) {
	          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
	          if (dir < 0 ? preventCursorRight : preventCursorLeft)
	            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
	          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
	        }

	        var far = m.find(dir < 0 ? -1 : 1);
	        if (dir < 0 ? preventCursorLeft : preventCursorRight)
	          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
	        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
	      }
	    } }
	    return pos
	  }

	  // Ensure a given position is not inside an atomic range.
	  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	    var dir = bias || 1;
	    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
	    if (!found) {
	      doc.cantEdit = true;
	      return Pos(doc.first, 0)
	    }
	    return found
	  }

	  function movePos(doc, pos, dir, line) {
	    if (dir < 0 && pos.ch == 0) {
	      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
	      else { return null }
	    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
	      else { return null }
	    } else {
	      return new Pos(pos.line, pos.ch + dir)
	    }
	  }

	  function selectAll(cm) {
	    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
	  }

	  // UPDATING

	  // Allow "beforeChange" event handlers to influence a change
	  function filterChange(doc, change, update) {
	    var obj = {
	      canceled: false,
	      from: change.from,
	      to: change.to,
	      text: change.text,
	      origin: change.origin,
	      cancel: function () { return obj.canceled = true; }
	    };
	    if (update) { obj.update = function (from, to, text, origin) {
	      if (from) { obj.from = clipPos(doc, from); }
	      if (to) { obj.to = clipPos(doc, to); }
	      if (text) { obj.text = text; }
	      if (origin !== undefined) { obj.origin = origin; }
	    }; }
	    signal(doc, "beforeChange", doc, obj);
	    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

	    if (obj.canceled) {
	      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
	      return null
	    }
	    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
	  }

	  // Apply a change to a document, and add it to the document's
	  // history, and propagating it to all linked documents.
	  function makeChange(doc, change, ignoreReadOnly) {
	    if (doc.cm) {
	      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
	      if (doc.cm.state.suppressEdits) { return }
	    }

	    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	      change = filterChange(doc, change, true);
	      if (!change) { return }
	    }

	    // Possibly split or suppress the update based on the presence
	    // of read-only spans in its range.
	    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	    if (split) {
	      for (var i = split.length - 1; i >= 0; --i)
	        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
	    } else {
	      makeChangeInner(doc, change);
	    }
	  }

	  function makeChangeInner(doc, change) {
	    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
	    var selAfter = computeSelAfterChange(doc, change);
	    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

	    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	    var rebased = [];

	    linkedDocs(doc, function (doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	    });
	  }

	  // Revert a change stored in a document's history.
	  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	    var suppress = doc.cm && doc.cm.state.suppressEdits;
	    if (suppress && !allowSelectionOnly) { return }

	    var hist = doc.history, event, selAfter = doc.sel;
	    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

	    // Verify that there is a useable event (so that ctrl-z won't
	    // needlessly clear selection events)
	    var i = 0;
	    for (; i < source.length; i++) {
	      event = source[i];
	      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	        { break }
	    }
	    if (i == source.length) { return }
	    hist.lastOrigin = hist.lastSelOrigin = null;

	    for (;;) {
	      event = source.pop();
	      if (event.ranges) {
	        pushSelectionToHistory(event, dest);
	        if (allowSelectionOnly && !event.equals(doc.sel)) {
	          setSelection(doc, event, {clearRedo: false});
	          return
	        }
	        selAfter = event;
	      } else if (suppress) {
	        source.push(event);
	        return
	      } else { break }
	    }

	    // Build up a reverse change object to add to the opposite history
	    // stack (redo when undoing, and vice versa).
	    var antiChanges = [];
	    pushSelectionToHistory(selAfter, dest);
	    dest.push({changes: antiChanges, generation: hist.generation});
	    hist.generation = event.generation || ++hist.maxGeneration;

	    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

	    var loop = function ( i ) {
	      var change = event.changes[i];
	      change.origin = type;
	      if (filter && !filterChange(doc, change, false)) {
	        source.length = 0;
	        return {}
	      }

	      antiChanges.push(historyChangeFromChange(doc, change));

	      var after = i ? computeSelAfterChange(doc, change) : lst(source);
	      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
	      var rebased = [];

	      // Propagate to the linked documents
	      linkedDocs(doc, function (doc, sharedHist) {
	        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	          rebaseHist(doc.history, change);
	          rebased.push(doc.history);
	        }
	        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	      });
	    };

	    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
	      var returned = loop( i$1 );

	      if ( returned ) return returned.v;
	    }
	  }

	  // Sub-views need their line numbers shifted when text is added
	  // above or below them in the parent document.
	  function shiftDoc(doc, distance) {
	    if (distance == 0) { return }
	    doc.first += distance;
	    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
	      Pos(range.anchor.line + distance, range.anchor.ch),
	      Pos(range.head.line + distance, range.head.ch)
	    ); }), doc.sel.primIndex);
	    if (doc.cm) {
	      regChange(doc.cm, doc.first, doc.first - distance, distance);
	      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	        { regLineChange(doc.cm, l, "gutter"); }
	    }
	  }

	  // More lower-level change function, handling only a single document
	  // (not linked ones).
	  function makeChangeSingleDoc(doc, change, selAfter, spans) {
	    if (doc.cm && !doc.cm.curOp)
	      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

	    if (change.to.line < doc.first) {
	      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	      return
	    }
	    if (change.from.line > doc.lastLine()) { return }

	    // Clip the change to the size of this doc
	    if (change.from.line < doc.first) {
	      var shift = change.text.length - 1 - (doc.first - change.from.line);
	      shiftDoc(doc, shift);
	      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	                text: [lst(change.text)], origin: change.origin};
	    }
	    var last = doc.lastLine();
	    if (change.to.line > last) {
	      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	                text: [change.text[0]], origin: change.origin};
	    }

	    change.removed = getBetween(doc, change.from, change.to);

	    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
	    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
	    else { updateDoc(doc, change, spans); }
	    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

	    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
	      { doc.cantEdit = false; }
	  }

	  // Handle the interaction of a change to a document with the editor
	  // that this document is part of.
	  function makeChangeSingleDocInEditor(cm, change, spans) {
	    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

	    var recomputeMaxLength = false, checkWidthStart = from.line;
	    if (!cm.options.lineWrapping) {
	      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	      doc.iter(checkWidthStart, to.line + 1, function (line) {
	        if (line == display.maxLine) {
	          recomputeMaxLength = true;
	          return true
	        }
	      });
	    }

	    if (doc.sel.contains(change.from, change.to) > -1)
	      { signalCursorActivity(cm); }

	    updateDoc(doc, change, spans, estimateHeight(cm));

	    if (!cm.options.lineWrapping) {
	      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
	        var len = lineLength(line);
	        if (len > display.maxLineLength) {
	          display.maxLine = line;
	          display.maxLineLength = len;
	          display.maxLineChanged = true;
	          recomputeMaxLength = false;
	        }
	      });
	      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
	    }

	    retreatFrontier(doc, from.line);
	    startWorker(cm, 400);

	    var lendiff = change.text.length - (to.line - from.line) - 1;
	    // Remember that these lines changed, for updating the display
	    if (change.full)
	      { regChange(cm); }
	    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	      { regLineChange(cm, from.line, "text"); }
	    else
	      { regChange(cm, from.line, to.line + 1, lendiff); }

	    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	    if (changeHandler || changesHandler) {
	      var obj = {
	        from: from, to: to,
	        text: change.text,
	        removed: change.removed,
	        origin: change.origin
	      };
	      if (changeHandler) { signalLater(cm, "change", cm, obj); }
	      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
	    }
	    cm.display.selForContextMenu = null;
	  }

	  function replaceRange(doc, code, from, to, origin) {
	    var assign;

	    if (!to) { to = from; }
	    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
	    if (typeof code == "string") { code = doc.splitLines(code); }
	    makeChange(doc, {from: from, to: to, text: code, origin: origin});
	  }

	  // Rebasing/resetting history to deal with externally-sourced changes

	  function rebaseHistSelSingle(pos, from, to, diff) {
	    if (to < pos.line) {
	      pos.line += diff;
	    } else if (from < pos.line) {
	      pos.line = from;
	      pos.ch = 0;
	    }
	  }

	  // Tries to rebase an array of history events given a change in the
	  // document. If the change touches the same lines as the event, the
	  // event, and everything 'behind' it, is discarded. If the change is
	  // before the event, the event's positions are updated. Uses a
	  // copy-on-write scheme for the positions, to avoid having to
	  // reallocate them all on every rebase, but also avoid problems with
	  // shared position objects being unsafely updated.
	  function rebaseHistArray(array, from, to, diff) {
	    for (var i = 0; i < array.length; ++i) {
	      var sub = array[i], ok = true;
	      if (sub.ranges) {
	        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	        for (var j = 0; j < sub.ranges.length; j++) {
	          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	        }
	        continue
	      }
	      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
	        var cur = sub.changes[j$1];
	        if (to < cur.from.line) {
	          cur.from = Pos(cur.from.line + diff, cur.from.ch);
	          cur.to = Pos(cur.to.line + diff, cur.to.ch);
	        } else if (from <= cur.to.line) {
	          ok = false;
	          break
	        }
	      }
	      if (!ok) {
	        array.splice(0, i + 1);
	        i = 0;
	      }
	    }
	  }

	  function rebaseHist(hist, change) {
	    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	    rebaseHistArray(hist.done, from, to, diff);
	    rebaseHistArray(hist.undone, from, to, diff);
	  }

	  // Utility for applying a change to a line by handle or number,
	  // returning the number and optionally registering the line as
	  // changed.
	  function changeLine(doc, handle, changeType, op) {
	    var no = handle, line = handle;
	    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
	    else { no = lineNo(handle); }
	    if (no == null) { return null }
	    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
	    return line
	  }

	  // The document is represented as a BTree consisting of leaves, with
	  // chunk of lines in them, and branches, with up to ten leaves or
	  // other branch nodes below them. The top node is always a branch
	  // node, and is the document object itself (meaning it has
	  // additional methods and properties).
	  //
	  // All nodes have parent links. The tree is used both to go from
	  // line numbers to line objects, and to go from objects to numbers.
	  // It also indexes by height, and is used to convert between height
	  // and line object, and to find the total height of the document.
	  //
	  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

	  function LeafChunk(lines) {
	    this.lines = lines;
	    this.parent = null;
	    var height = 0;
	    for (var i = 0; i < lines.length; ++i) {
	      lines[i].parent = this;
	      height += lines[i].height;
	    }
	    this.height = height;
	  }

	  LeafChunk.prototype = {
	    chunkSize: function() { return this.lines.length },

	    // Remove the n lines at offset 'at'.
	    removeInner: function(at, n) {
	      for (var i = at, e = at + n; i < e; ++i) {
	        var line = this.lines[i];
	        this.height -= line.height;
	        cleanUpLine(line);
	        signalLater(line, "delete");
	      }
	      this.lines.splice(at, n);
	    },

	    // Helper used to collapse a small branch into a single leaf.
	    collapse: function(lines) {
	      lines.push.apply(lines, this.lines);
	    },

	    // Insert the given array of lines at offset 'at', count them as
	    // having the given height.
	    insertInner: function(at, lines, height) {
	      this.height += height;
	      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
	    },

	    // Used to iterate over a part of the tree.
	    iterN: function(at, n, op) {
	      for (var e = at + n; at < e; ++at)
	        { if (op(this.lines[at])) { return true } }
	    }
	  };

	  function BranchChunk(children) {
	    this.children = children;
	    var size = 0, height = 0;
	    for (var i = 0; i < children.length; ++i) {
	      var ch = children[i];
	      size += ch.chunkSize(); height += ch.height;
	      ch.parent = this;
	    }
	    this.size = size;
	    this.height = height;
	    this.parent = null;
	  }

	  BranchChunk.prototype = {
	    chunkSize: function() { return this.size },

	    removeInner: function(at, n) {
	      this.size -= n;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var rm = Math.min(n, sz - at), oldHeight = child.height;
	          child.removeInner(at, rm);
	          this.height -= oldHeight - child.height;
	          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
	          if ((n -= rm) == 0) { break }
	          at = 0;
	        } else { at -= sz; }
	      }
	      // If the result is smaller than 25 lines, ensure that it is a
	      // single leaf node.
	      if (this.size - n < 25 &&
	          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	        var lines = [];
	        this.collapse(lines);
	        this.children = [new LeafChunk(lines)];
	        this.children[0].parent = this;
	      }
	    },

	    collapse: function(lines) {
	      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
	    },

	    insertInner: function(at, lines, height) {
	      this.size += lines.length;
	      this.height += height;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at <= sz) {
	          child.insertInner(at, lines, height);
	          if (child.lines && child.lines.length > 50) {
	            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	            var remaining = child.lines.length % 25 + 25;
	            for (var pos = remaining; pos < child.lines.length;) {
	              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	              child.height -= leaf.height;
	              this.children.splice(++i, 0, leaf);
	              leaf.parent = this;
	            }
	            child.lines = child.lines.slice(0, remaining);
	            this.maybeSpill();
	          }
	          break
	        }
	        at -= sz;
	      }
	    },

	    // When a node has grown, check whether it should be split.
	    maybeSpill: function() {
	      if (this.children.length <= 10) { return }
	      var me = this;
	      do {
	        var spilled = me.children.splice(me.children.length - 5, 5);
	        var sibling = new BranchChunk(spilled);
	        if (!me.parent) { // Become the parent node
	          var copy = new BranchChunk(me.children);
	          copy.parent = me;
	          me.children = [copy, sibling];
	          me = copy;
	       } else {
	          me.size -= sibling.size;
	          me.height -= sibling.height;
	          var myIndex = indexOf(me.parent.children, me);
	          me.parent.children.splice(myIndex + 1, 0, sibling);
	        }
	        sibling.parent = me.parent;
	      } while (me.children.length > 10)
	      me.parent.maybeSpill();
	    },

	    iterN: function(at, n, op) {
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var used = Math.min(n, sz - at);
	          if (child.iterN(at, used, op)) { return true }
	          if ((n -= used) == 0) { break }
	          at = 0;
	        } else { at -= sz; }
	      }
	    }
	  };

	  // Line widgets are block elements displayed above or below a line.

	  var LineWidget = function(doc, node, options) {
	    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
	      { this[opt] = options[opt]; } } }
	    this.doc = doc;
	    this.node = node;
	  };

	  LineWidget.prototype.clear = function () {
	    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	    if (no == null || !ws) { return }
	    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
	    if (!ws.length) { line.widgets = null; }
	    var height = widgetHeight(this);
	    updateLineHeight(line, Math.max(0, line.height - height));
	    if (cm) {
	      runInOp(cm, function () {
	        adjustScrollWhenAboveVisible(cm, line, -height);
	        regLineChange(cm, no, "widget");
	      });
	      signalLater(cm, "lineWidgetCleared", cm, this, no);
	    }
	  };

	  LineWidget.prototype.changed = function () {
	      var this$1 = this;

	    var oldH = this.height, cm = this.doc.cm, line = this.line;
	    this.height = null;
	    var diff = widgetHeight(this) - oldH;
	    if (!diff) { return }
	    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
	    if (cm) {
	      runInOp(cm, function () {
	        cm.curOp.forceUpdate = true;
	        adjustScrollWhenAboveVisible(cm, line, diff);
	        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
	      });
	    }
	  };
	  eventMixin(LineWidget);

	  function adjustScrollWhenAboveVisible(cm, line, diff) {
	    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	      { addToScrollTop(cm, diff); }
	  }

	  function addLineWidget(doc, handle, node, options) {
	    var widget = new LineWidget(doc, node, options);
	    var cm = doc.cm;
	    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
	    changeLine(doc, handle, "widget", function (line) {
	      var widgets = line.widgets || (line.widgets = []);
	      if (widget.insertAt == null) { widgets.push(widget); }
	      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
	      widget.line = line;
	      if (cm && !lineIsHidden(doc, line)) {
	        var aboveVisible = heightAtLine(line) < doc.scrollTop;
	        updateLineHeight(line, line.height + widgetHeight(widget));
	        if (aboveVisible) { addToScrollTop(cm, widget.height); }
	        cm.curOp.forceUpdate = true;
	      }
	      return true
	    });
	    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
	    return widget
	  }

	  // TEXTMARKERS

	  // Created with markText and setBookmark methods. A TextMarker is a
	  // handle that can be used to clear or find a marked position in the
	  // document. Line objects hold arrays (markedSpans) containing
	  // {from, to, marker} object pointing to such marker objects, and
	  // indicating that such a marker is present on that line. Multiple
	  // lines may point to the same marker when it spans across lines.
	  // The spans will have null for their from/to properties when the
	  // marker continues beyond the start/end of the line. Markers have
	  // links back to the lines they currently touch.

	  // Collapsed markers have unique ids, in order to be able to order
	  // them, which is needed for uniquely determining an outer marker
	  // when they overlap (they may nest, but not partially overlap).
	  var nextMarkerId = 0;

	  var TextMarker = function(doc, type) {
	    this.lines = [];
	    this.type = type;
	    this.doc = doc;
	    this.id = ++nextMarkerId;
	  };

	  // Clear the marker.
	  TextMarker.prototype.clear = function () {
	    if (this.explicitlyCleared) { return }
	    var cm = this.doc.cm, withOp = cm && !cm.curOp;
	    if (withOp) { startOperation(cm); }
	    if (hasHandler(this, "clear")) {
	      var found = this.find();
	      if (found) { signalLater(this, "clear", found.from, found.to); }
	    }
	    var min = null, max = null;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
	      else if (cm) {
	        if (span.to != null) { max = lineNo(line); }
	        if (span.from != null) { min = lineNo(line); }
	      }
	      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
	        { updateLineHeight(line, textHeight(cm.display)); }
	    }
	    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
	      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
	      if (len > cm.display.maxLineLength) {
	        cm.display.maxLine = visual;
	        cm.display.maxLineLength = len;
	        cm.display.maxLineChanged = true;
	      }
	    } }

	    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
	    this.lines.length = 0;
	    this.explicitlyCleared = true;
	    if (this.atomic && this.doc.cantEdit) {
	      this.doc.cantEdit = false;
	      if (cm) { reCheckSelection(cm.doc); }
	    }
	    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
	    if (withOp) { endOperation(cm); }
	    if (this.parent) { this.parent.clear(); }
	  };

	  // Find the position of the marker in the document. Returns a {from,
	  // to} object by default. Side can be passed to get a specific side
	  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	  // Pos objects returned contain a line object, rather than a line
	  // number (used to prevent looking up the same line twice).
	  TextMarker.prototype.find = function (side, lineObj) {
	    if (side == null && this.type == "bookmark") { side = 1; }
	    var from, to;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (span.from != null) {
	        from = Pos(lineObj ? line : lineNo(line), span.from);
	        if (side == -1) { return from }
	      }
	      if (span.to != null) {
	        to = Pos(lineObj ? line : lineNo(line), span.to);
	        if (side == 1) { return to }
	      }
	    }
	    return from && {from: from, to: to}
	  };

	  // Signals that the marker's widget changed, and surrounding layout
	  // should be recomputed.
	  TextMarker.prototype.changed = function () {
	      var this$1 = this;

	    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	    if (!pos || !cm) { return }
	    runInOp(cm, function () {
	      var line = pos.line, lineN = lineNo(pos.line);
	      var view = findViewForLine(cm, lineN);
	      if (view) {
	        clearLineMeasurementCacheFor(view);
	        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	      }
	      cm.curOp.updateMaxLine = true;
	      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	        var oldHeight = widget.height;
	        widget.height = null;
	        var dHeight = widgetHeight(widget) - oldHeight;
	        if (dHeight)
	          { updateLineHeight(line, line.height + dHeight); }
	      }
	      signalLater(cm, "markerChanged", cm, this$1);
	    });
	  };

	  TextMarker.prototype.attachLine = function (line) {
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp;
	      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
	    }
	    this.lines.push(line);
	  };

	  TextMarker.prototype.detachLine = function (line) {
	    this.lines.splice(indexOf(this.lines, line), 1);
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp
	      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	    }
	  };
	  eventMixin(TextMarker);

	  // Create a marker, wire it up to the right lines, and
	  function markText(doc, from, to, options, type) {
	    // Shared markers (across linked documents) are handled separately
	    // (markTextShared will call out to this again, once per
	    // document).
	    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
	    // Ensure we are in an operation.
	    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

	    var marker = new TextMarker(doc, type), diff = cmp(from, to);
	    if (options) { copyObj(options, marker, false); }
	    // Don't connect empty markers unless clearWhenEmpty is false
	    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	      { return marker }
	    if (marker.replacedWith) {
	      // Showing up as a widget implies collapsed (widget replaces text)
	      marker.collapsed = true;
	      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
	      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
	      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
	    }
	    if (marker.collapsed) {
	      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
	      seeCollapsedSpans();
	    }

	    if (marker.addToHistory)
	      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

	    var curLine = from.line, cm = doc.cm, updateMaxLine;
	    doc.iter(curLine, to.line + 1, function (line) {
	      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	        { updateMaxLine = true; }
	      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
	      addMarkedSpan(line, new MarkedSpan(marker,
	                                         curLine == from.line ? from.ch : null,
	                                         curLine == to.line ? to.ch : null));
	      ++curLine;
	    });
	    // lineIsHidden depends on the presence of the spans, so needs a second pass
	    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
	      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
	    }); }

	    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

	    if (marker.readOnly) {
	      seeReadOnlySpans();
	      if (doc.history.done.length || doc.history.undone.length)
	        { doc.clearHistory(); }
	    }
	    if (marker.collapsed) {
	      marker.id = ++nextMarkerId;
	      marker.atomic = true;
	    }
	    if (cm) {
	      // Sync editor state
	      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
	      if (marker.collapsed)
	        { regChange(cm, from.line, to.line + 1); }
	      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
	               marker.attributes || marker.title)
	        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
	      if (marker.atomic) { reCheckSelection(cm.doc); }
	      signalLater(cm, "markerAdded", cm, marker);
	    }
	    return marker
	  }

	  // SHARED TEXTMARKERS

	  // A shared marker spans multiple linked documents. It is
	  // implemented as a meta-marker-object controlling multiple normal
	  // markers.
	  var SharedTextMarker = function(markers, primary) {
	    this.markers = markers;
	    this.primary = primary;
	    for (var i = 0; i < markers.length; ++i)
	      { markers[i].parent = this; }
	  };

	  SharedTextMarker.prototype.clear = function () {
	    if (this.explicitlyCleared) { return }
	    this.explicitlyCleared = true;
	    for (var i = 0; i < this.markers.length; ++i)
	      { this.markers[i].clear(); }
	    signalLater(this, "clear");
	  };

	  SharedTextMarker.prototype.find = function (side, lineObj) {
	    return this.primary.find(side, lineObj)
	  };
	  eventMixin(SharedTextMarker);

	  function markTextShared(doc, from, to, options, type) {
	    options = copyObj(options);
	    options.shared = false;
	    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	    var widget = options.widgetNode;
	    linkedDocs(doc, function (doc) {
	      if (widget) { options.widgetNode = widget.cloneNode(true); }
	      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	      for (var i = 0; i < doc.linked.length; ++i)
	        { if (doc.linked[i].isParent) { return } }
	      primary = lst(markers);
	    });
	    return new SharedTextMarker(markers, primary)
	  }

	  function findSharedMarkers(doc) {
	    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
	  }

	  function copySharedMarkers(doc, markers) {
	    for (var i = 0; i < markers.length; i++) {
	      var marker = markers[i], pos = marker.find();
	      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	      if (cmp(mFrom, mTo)) {
	        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	        marker.markers.push(subMark);
	        subMark.parent = marker;
	      }
	    }
	  }

	  function detachSharedMarkers(markers) {
	    var loop = function ( i ) {
	      var marker = markers[i], linked = [marker.primary.doc];
	      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
	      for (var j = 0; j < marker.markers.length; j++) {
	        var subMarker = marker.markers[j];
	        if (indexOf(linked, subMarker.doc) == -1) {
	          subMarker.parent = null;
	          marker.markers.splice(j--, 1);
	        }
	      }
	    };

	    for (var i = 0; i < markers.length; i++) loop( i );
	  }

	  var nextDocId = 0;
	  var Doc = function(text, mode, firstLine, lineSep, direction) {
	    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
	    if (firstLine == null) { firstLine = 0; }

	    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	    this.first = firstLine;
	    this.scrollTop = this.scrollLeft = 0;
	    this.cantEdit = false;
	    this.cleanGeneration = 1;
	    this.modeFrontier = this.highlightFrontier = firstLine;
	    var start = Pos(firstLine, 0);
	    this.sel = simpleSelection(start);
	    this.history = new History(null);
	    this.id = ++nextDocId;
	    this.modeOption = mode;
	    this.lineSep = lineSep;
	    this.direction = (direction == "rtl") ? "rtl" : "ltr";
	    this.extend = false;

	    if (typeof text == "string") { text = this.splitLines(text); }
	    updateDoc(this, {from: start, to: start, text: text});
	    setSelection(this, simpleSelection(start), sel_dontScroll);
	  };

	  Doc.prototype = createObj(BranchChunk.prototype, {
	    constructor: Doc,
	    // Iterate over the document. Supports two forms -- with only one
	    // argument, it calls that for each line in the document. With
	    // three, it iterates over the range given by the first two (with
	    // the second being non-inclusive).
	    iter: function(from, to, op) {
	      if (op) { this.iterN(from - this.first, to - from, op); }
	      else { this.iterN(this.first, this.first + this.size, from); }
	    },

	    // Non-public interface for adding and removing lines.
	    insert: function(at, lines) {
	      var height = 0;
	      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
	      this.insertInner(at - this.first, lines, height);
	    },
	    remove: function(at, n) { this.removeInner(at - this.first, n); },

	    // From here, the methods are part of the public interface. Most
	    // are also available from CodeMirror (editor) instances.

	    getValue: function(lineSep) {
	      var lines = getLines(this, this.first, this.first + this.size);
	      if (lineSep === false) { return lines }
	      return lines.join(lineSep || this.lineSeparator())
	    },
	    setValue: docMethodOp(function(code) {
	      var top = Pos(this.first, 0), last = this.first + this.size - 1;
	      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                        text: this.splitLines(code), origin: "setValue", full: true}, true);
	      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
	      setSelection(this, simpleSelection(top), sel_dontScroll);
	    }),
	    replaceRange: function(code, from, to, origin) {
	      from = clipPos(this, from);
	      to = to ? clipPos(this, to) : from;
	      replaceRange(this, code, from, to, origin);
	    },
	    getRange: function(from, to, lineSep) {
	      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	      if (lineSep === false) { return lines }
	      return lines.join(lineSep || this.lineSeparator())
	    },

	    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

	    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
	    getLineNumber: function(line) {return lineNo(line)},

	    getLineHandleVisualStart: function(line) {
	      if (typeof line == "number") { line = getLine(this, line); }
	      return visualLine(line)
	    },

	    lineCount: function() {return this.size},
	    firstLine: function() {return this.first},
	    lastLine: function() {return this.first + this.size - 1},

	    clipPos: function(pos) {return clipPos(this, pos)},

	    getCursor: function(start) {
	      var range = this.sel.primary(), pos;
	      if (start == null || start == "head") { pos = range.head; }
	      else if (start == "anchor") { pos = range.anchor; }
	      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
	      else { pos = range.from(); }
	      return pos
	    },
	    listSelections: function() { return this.sel.ranges },
	    somethingSelected: function() {return this.sel.somethingSelected()},

	    setCursor: docMethodOp(function(line, ch, options) {
	      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	    }),
	    setSelection: docMethodOp(function(anchor, head, options) {
	      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	    }),
	    extendSelection: docMethodOp(function(head, other, options) {
	      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	    }),
	    extendSelections: docMethodOp(function(heads, options) {
	      extendSelections(this, clipPosArray(this, heads), options);
	    }),
	    extendSelectionsBy: docMethodOp(function(f, options) {
	      var heads = map(this.sel.ranges, f);
	      extendSelections(this, clipPosArray(this, heads), options);
	    }),
	    setSelections: docMethodOp(function(ranges, primary, options) {
	      if (!ranges.length) { return }
	      var out = [];
	      for (var i = 0; i < ranges.length; i++)
	        { out[i] = new Range(clipPos(this, ranges[i].anchor),
	                           clipPos(this, ranges[i].head)); }
	      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
	      setSelection(this, normalizeSelection(this.cm, out, primary), options);
	    }),
	    addSelection: docMethodOp(function(anchor, head, options) {
	      var ranges = this.sel.ranges.slice(0);
	      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
	    }),

	    getSelection: function(lineSep) {
	      var ranges = this.sel.ranges, lines;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        lines = lines ? lines.concat(sel) : sel;
	      }
	      if (lineSep === false) { return lines }
	      else { return lines.join(lineSep || this.lineSeparator()) }
	    },
	    getSelections: function(lineSep) {
	      var parts = [], ranges = this.sel.ranges;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
	        parts[i] = sel;
	      }
	      return parts
	    },
	    replaceSelection: function(code, collapse, origin) {
	      var dup = [];
	      for (var i = 0; i < this.sel.ranges.length; i++)
	        { dup[i] = code; }
	      this.replaceSelections(dup, collapse, origin || "+input");
	    },
	    replaceSelections: docMethodOp(function(code, collapse, origin) {
	      var changes = [], sel = this.sel;
	      for (var i = 0; i < sel.ranges.length; i++) {
	        var range = sel.ranges[i];
	        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
	      }
	      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
	        { makeChange(this, changes[i$1]); }
	      if (newSel) { setSelectionReplaceHistory(this, newSel); }
	      else if (this.cm) { ensureCursorVisible(this.cm); }
	    }),
	    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

	    setExtending: function(val) {this.extend = val;},
	    getExtending: function() {return this.extend},

	    historySize: function() {
	      var hist = this.history, done = 0, undone = 0;
	      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
	      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
	      return {undo: done, redo: undone}
	    },
	    clearHistory: function() {
	      var this$1 = this;

	      this.history = new History(this.history.maxGeneration);
	      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
	    },

	    markClean: function() {
	      this.cleanGeneration = this.changeGeneration(true);
	    },
	    changeGeneration: function(forceSplit) {
	      if (forceSplit)
	        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
	      return this.history.generation
	    },
	    isClean: function (gen) {
	      return this.history.generation == (gen || this.cleanGeneration)
	    },

	    getHistory: function() {
	      return {done: copyHistoryArray(this.history.done),
	              undone: copyHistoryArray(this.history.undone)}
	    },
	    setHistory: function(histData) {
	      var hist = this.history = new History(this.history.maxGeneration);
	      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	    },

	    setGutterMarker: docMethodOp(function(line, gutterID, value) {
	      return changeLine(this, line, "gutter", function (line) {
	        var markers = line.gutterMarkers || (line.gutterMarkers = {});
	        markers[gutterID] = value;
	        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
	        return true
	      })
	    }),

	    clearGutter: docMethodOp(function(gutterID) {
	      var this$1 = this;

	      this.iter(function (line) {
	        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	          changeLine(this$1, line, "gutter", function () {
	            line.gutterMarkers[gutterID] = null;
	            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
	            return true
	          });
	        }
	      });
	    }),

	    lineInfo: function(line) {
	      var n;
	      if (typeof line == "number") {
	        if (!isLine(this, line)) { return null }
	        n = line;
	        line = getLine(this, line);
	        if (!line) { return null }
	      } else {
	        n = lineNo(line);
	        if (n == null) { return null }
	      }
	      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	              widgets: line.widgets}
	    },

	    addLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        if (!line[prop]) { line[prop] = cls; }
	        else if (classTest(cls).test(line[prop])) { return false }
	        else { line[prop] += " " + cls; }
	        return true
	      })
	    }),
	    removeLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        var cur = line[prop];
	        if (!cur) { return false }
	        else if (cls == null) { line[prop] = null; }
	        else {
	          var found = cur.match(classTest(cls));
	          if (!found) { return false }
	          var end = found.index + found[0].length;
	          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	        }
	        return true
	      })
	    }),

	    addLineWidget: docMethodOp(function(handle, node, options) {
	      return addLineWidget(this, handle, node, options)
	    }),
	    removeLineWidget: function(widget) { widget.clear(); },

	    markText: function(from, to, options) {
	      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
	    },
	    setBookmark: function(pos, options) {
	      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                      insertLeft: options && options.insertLeft,
	                      clearWhenEmpty: false, shared: options && options.shared,
	                      handleMouseEvents: options && options.handleMouseEvents};
	      pos = clipPos(this, pos);
	      return markText(this, pos, pos, realOpts, "bookmark")
	    },
	    findMarksAt: function(pos) {
	      pos = clipPos(this, pos);
	      var markers = [], spans = getLine(this, pos.line).markedSpans;
	      if (spans) { for (var i = 0; i < spans.length; ++i) {
	        var span = spans[i];
	        if ((span.from == null || span.from <= pos.ch) &&
	            (span.to == null || span.to >= pos.ch))
	          { markers.push(span.marker.parent || span.marker); }
	      } }
	      return markers
	    },
	    findMarks: function(from, to, filter) {
	      from = clipPos(this, from); to = clipPos(this, to);
	      var found = [], lineNo = from.line;
	      this.iter(from.line, to.line + 1, function (line) {
	        var spans = line.markedSpans;
	        if (spans) { for (var i = 0; i < spans.length; i++) {
	          var span = spans[i];
	          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
	                span.from == null && lineNo != from.line ||
	                span.from != null && lineNo == to.line && span.from >= to.ch) &&
	              (!filter || filter(span.marker)))
	            { found.push(span.marker.parent || span.marker); }
	        } }
	        ++lineNo;
	      });
	      return found
	    },
	    getAllMarks: function() {
	      var markers = [];
	      this.iter(function (line) {
	        var sps = line.markedSpans;
	        if (sps) { for (var i = 0; i < sps.length; ++i)
	          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
	      });
	      return markers
	    },

	    posFromIndex: function(off) {
	      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
	      this.iter(function (line) {
	        var sz = line.text.length + sepSize;
	        if (sz > off) { ch = off; return true }
	        off -= sz;
	        ++lineNo;
	      });
	      return clipPos(this, Pos(lineNo, ch))
	    },
	    indexFromPos: function (coords) {
	      coords = clipPos(this, coords);
	      var index = coords.ch;
	      if (coords.line < this.first || coords.ch < 0) { return 0 }
	      var sepSize = this.lineSeparator().length;
	      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
	        index += line.text.length + sepSize;
	      });
	      return index
	    },

	    copy: function(copyHistory) {
	      var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                        this.modeOption, this.first, this.lineSep, this.direction);
	      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	      doc.sel = this.sel;
	      doc.extend = false;
	      if (copyHistory) {
	        doc.history.undoDepth = this.history.undoDepth;
	        doc.setHistory(this.getHistory());
	      }
	      return doc
	    },

	    linkedDoc: function(options) {
	      if (!options) { options = {}; }
	      var from = this.first, to = this.first + this.size;
	      if (options.from != null && options.from > from) { from = options.from; }
	      if (options.to != null && options.to < to) { to = options.to; }
	      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
	      if (options.sharedHist) { copy.history = this.history
	      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	      copySharedMarkers(copy, findSharedMarkers(this));
	      return copy
	    },
	    unlinkDoc: function(other) {
	      if (other instanceof CodeMirror) { other = other.doc; }
	      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
	        var link = this.linked[i];
	        if (link.doc != other) { continue }
	        this.linked.splice(i, 1);
	        other.unlinkDoc(this);
	        detachSharedMarkers(findSharedMarkers(this));
	        break
	      } }
	      // If the histories were shared, split them again
	      if (other.history == this.history) {
	        var splitIds = [other.id];
	        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
	        other.history = new History(null);
	        other.history.done = copyHistoryArray(this.history.done, splitIds);
	        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	      }
	    },
	    iterLinkedDocs: function(f) {linkedDocs(this, f);},

	    getMode: function() {return this.mode},
	    getEditor: function() {return this.cm},

	    splitLines: function(str) {
	      if (this.lineSep) { return str.split(this.lineSep) }
	      return splitLinesAuto(str)
	    },
	    lineSeparator: function() { return this.lineSep || "\n" },

	    setDirection: docMethodOp(function (dir) {
	      if (dir != "rtl") { dir = "ltr"; }
	      if (dir == this.direction) { return }
	      this.direction = dir;
	      this.iter(function (line) { return line.order = null; });
	      if (this.cm) { directionChanged(this.cm); }
	    })
	  });

	  // Public alias.
	  Doc.prototype.eachLine = Doc.prototype.iter;

	  // Kludge to work around strange IE behavior where it'll sometimes
	  // re-fire a series of drag-related events right after the drop (#1551)
	  var lastDrop = 0;

	  function onDrop(e) {
	    var cm = this;
	    clearDragCursor(cm);
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	      { return }
	    e_preventDefault(e);
	    if (ie) { lastDrop = +new Date; }
	    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	    if (!pos || cm.isReadOnly()) { return }
	    // Might be a file drop, in which case we simply extract the text
	    // and insert it.
	    if (files && files.length && window.FileReader && window.File) {
	      var n = files.length, text = Array(n), read = 0;
	      var markAsReadAndPasteIfAllFilesAreRead = function () {
	        if (++read == n) {
	          operation(cm, function () {
	            pos = clipPos(cm.doc, pos);
	            var change = {from: pos, to: pos,
	                          text: cm.doc.splitLines(
	                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
	                          origin: "paste"};
	            makeChange(cm.doc, change);
	            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
	          })();
	        }
	      };
	      var readTextFromFile = function (file, i) {
	        if (cm.options.allowDropFileTypes &&
	            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
	          markAsReadAndPasteIfAllFilesAreRead();
	          return
	        }
	        var reader = new FileReader;
	        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
	        reader.onload = function () {
	          var content = reader.result;
	          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
	            markAsReadAndPasteIfAllFilesAreRead();
	            return
	          }
	          text[i] = content;
	          markAsReadAndPasteIfAllFilesAreRead();
	        };
	        reader.readAsText(file);
	      };
	      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
	    } else { // Normal drop
	      // Don't do a replace if the drop happened inside of the selected text.
	      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	        cm.state.draggingText(e);
	        // Ensure the editor is re-focused
	        setTimeout(function () { return cm.display.input.focus(); }, 20);
	        return
	      }
	      try {
	        var text$1 = e.dataTransfer.getData("Text");
	        if (text$1) {
	          var selected;
	          if (cm.state.draggingText && !cm.state.draggingText.copy)
	            { selected = cm.listSelections(); }
	          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
	            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
	          cm.replaceSelection(text$1, "around", "paste");
	          cm.display.input.focus();
	        }
	      }
	      catch(e$1){}
	    }
	  }

	  function onDragStart(cm, e) {
	    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

	    e.dataTransfer.setData("Text", cm.getSelection());
	    e.dataTransfer.effectAllowed = "copyMove";

	    // Use dummy image instead of default browsers image.
	    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	    if (e.dataTransfer.setDragImage && !safari) {
	      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	      if (presto) {
	        img.width = img.height = 1;
	        cm.display.wrapper.appendChild(img);
	        // Force a relayout, or Opera won't use our image for some obscure reason
	        img._top = img.offsetTop;
	      }
	      e.dataTransfer.setDragImage(img, 0, 0);
	      if (presto) { img.parentNode.removeChild(img); }
	    }
	  }

	  function onDragOver(cm, e) {
	    var pos = posFromMouse(cm, e);
	    if (!pos) { return }
	    var frag = document.createDocumentFragment();
	    drawSelectionCursor(cm, pos, frag);
	    if (!cm.display.dragCursor) {
	      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	    }
	    removeChildrenAndAdd(cm.display.dragCursor, frag);
	  }

	  function clearDragCursor(cm) {
	    if (cm.display.dragCursor) {
	      cm.display.lineSpace.removeChild(cm.display.dragCursor);
	      cm.display.dragCursor = null;
	    }
	  }

	  // These must be handled carefully, because naively registering a
	  // handler for each editor will cause the editors to never be
	  // garbage collected.

	  function forEachCodeMirror(f) {
	    if (!document.getElementsByClassName) { return }
	    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
	    for (var i = 0; i < byClass.length; i++) {
	      var cm = byClass[i].CodeMirror;
	      if (cm) { editors.push(cm); }
	    }
	    if (editors.length) { editors[0].operation(function () {
	      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
	    }); }
	  }

	  var globalsRegistered = false;
	  function ensureGlobalHandlers() {
	    if (globalsRegistered) { return }
	    registerGlobalHandlers();
	    globalsRegistered = true;
	  }
	  function registerGlobalHandlers() {
	    // When the window resizes, we need to refresh active editors.
	    var resizeTimer;
	    on(window, "resize", function () {
	      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
	        resizeTimer = null;
	        forEachCodeMirror(onResize);
	      }, 100); }
	    });
	    // When the window loses focus, we want to show the editor as blurred
	    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
	  }
	  // Called when the window resizes
	  function onResize(cm) {
	    var d = cm.display;
	    // Might be a text scaling operation, clear size caches.
	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	    d.scrollbarsClipped = false;
	    cm.setSize();
	  }

	  var keyNames = {
	    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
	    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	  };

	  // Number keys
	  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
	  // Alphabetic keys
	  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
	  // Function keys
	  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

	  var keyMap = {};

	  keyMap.basic = {
	    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	    "Esc": "singleSelection"
	  };
	  // Note that the save and find-related commands aren't defined by
	  // default. User code or addons can define them. Unknown commands
	  // are simply ignored.
	  keyMap.pcDefault = {
	    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	    "fallthrough": "basic"
	  };
	  // Very basic readline/emacs-style bindings, which are standard on Mac.
	  keyMap.emacsy = {
	    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	    "Ctrl-O": "openLine"
	  };
	  keyMap.macDefault = {
	    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	    "fallthrough": ["basic", "emacsy"]
	  };
	  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

	  // KEYMAP DISPATCH

	  function normalizeKeyName(name) {
	    var parts = name.split(/-(?!$)/);
	    name = parts[parts.length - 1];
	    var alt, ctrl, shift, cmd;
	    for (var i = 0; i < parts.length - 1; i++) {
	      var mod = parts[i];
	      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
	      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
	      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
	      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
	      else { throw new Error("Unrecognized modifier name: " + mod) }
	    }
	    if (alt) { name = "Alt-" + name; }
	    if (ctrl) { name = "Ctrl-" + name; }
	    if (cmd) { name = "Cmd-" + name; }
	    if (shift) { name = "Shift-" + name; }
	    return name
	  }

	  // This is a kludge to keep keymaps mostly working as raw objects
	  // (backwards compatibility) while at the same time support features
	  // like normalization and multi-stroke key bindings. It compiles a
	  // new normalized keymap, and then updates the old object to reflect
	  // this.
	  function normalizeKeyMap(keymap) {
	    var copy = {};
	    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
	      var value = keymap[keyname];
	      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
	      if (value == "...") { delete keymap[keyname]; continue }

	      var keys = map(keyname.split(" "), normalizeKeyName);
	      for (var i = 0; i < keys.length; i++) {
	        var val = (void 0), name = (void 0);
	        if (i == keys.length - 1) {
	          name = keys.join(" ");
	          val = value;
	        } else {
	          name = keys.slice(0, i + 1).join(" ");
	          val = "...";
	        }
	        var prev = copy[name];
	        if (!prev) { copy[name] = val; }
	        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
	      }
	      delete keymap[keyname];
	    } }
	    for (var prop in copy) { keymap[prop] = copy[prop]; }
	    return keymap
	  }

	  function lookupKey(key, map, handle, context) {
	    map = getKeyMap(map);
	    var found = map.call ? map.call(key, context) : map[key];
	    if (found === false) { return "nothing" }
	    if (found === "...") { return "multi" }
	    if (found != null && handle(found)) { return "handled" }

	    if (map.fallthrough) {
	      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
	        { return lookupKey(key, map.fallthrough, handle, context) }
	      for (var i = 0; i < map.fallthrough.length; i++) {
	        var result = lookupKey(key, map.fallthrough[i], handle, context);
	        if (result) { return result }
	      }
	    }
	  }

	  // Modifier key presses don't count as 'real' key presses for the
	  // purpose of keymap fallthrough.
	  function isModifierKey(value) {
	    var name = typeof value == "string" ? value : keyNames[value.keyCode];
	    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
	  }

	  function addModifierNames(name, event, noShift) {
	    var base = name;
	    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
	    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
	    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
	    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
	    return name
	  }

	  // Look up the name of a key as indicated by an event object.
	  function keyName(event, noShift) {
	    if (presto && event.keyCode == 34 && event["char"]) { return false }
	    var name = keyNames[event.keyCode];
	    if (name == null || event.altGraphKey) { return false }
	    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
	    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
	    if (event.keyCode == 3 && event.code) { name = event.code; }
	    return addModifierNames(name, event, noShift)
	  }

	  function getKeyMap(val) {
	    return typeof val == "string" ? keyMap[val] : val
	  }

	  // Helper for deleting text near the selection(s), used to implement
	  // backspace, delete, and similar functionality.
	  function deleteNearSelection(cm, compute) {
	    var ranges = cm.doc.sel.ranges, kill = [];
	    // Build up a set of ranges to kill first, merging overlapping
	    // ranges.
	    for (var i = 0; i < ranges.length; i++) {
	      var toKill = compute(ranges[i]);
	      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	        var replaced = kill.pop();
	        if (cmp(replaced.from, toKill.from) < 0) {
	          toKill.from = replaced.from;
	          break
	        }
	      }
	      kill.push(toKill);
	    }
	    // Next, remove those actual ranges.
	    runInOp(cm, function () {
	      for (var i = kill.length - 1; i >= 0; i--)
	        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
	      ensureCursorVisible(cm);
	    });
	  }

	  function moveCharLogically(line, ch, dir) {
	    var target = skipExtendingChars(line.text, ch + dir, dir);
	    return target < 0 || target > line.text.length ? null : target
	  }

	  function moveLogically(line, start, dir) {
	    var ch = moveCharLogically(line, start.ch, dir);
	    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
	  }

	  function endOfLine(visually, cm, lineObj, lineNo, dir) {
	    if (visually) {
	      if (cm.doc.direction == "rtl") { dir = -dir; }
	      var order = getOrder(lineObj, cm.doc.direction);
	      if (order) {
	        var part = dir < 0 ? lst(order) : order[0];
	        var moveInStorageOrder = (dir < 0) == (part.level == 1);
	        var sticky = moveInStorageOrder ? "after" : "before";
	        var ch;
	        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
	        // it could be that the last bidi part is not on the last visual line,
	        // since visual lines contain content order-consecutive chunks.
	        // Thus, in rtl, we are looking for the first (content-order) character
	        // in the rtl chunk that is on the last line (that is, the same line
	        // as the last (content-order) character).
	        if (part.level > 0 || cm.doc.direction == "rtl") {
	          var prep = prepareMeasureForLine(cm, lineObj);
	          ch = dir < 0 ? lineObj.text.length - 1 : 0;
	          var targetTop = measureCharPrepared(cm, prep, ch).top;
	          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
	          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
	        } else { ch = dir < 0 ? part.to : part.from; }
	        return new Pos(lineNo, ch, sticky)
	      }
	    }
	    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
	  }

	  function moveVisually(cm, line, start, dir) {
	    var bidi = getOrder(line, cm.doc.direction);
	    if (!bidi) { return moveLogically(line, start, dir) }
	    if (start.ch >= line.text.length) {
	      start.ch = line.text.length;
	      start.sticky = "before";
	    } else if (start.ch <= 0) {
	      start.ch = 0;
	      start.sticky = "after";
	    }
	    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
	    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
	      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
	      // nothing interesting happens.
	      return moveLogically(line, start, dir)
	    }

	    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
	    var prep;
	    var getWrappedLineExtent = function (ch) {
	      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
	      prep = prep || prepareMeasureForLine(cm, line);
	      return wrappedLineExtentChar(cm, line, prep, ch)
	    };
	    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

	    if (cm.doc.direction == "rtl" || part.level == 1) {
	      var moveInStorageOrder = (part.level == 1) == (dir < 0);
	      var ch = mv(start, moveInStorageOrder ? 1 : -1);
	      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
	        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
	        var sticky = moveInStorageOrder ? "before" : "after";
	        return new Pos(start.line, ch, sticky)
	      }
	    }

	    // Case 3: Could not move within this bidi part in this visual line, so leave
	    // the current bidi part

	    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
	      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
	        ? new Pos(start.line, mv(ch, 1), "before")
	        : new Pos(start.line, ch, "after"); };

	      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
	        var part = bidi[partPos];
	        var moveInStorageOrder = (dir > 0) == (part.level != 1);
	        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
	        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
	        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
	        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
	      }
	    };

	    // Case 3a: Look for other bidi parts on the same visual line
	    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
	    if (res) { return res }

	    // Case 3b: Look for other bidi parts on the next visual line
	    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
	    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
	      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
	      if (res) { return res }
	    }

	    // Case 4: Nowhere to move
	    return null
	  }

	  // Commands are parameter-less actions that can be performed on an
	  // editor, mostly used for keybindings.
	  var commands = {
	    selectAll: selectAll,
	    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
	    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
	      if (range.empty()) {
	        var len = getLine(cm.doc, range.head.line).text.length;
	        if (range.head.ch == len && range.head.line < cm.lastLine())
	          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
	        else
	          { return {from: range.head, to: Pos(range.head.line, len)} }
	      } else {
	        return {from: range.from(), to: range.to()}
	      }
	    }); },
	    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	      from: Pos(range.from().line, 0),
	      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
	    }); }); },
	    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	      from: Pos(range.from().line, 0), to: range.from()
	    }); }); },
	    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
	      var top = cm.charCoords(range.head, "div").top + 5;
	      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	      return {from: leftPos, to: range.from()}
	    }); },
	    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
	      var top = cm.charCoords(range.head, "div").top + 5;
	      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	      return {from: range.from(), to: rightPos }
	    }); },
	    undo: function (cm) { return cm.undo(); },
	    redo: function (cm) { return cm.redo(); },
	    undoSelection: function (cm) { return cm.undoSelection(); },
	    redoSelection: function (cm) { return cm.redoSelection(); },
	    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
	    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
	    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
	      {origin: "+move", bias: 1}
	    ); },
	    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
	      {origin: "+move", bias: 1}
	    ); },
	    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
	      {origin: "+move", bias: -1}
	    ); },
	    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
	      var top = cm.cursorCoords(range.head, "div").top + 5;
	      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
	    }, sel_move); },
	    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
	      var top = cm.cursorCoords(range.head, "div").top + 5;
	      return cm.coordsChar({left: 0, top: top}, "div")
	    }, sel_move); },
	    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
	      var top = cm.cursorCoords(range.head, "div").top + 5;
	      var pos = cm.coordsChar({left: 0, top: top}, "div");
	      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
	      return pos
	    }, sel_move); },
	    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
	    goLineDown: function (cm) { return cm.moveV(1, "line"); },
	    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
	    goPageDown: function (cm) { return cm.moveV(1, "page"); },
	    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
	    goCharRight: function (cm) { return cm.moveH(1, "char"); },
	    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
	    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
	    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
	    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
	    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
	    goWordRight: function (cm) { return cm.moveH(1, "word"); },
	    delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
	    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
	    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
	    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
	    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
	    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
	    indentAuto: function (cm) { return cm.indentSelection("smart"); },
	    indentMore: function (cm) { return cm.indentSelection("add"); },
	    indentLess: function (cm) { return cm.indentSelection("subtract"); },
	    insertTab: function (cm) { return cm.replaceSelection("\t"); },
	    insertSoftTab: function (cm) {
	      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	      for (var i = 0; i < ranges.length; i++) {
	        var pos = ranges[i].from();
	        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	        spaces.push(spaceStr(tabSize - col % tabSize));
	      }
	      cm.replaceSelections(spaces);
	    },
	    defaultTab: function (cm) {
	      if (cm.somethingSelected()) { cm.indentSelection("add"); }
	      else { cm.execCommand("insertTab"); }
	    },
	    // Swap the two chars left and right of each selection's head.
	    // Move cursor behind the two swapped characters afterwards.
	    //
	    // Doesn't consider line feeds a character.
	    // Doesn't scan more than one line above to find a character.
	    // Doesn't do anything on an empty line.
	    // Doesn't do anything with non-empty selections.
	    transposeChars: function (cm) { return runInOp(cm, function () {
	      var ranges = cm.listSelections(), newSel = [];
	      for (var i = 0; i < ranges.length; i++) {
	        if (!ranges[i].empty()) { continue }
	        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	        if (line) {
	          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
	          if (cur.ch > 0) {
	            cur = new Pos(cur.line, cur.ch + 1);
	            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
	          } else if (cur.line > cm.doc.first) {
	            var prev = getLine(cm.doc, cur.line - 1).text;
	            if (prev) {
	              cur = new Pos(cur.line, 1);
	              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                              prev.charAt(prev.length - 1),
	                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
	            }
	          }
	        }
	        newSel.push(new Range(cur, cur));
	      }
	      cm.setSelections(newSel);
	    }); },
	    newlineAndIndent: function (cm) { return runInOp(cm, function () {
	      var sels = cm.listSelections();
	      for (var i = sels.length - 1; i >= 0; i--)
	        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
	      sels = cm.listSelections();
	      for (var i$1 = 0; i$1 < sels.length; i$1++)
	        { cm.indentLine(sels[i$1].from().line, null, true); }
	      ensureCursorVisible(cm);
	    }); },
	    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
	    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
	  };


	  function lineStart(cm, lineN) {
	    var line = getLine(cm.doc, lineN);
	    var visual = visualLine(line);
	    if (visual != line) { lineN = lineNo(visual); }
	    return endOfLine(true, cm, visual, lineN, 1)
	  }
	  function lineEnd(cm, lineN) {
	    var line = getLine(cm.doc, lineN);
	    var visual = visualLineEnd(line);
	    if (visual != line) { lineN = lineNo(visual); }
	    return endOfLine(true, cm, line, lineN, -1)
	  }
	  function lineStartSmart(cm, pos) {
	    var start = lineStart(cm, pos.line);
	    var line = getLine(cm.doc, start.line);
	    var order = getOrder(line, cm.doc.direction);
	    if (!order || order[0].level == 0) {
	      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
	      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
	    }
	    return start
	  }

	  // Run a handler that was bound to a key.
	  function doHandleBinding(cm, bound, dropShift) {
	    if (typeof bound == "string") {
	      bound = commands[bound];
	      if (!bound) { return false }
	    }
	    // Ensure previous input has been read, so that the handler sees a
	    // consistent view of the document
	    cm.display.input.ensurePolled();
	    var prevShift = cm.display.shift, done = false;
	    try {
	      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	      if (dropShift) { cm.display.shift = false; }
	      done = bound(cm) != Pass;
	    } finally {
	      cm.display.shift = prevShift;
	      cm.state.suppressEdits = false;
	    }
	    return done
	  }

	  function lookupKeyForEditor(cm, name, handle) {
	    for (var i = 0; i < cm.state.keyMaps.length; i++) {
	      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	      if (result) { return result }
	    }
	    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	      || lookupKey(name, cm.options.keyMap, handle, cm)
	  }

	  // Note that, despite the name, this function is also used to check
	  // for bound mouse clicks.

	  var stopSeq = new Delayed;

	  function dispatchKey(cm, name, e, handle) {
	    var seq = cm.state.keySeq;
	    if (seq) {
	      if (isModifierKey(name)) { return "handled" }
	      if (/\'$/.test(name))
	        { cm.state.keySeq = null; }
	      else
	        { stopSeq.set(50, function () {
	          if (cm.state.keySeq == seq) {
	            cm.state.keySeq = null;
	            cm.display.input.reset();
	          }
	        }); }
	      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
	    }
	    return dispatchKeyInner(cm, name, e, handle)
	  }

	  function dispatchKeyInner(cm, name, e, handle) {
	    var result = lookupKeyForEditor(cm, name, handle);

	    if (result == "multi")
	      { cm.state.keySeq = name; }
	    if (result == "handled")
	      { signalLater(cm, "keyHandled", cm, name, e); }

	    if (result == "handled" || result == "multi") {
	      e_preventDefault(e);
	      restartBlink(cm);
	    }

	    return !!result
	  }

	  // Handle a key from the keydown event.
	  function handleKeyBinding(cm, e) {
	    var name = keyName(e, true);
	    if (!name) { return false }

	    if (e.shiftKey && !cm.state.keySeq) {
	      // First try to resolve full name (including 'Shift-'). Failing
	      // that, see if there is a cursor-motion command (starting with
	      // 'go') bound to the keyname without 'Shift-'.
	      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
	          || dispatchKey(cm, name, e, function (b) {
	               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	                 { return doHandleBinding(cm, b) }
	             })
	    } else {
	      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
	    }
	  }

	  // Handle a key from the keypress event
	  function handleCharBinding(cm, e, ch) {
	    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
	  }

	  var lastStoppedKey = null;
	  function onKeyDown(e) {
	    var cm = this;
	    if (e.target && e.target != cm.display.input.getField()) { return }
	    cm.curOp.focus = activeElt();
	    if (signalDOMEvent(cm, e)) { return }
	    // IE does strange things with escape.
	    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
	    var code = e.keyCode;
	    cm.display.shift = code == 16 || e.shiftKey;
	    var handled = handleKeyBinding(cm, e);
	    if (presto) {
	      lastStoppedKey = handled ? code : null;
	      // Opera has no cut event... we try to at least catch the key combo
	      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	        { cm.replaceSelection("", null, "cut"); }
	    }
	    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
	      { document.execCommand("cut"); }

	    // Turn mouse into crosshair when Alt is held on Mac.
	    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	      { showCrossHair(cm); }
	  }

	  function showCrossHair(cm) {
	    var lineDiv = cm.display.lineDiv;
	    addClass(lineDiv, "CodeMirror-crosshair");

	    function up(e) {
	      if (e.keyCode == 18 || !e.altKey) {
	        rmClass(lineDiv, "CodeMirror-crosshair");
	        off(document, "keyup", up);
	        off(document, "mouseover", up);
	      }
	    }
	    on(document, "keyup", up);
	    on(document, "mouseover", up);
	  }

	  function onKeyUp(e) {
	    if (e.keyCode == 16) { this.doc.sel.shift = false; }
	    signalDOMEvent(this, e);
	  }

	  function onKeyPress(e) {
	    var cm = this;
	    if (e.target && e.target != cm.display.input.getField()) { return }
	    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
	    var keyCode = e.keyCode, charCode = e.charCode;
	    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
	    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
	    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	    // Some browsers fire keypress events for backspace
	    if (ch == "\x08") { return }
	    if (handleCharBinding(cm, e, ch)) { return }
	    cm.display.input.onKeyPress(e);
	  }

	  var DOUBLECLICK_DELAY = 400;

	  var PastClick = function(time, pos, button) {
	    this.time = time;
	    this.pos = pos;
	    this.button = button;
	  };

	  PastClick.prototype.compare = function (time, pos, button) {
	    return this.time + DOUBLECLICK_DELAY > time &&
	      cmp(pos, this.pos) == 0 && button == this.button
	  };

	  var lastClick, lastDoubleClick;
	  function clickRepeat(pos, button) {
	    var now = +new Date;
	    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
	      lastClick = lastDoubleClick = null;
	      return "triple"
	    } else if (lastClick && lastClick.compare(now, pos, button)) {
	      lastDoubleClick = new PastClick(now, pos, button);
	      lastClick = null;
	      return "double"
	    } else {
	      lastClick = new PastClick(now, pos, button);
	      lastDoubleClick = null;
	      return "single"
	    }
	  }

	  // A mouse down can be a single click, double click, triple click,
	  // start of selection drag, start of text drag, new cursor
	  // (ctrl-click), rectangle drag (alt-drag), or xwin
	  // middle-click-paste. Or it might be a click on something we should
	  // not interfere with, such as a scrollbar or widget.
	  function onMouseDown(e) {
	    var cm = this, display = cm.display;
	    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
	    display.input.ensurePolled();
	    display.shift = e.shiftKey;

	    if (eventInWidget(display, e)) {
	      if (!webkit) {
	        // Briefly turn off draggability, to allow widgets to do
	        // normal dragging things.
	        display.scroller.draggable = false;
	        setTimeout(function () { return display.scroller.draggable = true; }, 100);
	      }
	      return
	    }
	    if (clickInGutter(cm, e)) { return }
	    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
	    window.focus();

	    // #3261: make sure, that we're not starting a second selection
	    if (button == 1 && cm.state.selectingText)
	      { cm.state.selectingText(e); }

	    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

	    if (button == 1) {
	      if (pos) { leftButtonDown(cm, pos, repeat, e); }
	      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
	    } else if (button == 2) {
	      if (pos) { extendSelection(cm.doc, pos); }
	      setTimeout(function () { return display.input.focus(); }, 20);
	    } else if (button == 3) {
	      if (captureRightClick) { cm.display.input.onContextMenu(e); }
	      else { delayBlurEvent(cm); }
	    }
	  }

	  function handleMappedButton(cm, button, pos, repeat, event) {
	    var name = "Click";
	    if (repeat == "double") { name = "Double" + name; }
	    else if (repeat == "triple") { name = "Triple" + name; }
	    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

	    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
	      if (typeof bound == "string") { bound = commands[bound]; }
	      if (!bound) { return false }
	      var done = false;
	      try {
	        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	        done = bound(cm, pos) != Pass;
	      } finally {
	        cm.state.suppressEdits = false;
	      }
	      return done
	    })
	  }

	  function configureMouse(cm, repeat, event) {
	    var option = cm.getOption("configureMouse");
	    var value = option ? option(cm, repeat, event) : {};
	    if (value.unit == null) {
	      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
	      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
	    }
	    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
	    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
	    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
	    return value
	  }

	  function leftButtonDown(cm, pos, repeat, event) {
	    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
	    else { cm.curOp.focus = activeElt(); }

	    var behavior = configureMouse(cm, repeat, event);

	    var sel = cm.doc.sel, contained;
	    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
	        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
	        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
	      { leftButtonStartDrag(cm, event, pos, behavior); }
	    else
	      { leftButtonSelect(cm, event, pos, behavior); }
	  }

	  // Start a text drag. When it ends, see if any dragging actually
	  // happen, and treat as a click if it didn't.
	  function leftButtonStartDrag(cm, event, pos, behavior) {
	    var display = cm.display, moved = false;
	    var dragEnd = operation(cm, function (e) {
	      if (webkit) { display.scroller.draggable = false; }
	      cm.state.draggingText = false;
	      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
	      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
	      off(display.scroller, "dragstart", dragStart);
	      off(display.scroller, "drop", dragEnd);
	      if (!moved) {
	        e_preventDefault(e);
	        if (!behavior.addNew)
	          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
	        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	        if ((webkit && !safari) || ie && ie_version == 9)
	          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }
	        else
	          { display.input.focus(); }
	      }
	    });
	    var mouseMove = function(e2) {
	      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
	    };
	    var dragStart = function () { return moved = true; };
	    // Let the drag handler handle this.
	    if (webkit) { display.scroller.draggable = true; }
	    cm.state.draggingText = dragEnd;
	    dragEnd.copy = !behavior.moveOnDrag;
	    // IE's approach to draggable
	    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
	    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
	    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
	    on(display.scroller, "dragstart", dragStart);
	    on(display.scroller, "drop", dragEnd);

	    delayBlurEvent(cm);
	    setTimeout(function () { return display.input.focus(); }, 20);
	  }

	  function rangeForUnit(cm, pos, unit) {
	    if (unit == "char") { return new Range(pos, pos) }
	    if (unit == "word") { return cm.findWordAt(pos) }
	    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
	    var result = unit(cm, pos);
	    return new Range(result.from, result.to)
	  }

	  // Normal selection, as opposed to text dragging.
	  function leftButtonSelect(cm, event, start, behavior) {
	    var display = cm.display, doc = cm.doc;
	    e_preventDefault(event);

	    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	    if (behavior.addNew && !behavior.extend) {
	      ourIndex = doc.sel.contains(start);
	      if (ourIndex > -1)
	        { ourRange = ranges[ourIndex]; }
	      else
	        { ourRange = new Range(start, start); }
	    } else {
	      ourRange = doc.sel.primary();
	      ourIndex = doc.sel.primIndex;
	    }

	    if (behavior.unit == "rectangle") {
	      if (!behavior.addNew) { ourRange = new Range(start, start); }
	      start = posFromMouse(cm, event, true, true);
	      ourIndex = -1;
	    } else {
	      var range = rangeForUnit(cm, start, behavior.unit);
	      if (behavior.extend)
	        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
	      else
	        { ourRange = range; }
	    }

	    if (!behavior.addNew) {
	      ourIndex = 0;
	      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	      startSel = doc.sel;
	    } else if (ourIndex == -1) {
	      ourIndex = ranges.length;
	      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
	                   {scroll: false, origin: "*mouse"});
	    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
	      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                   {scroll: false, origin: "*mouse"});
	      startSel = doc.sel;
	    } else {
	      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	    }

	    var lastPos = start;
	    function extendTo(pos) {
	      if (cmp(lastPos, pos) == 0) { return }
	      lastPos = pos;

	      if (behavior.unit == "rectangle") {
	        var ranges = [], tabSize = cm.options.tabSize;
	        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	             line <= end; line++) {
	          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	          if (left == right)
	            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
	          else if (text.length > leftPos)
	            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
	        }
	        if (!ranges.length) { ranges.push(new Range(start, start)); }
	        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                     {origin: "*mouse", scroll: false});
	        cm.scrollIntoView(pos);
	      } else {
	        var oldRange = ourRange;
	        var range = rangeForUnit(cm, pos, behavior.unit);
	        var anchor = oldRange.anchor, head;
	        if (cmp(range.anchor, anchor) > 0) {
	          head = range.head;
	          anchor = minPos(oldRange.from(), range.anchor);
	        } else {
	          head = range.anchor;
	          anchor = maxPos(oldRange.to(), range.head);
	        }
	        var ranges$1 = startSel.ranges.slice(0);
	        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
	        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
	      }
	    }

	    var editorSize = display.wrapper.getBoundingClientRect();
	    // Used to ensure timeout re-tries don't fire when another extend
	    // happened in the meantime (clearTimeout isn't reliable -- at
	    // least on Chrome, the timeouts still happen even when cleared,
	    // if the clear happens after their scheduled firing time).
	    var counter = 0;

	    function extend(e) {
	      var curCount = ++counter;
	      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
	      if (!cur) { return }
	      if (cmp(cur, lastPos) != 0) {
	        cm.curOp.focus = activeElt();
	        extendTo(cur);
	        var visible = visibleLines(display, doc);
	        if (cur.line >= visible.to || cur.line < visible.from)
	          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
	      } else {
	        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	        if (outside) { setTimeout(operation(cm, function () {
	          if (counter != curCount) { return }
	          display.scroller.scrollTop += outside;
	          extend(e);
	        }), 50); }
	      }
	    }

	    function done(e) {
	      cm.state.selectingText = false;
	      counter = Infinity;
	      // If e is null or undefined we interpret this as someone trying
	      // to explicitly cancel the selection rather than the user
	      // letting go of the mouse button.
	      if (e) {
	        e_preventDefault(e);
	        display.input.focus();
	      }
	      off(display.wrapper.ownerDocument, "mousemove", move);
	      off(display.wrapper.ownerDocument, "mouseup", up);
	      doc.history.lastSelOrigin = null;
	    }

	    var move = operation(cm, function (e) {
	      if (e.buttons === 0 || !e_button(e)) { done(e); }
	      else { extend(e); }
	    });
	    var up = operation(cm, done);
	    cm.state.selectingText = up;
	    on(display.wrapper.ownerDocument, "mousemove", move);
	    on(display.wrapper.ownerDocument, "mouseup", up);
	  }

	  // Used when mouse-selecting to adjust the anchor to the proper side
	  // of a bidi jump depending on the visual position of the head.
	  function bidiSimplify(cm, range) {
	    var anchor = range.anchor;
	    var head = range.head;
	    var anchorLine = getLine(cm.doc, anchor.line);
	    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
	    var order = getOrder(anchorLine);
	    if (!order) { return range }
	    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
	    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
	    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
	    if (boundary == 0 || boundary == order.length) { return range }

	    // Compute the relative visual position of the head compared to the
	    // anchor (<0 is to the left, >0 to the right)
	    var leftSide;
	    if (head.line != anchor.line) {
	      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
	    } else {
	      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
	      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
	      if (headIndex == boundary - 1 || headIndex == boundary)
	        { leftSide = dir < 0; }
	      else
	        { leftSide = dir > 0; }
	    }

	    var usePart = order[boundary + (leftSide ? -1 : 0)];
	    var from = leftSide == (usePart.level == 1);
	    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
	    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
	  }


	  // Determines whether an event happened in the gutter, and fires the
	  // handlers for the corresponding event.
	  function gutterEvent(cm, e, type, prevent) {
	    var mX, mY;
	    if (e.touches) {
	      mX = e.touches[0].clientX;
	      mY = e.touches[0].clientY;
	    } else {
	      try { mX = e.clientX; mY = e.clientY; }
	      catch(e$1) { return false }
	    }
	    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
	    if (prevent) { e_preventDefault(e); }

	    var display = cm.display;
	    var lineBox = display.lineDiv.getBoundingClientRect();

	    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
	    mY -= lineBox.top - display.viewOffset;

	    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
	      var g = display.gutters.childNodes[i];
	      if (g && g.getBoundingClientRect().right >= mX) {
	        var line = lineAtHeight(cm.doc, mY);
	        var gutter = cm.display.gutterSpecs[i];
	        signal(cm, type, cm, line, gutter.className, e);
	        return e_defaultPrevented(e)
	      }
	    }
	  }

	  function clickInGutter(cm, e) {
	    return gutterEvent(cm, e, "gutterClick", true)
	  }

	  // CONTEXT MENU HANDLING

	  // To make the context menu work, we need to briefly unhide the
	  // textarea (making it as unobtrusive as possible) to let the
	  // right-click take effect on it.
	  function onContextMenu(cm, e) {
	    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
	    if (signalDOMEvent(cm, e, "contextmenu")) { return }
	    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
	  }

	  function contextMenuInGutter(cm, e) {
	    if (!hasHandler(cm, "gutterContextMenu")) { return false }
	    return gutterEvent(cm, e, "gutterContextMenu", false)
	  }

	  function themeChanged(cm) {
	    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	    clearCaches(cm);
	  }

	  var Init = {toString: function(){return "CodeMirror.Init"}};

	  var defaults = {};
	  var optionHandlers = {};

	  function defineOptions(CodeMirror) {
	    var optionHandlers = CodeMirror.optionHandlers;

	    function option(name, deflt, handle, notOnInit) {
	      CodeMirror.defaults[name] = deflt;
	      if (handle) { optionHandlers[name] =
	        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
	    }

	    CodeMirror.defineOption = option;

	    // Passed to option handlers when there is no old value.
	    CodeMirror.Init = Init;

	    // These two are, on init, called from the constructor because they
	    // have to be initialized before the editor can start at all.
	    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
	    option("mode", null, function (cm, val) {
	      cm.doc.modeOption = val;
	      loadMode(cm);
	    }, true);

	    option("indentUnit", 2, loadMode, true);
	    option("indentWithTabs", false);
	    option("smartIndent", true);
	    option("tabSize", 4, function (cm) {
	      resetModeState(cm);
	      clearCaches(cm);
	      regChange(cm);
	    }, true);

	    option("lineSeparator", null, function (cm, val) {
	      cm.doc.lineSep = val;
	      if (!val) { return }
	      var newBreaks = [], lineNo = cm.doc.first;
	      cm.doc.iter(function (line) {
	        for (var pos = 0;;) {
	          var found = line.text.indexOf(val, pos);
	          if (found == -1) { break }
	          pos = found + val.length;
	          newBreaks.push(Pos(lineNo, found));
	        }
	        lineNo++;
	      });
	      for (var i = newBreaks.length - 1; i >= 0; i--)
	        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
	    });
	    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
	      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	      if (old != Init) { cm.refresh(); }
	    });
	    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
	    option("electricChars", true);
	    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
	      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
	    }, true);
	    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
	    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
	    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
	    option("rtlMoveVisually", !windows);
	    option("wholeLineUpdateBefore", true);

	    option("theme", "default", function (cm) {
	      themeChanged(cm);
	      updateGutters(cm);
	    }, true);
	    option("keyMap", "default", function (cm, val, old) {
	      var next = getKeyMap(val);
	      var prev = old != Init && getKeyMap(old);
	      if (prev && prev.detach) { prev.detach(cm, next); }
	      if (next.attach) { next.attach(cm, prev || null); }
	    });
	    option("extraKeys", null);
	    option("configureMouse", null);

	    option("lineWrapping", false, wrappingChanged, true);
	    option("gutters", [], function (cm, val) {
	      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
	      updateGutters(cm);
	    }, true);
	    option("fixedGutter", true, function (cm, val) {
	      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	      cm.refresh();
	    }, true);
	    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
	    option("scrollbarStyle", "native", function (cm) {
	      initScrollbars(cm);
	      updateScrollbars(cm);
	      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	    }, true);
	    option("lineNumbers", false, function (cm, val) {
	      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
	      updateGutters(cm);
	    }, true);
	    option("firstLineNumber", 1, updateGutters, true);
	    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
	    option("showCursorWhenSelecting", false, updateSelection, true);

	    option("resetSelectionOnContextMenu", true);
	    option("lineWiseCopyCut", true);
	    option("pasteLinesPerSelection", true);
	    option("selectionsMayTouch", false);

	    option("readOnly", false, function (cm, val) {
	      if (val == "nocursor") {
	        onBlur(cm);
	        cm.display.input.blur();
	      }
	      cm.display.input.readOnlyChanged(val);
	    });

	    option("screenReaderLabel", null, function (cm, val) {
	      val = (val === '') ? null : val;
	      cm.display.input.screenReaderLabelChanged(val);
	    });

	    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
	    option("dragDrop", true, dragDropChanged);
	    option("allowDropFileTypes", null);

	    option("cursorBlinkRate", 530);
	    option("cursorScrollMargin", 0);
	    option("cursorHeight", 1, updateSelection, true);
	    option("singleCursorHeightPerLine", true, updateSelection, true);
	    option("workTime", 100);
	    option("workDelay", 100);
	    option("flattenSpans", true, resetModeState, true);
	    option("addModeClass", false, resetModeState, true);
	    option("pollInterval", 100);
	    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
	    option("historyEventDelay", 1250);
	    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
	    option("maxHighlightLength", 10000, resetModeState, true);
	    option("moveInputWithCursor", true, function (cm, val) {
	      if (!val) { cm.display.input.resetPosition(); }
	    });

	    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
	    option("autofocus", null);
	    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
	    option("phrases", null);
	  }

	  function dragDropChanged(cm, value, old) {
	    var wasOn = old && old != Init;
	    if (!value != !wasOn) {
	      var funcs = cm.display.dragFunctions;
	      var toggle = value ? on : off;
	      toggle(cm.display.scroller, "dragstart", funcs.start);
	      toggle(cm.display.scroller, "dragenter", funcs.enter);
	      toggle(cm.display.scroller, "dragover", funcs.over);
	      toggle(cm.display.scroller, "dragleave", funcs.leave);
	      toggle(cm.display.scroller, "drop", funcs.drop);
	    }
	  }

	  function wrappingChanged(cm) {
	    if (cm.options.lineWrapping) {
	      addClass(cm.display.wrapper, "CodeMirror-wrap");
	      cm.display.sizer.style.minWidth = "";
	      cm.display.sizerWidth = null;
	    } else {
	      rmClass(cm.display.wrapper, "CodeMirror-wrap");
	      findMaxLine(cm);
	    }
	    estimateLineHeights(cm);
	    regChange(cm);
	    clearCaches(cm);
	    setTimeout(function () { return updateScrollbars(cm); }, 100);
	  }

	  // A CodeMirror instance represents an editor. This is the object
	  // that user code is usually dealing with.

	  function CodeMirror(place, options) {
	    var this$1 = this;

	    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

	    this.options = options = options ? copyObj(options) : {};
	    // Determine effective options based on given values and defaults.
	    copyObj(defaults, options, false);

	    var doc = options.value;
	    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
	    else if (options.mode) { doc.modeOption = options.mode; }
	    this.doc = doc;

	    var input = new CodeMirror.inputStyles[options.inputStyle](this);
	    var display = this.display = new Display(place, doc, input, options);
	    display.wrapper.CodeMirror = this;
	    themeChanged(this);
	    if (options.lineWrapping)
	      { this.display.wrapper.className += " CodeMirror-wrap"; }
	    initScrollbars(this);

	    this.state = {
	      keyMaps: [],  // stores maps added by addKeyMap
	      overlays: [], // highlighting overlays, as added by addOverlay
	      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	      overwrite: false,
	      delayingBlurEvent: false,
	      focused: false,
	      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
	      selectingText: false,
	      draggingText: false,
	      highlight: new Delayed(), // stores highlight worker timeout
	      keySeq: null,  // Unfinished key sequence
	      specialChars: null
	    };

	    if (options.autofocus && !mobile) { display.input.focus(); }

	    // Override magic textarea content restore that IE sometimes does
	    // on our hidden textarea on reload
	    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

	    registerEventHandlers(this);
	    ensureGlobalHandlers();

	    startOperation(this);
	    this.curOp.forceUpdate = true;
	    attachDoc(this, doc);

	    if ((options.autofocus && !mobile) || this.hasFocus())
	      { setTimeout(bind(onFocus, this), 20); }
	    else
	      { onBlur(this); }

	    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
	      { optionHandlers[opt](this, options[opt], Init); } }
	    maybeUpdateLineNumberWidth(this);
	    if (options.finishInit) { options.finishInit(this); }
	    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
	    endOperation(this);
	    // Suppress optimizelegibility in Webkit, since it breaks text
	    // measuring on line wrapping boundaries.
	    if (webkit && options.lineWrapping &&
	        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	      { display.lineDiv.style.textRendering = "auto"; }
	  }

	  // The default configuration options.
	  CodeMirror.defaults = defaults;
	  // Functions to run when options are changed.
	  CodeMirror.optionHandlers = optionHandlers;

	  // Attach the necessary event handlers when initializing the editor
	  function registerEventHandlers(cm) {
	    var d = cm.display;
	    on(d.scroller, "mousedown", operation(cm, onMouseDown));
	    // Older IE's will not fire a second mousedown for a double click
	    if (ie && ie_version < 11)
	      { on(d.scroller, "dblclick", operation(cm, function (e) {
	        if (signalDOMEvent(cm, e)) { return }
	        var pos = posFromMouse(cm, e);
	        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
	        e_preventDefault(e);
	        var word = cm.findWordAt(pos);
	        extendSelection(cm.doc, word.anchor, word.head);
	      })); }
	    else
	      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
	    // Some browsers fire contextmenu *after* opening the menu, at
	    // which point we can't mess with it anymore. Context menu is
	    // handled in onMouseDown for these browsers.
	    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
	    on(d.input.getField(), "contextmenu", function (e) {
	      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
	    });

	    // Used to suppress mouse event handling when a touch happens
	    var touchFinished, prevTouch = {end: 0};
	    function finishTouch() {
	      if (d.activeTouch) {
	        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
	        prevTouch = d.activeTouch;
	        prevTouch.end = +new Date;
	      }
	    }
	    function isMouseLikeTouchEvent(e) {
	      if (e.touches.length != 1) { return false }
	      var touch = e.touches[0];
	      return touch.radiusX <= 1 && touch.radiusY <= 1
	    }
	    function farAway(touch, other) {
	      if (other.left == null) { return true }
	      var dx = other.left - touch.left, dy = other.top - touch.top;
	      return dx * dx + dy * dy > 20 * 20
	    }
	    on(d.scroller, "touchstart", function (e) {
	      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
	        d.input.ensurePolled();
	        clearTimeout(touchFinished);
	        var now = +new Date;
	        d.activeTouch = {start: now, moved: false,
	                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
	        if (e.touches.length == 1) {
	          d.activeTouch.left = e.touches[0].pageX;
	          d.activeTouch.top = e.touches[0].pageY;
	        }
	      }
	    });
	    on(d.scroller, "touchmove", function () {
	      if (d.activeTouch) { d.activeTouch.moved = true; }
	    });
	    on(d.scroller, "touchend", function (e) {
	      var touch = d.activeTouch;
	      if (touch && !eventInWidget(d, e) && touch.left != null &&
	          !touch.moved && new Date - touch.start < 300) {
	        var pos = cm.coordsChar(d.activeTouch, "page"), range;
	        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	          { range = new Range(pos, pos); }
	        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	          { range = cm.findWordAt(pos); }
	        else // Triple tap
	          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
	        cm.setSelection(range.anchor, range.head);
	        cm.focus();
	        e_preventDefault(e);
	      }
	      finishTouch();
	    });
	    on(d.scroller, "touchcancel", finishTouch);

	    // Sync scrolling between fake scrollbars and real scrollable
	    // area, ensure viewport is updated when scrolling.
	    on(d.scroller, "scroll", function () {
	      if (d.scroller.clientHeight) {
	        updateScrollTop(cm, d.scroller.scrollTop);
	        setScrollLeft(cm, d.scroller.scrollLeft, true);
	        signal(cm, "scroll", cm);
	      }
	    });

	    // Listen to wheel events in order to try and update the viewport on time.
	    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
	    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

	    // Prevent wrapper from ever scrolling
	    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

	    d.dragFunctions = {
	      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
	      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
	      start: function (e) { return onDragStart(cm, e); },
	      drop: operation(cm, onDrop),
	      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
	    };

	    var inp = d.input.getField();
	    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
	    on(inp, "keydown", operation(cm, onKeyDown));
	    on(inp, "keypress", operation(cm, onKeyPress));
	    on(inp, "focus", function (e) { return onFocus(cm, e); });
	    on(inp, "blur", function (e) { return onBlur(cm, e); });
	  }

	  var initHooks = [];
	  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

	  // Indent the given line. The how parameter can be "smart",
	  // "add"/null, "subtract", or "prev". When aggressive is false
	  // (typically set to true for forced single-line indents), empty
	  // lines are not indented, and places where the mode returns Pass
	  // are left alone.
	  function indentLine(cm, n, how, aggressive) {
	    var doc = cm.doc, state;
	    if (how == null) { how = "add"; }
	    if (how == "smart") {
	      // Fall back to "prev" when the mode doesn't have an indentation
	      // method.
	      if (!doc.mode.indent) { how = "prev"; }
	      else { state = getContextBefore(cm, n).state; }
	    }

	    var tabSize = cm.options.tabSize;
	    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	    if (line.stateAfter) { line.stateAfter = null; }
	    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	    if (!aggressive && !/\S/.test(line.text)) {
	      indentation = 0;
	      how = "not";
	    } else if (how == "smart") {
	      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	      if (indentation == Pass || indentation > 150) {
	        if (!aggressive) { return }
	        how = "prev";
	      }
	    }
	    if (how == "prev") {
	      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
	      else { indentation = 0; }
	    } else if (how == "add") {
	      indentation = curSpace + cm.options.indentUnit;
	    } else if (how == "subtract") {
	      indentation = curSpace - cm.options.indentUnit;
	    } else if (typeof how == "number") {
	      indentation = curSpace + how;
	    }
	    indentation = Math.max(0, indentation);

	    var indentString = "", pos = 0;
	    if (cm.options.indentWithTabs)
	      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
	    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

	    if (indentString != curSpaceString) {
	      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	      line.stateAfter = null;
	      return true
	    } else {
	      // Ensure that, if the cursor was in the whitespace at the start
	      // of the line, it is moved to the end of that space.
	      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
	        var range = doc.sel.ranges[i$1];
	        if (range.head.line == n && range.head.ch < curSpaceString.length) {
	          var pos$1 = Pos(n, curSpaceString.length);
	          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
	          break
	        }
	      }
	    }
	  }

	  // This will be set to a {lineWise: bool, text: [string]} object, so
	  // that, when pasting, we know what kind of selections the copied
	  // text was made out of.
	  var lastCopied = null;

	  function setLastCopied(newLastCopied) {
	    lastCopied = newLastCopied;
	  }

	  function applyTextInput(cm, inserted, deleted, sel, origin) {
	    var doc = cm.doc;
	    cm.display.shift = false;
	    if (!sel) { sel = doc.sel; }

	    var recent = +new Date - 200;
	    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
	    var textLines = splitLinesAuto(inserted), multiPaste = null;
	    // When pasting N lines into N selections, insert one line per selection
	    if (paste && sel.ranges.length > 1) {
	      if (lastCopied && lastCopied.text.join("\n") == inserted) {
	        if (sel.ranges.length % lastCopied.text.length == 0) {
	          multiPaste = [];
	          for (var i = 0; i < lastCopied.text.length; i++)
	            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
	        }
	      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
	        multiPaste = map(textLines, function (l) { return [l]; });
	      }
	    }

	    var updateInput = cm.curOp.updateInput;
	    // Normal behavior is to insert the new text into every selection
	    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
	      var range = sel.ranges[i$1];
	      var from = range.from(), to = range.to();
	      if (range.empty()) {
	        if (deleted && deleted > 0) // Handle deletion
	          { from = Pos(from.line, from.ch - deleted); }
	        else if (cm.state.overwrite && !paste) // Handle overwrite
	          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
	        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
	          { from = to = Pos(from.line, 0); }
	      }
	      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
	                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
	      makeChange(cm.doc, changeEvent);
	      signalLater(cm, "inputRead", cm, changeEvent);
	    }
	    if (inserted && !paste)
	      { triggerElectric(cm, inserted); }

	    ensureCursorVisible(cm);
	    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
	    cm.curOp.typing = true;
	    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
	  }

	  function handlePaste(e, cm) {
	    var pasted = e.clipboardData && e.clipboardData.getData("Text");
	    if (pasted) {
	      e.preventDefault();
	      if (!cm.isReadOnly() && !cm.options.disableInput)
	        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
	      return true
	    }
	  }

	  function triggerElectric(cm, inserted) {
	    // When an 'electric' character is inserted, immediately trigger a reindent
	    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
	    var sel = cm.doc.sel;

	    for (var i = sel.ranges.length - 1; i >= 0; i--) {
	      var range = sel.ranges[i];
	      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
	      var mode = cm.getModeAt(range.head);
	      var indented = false;
	      if (mode.electricChars) {
	        for (var j = 0; j < mode.electricChars.length; j++)
	          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	            indented = indentLine(cm, range.head.line, "smart");
	            break
	          } }
	      } else if (mode.electricInput) {
	        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
	          { indented = indentLine(cm, range.head.line, "smart"); }
	      }
	      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
	    }
	  }

	  function copyableRanges(cm) {
	    var text = [], ranges = [];
	    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	      var line = cm.doc.sel.ranges[i].head.line;
	      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	      ranges.push(lineRange);
	      text.push(cm.getRange(lineRange.anchor, lineRange.head));
	    }
	    return {text: text, ranges: ranges}
	  }

	  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
	    field.setAttribute("autocorrect", autocorrect ? "" : "off");
	    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
	    field.setAttribute("spellcheck", !!spellcheck);
	  }

	  function hiddenTextarea() {
	    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	    // The textarea is kept positioned near the cursor to prevent the
	    // fact that it'll be scrolled into view on input from scrolling
	    // our fake cursor out of view. On webkit, when wrap=off, paste is
	    // very slow. So make the area wide instead.
	    if (webkit) { te.style.width = "1000px"; }
	    else { te.setAttribute("wrap", "off"); }
	    // If border: 0; -- iOS fails to open keyboard (issue #1287)
	    if (ios) { te.style.border = "1px solid black"; }
	    disableBrowserMagic(te);
	    return div
	  }

	  // The publicly visible API. Note that methodOp(f) means
	  // 'wrap f in an operation, performed on its `this` parameter'.

	  // This is not the complete set of editor methods. Most of the
	  // methods defined on the Doc type are also injected into
	  // CodeMirror.prototype, for backwards compatibility and
	  // convenience.

	  function addEditorMethods(CodeMirror) {
	    var optionHandlers = CodeMirror.optionHandlers;

	    var helpers = CodeMirror.helpers = {};

	    CodeMirror.prototype = {
	      constructor: CodeMirror,
	      focus: function(){window.focus(); this.display.input.focus();},

	      setOption: function(option, value) {
	        var options = this.options, old = options[option];
	        if (options[option] == value && option != "mode") { return }
	        options[option] = value;
	        if (optionHandlers.hasOwnProperty(option))
	          { operation(this, optionHandlers[option])(this, value, old); }
	        signal(this, "optionChange", this, option);
	      },

	      getOption: function(option) {return this.options[option]},
	      getDoc: function() {return this.doc},

	      addKeyMap: function(map, bottom) {
	        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
	      },
	      removeKeyMap: function(map) {
	        var maps = this.state.keyMaps;
	        for (var i = 0; i < maps.length; ++i)
	          { if (maps[i] == map || maps[i].name == map) {
	            maps.splice(i, 1);
	            return true
	          } }
	      },

	      addOverlay: methodOp(function(spec, options) {
	        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
	        insertSorted(this.state.overlays,
	                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
	                      priority: (options && options.priority) || 0},
	                     function (overlay) { return overlay.priority; });
	        this.state.modeGen++;
	        regChange(this);
	      }),
	      removeOverlay: methodOp(function(spec) {
	        var overlays = this.state.overlays;
	        for (var i = 0; i < overlays.length; ++i) {
	          var cur = overlays[i].modeSpec;
	          if (cur == spec || typeof spec == "string" && cur.name == spec) {
	            overlays.splice(i, 1);
	            this.state.modeGen++;
	            regChange(this);
	            return
	          }
	        }
	      }),

	      indentLine: methodOp(function(n, dir, aggressive) {
	        if (typeof dir != "string" && typeof dir != "number") {
	          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
	          else { dir = dir ? "add" : "subtract"; }
	        }
	        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
	      }),
	      indentSelection: methodOp(function(how) {
	        var ranges = this.doc.sel.ranges, end = -1;
	        for (var i = 0; i < ranges.length; i++) {
	          var range = ranges[i];
	          if (!range.empty()) {
	            var from = range.from(), to = range.to();
	            var start = Math.max(end, from.line);
	            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	            for (var j = start; j < end; ++j)
	              { indentLine(this, j, how); }
	            var newRanges = this.doc.sel.ranges;
	            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
	          } else if (range.head.line > end) {
	            indentLine(this, range.head.line, how, true);
	            end = range.head.line;
	            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
	          }
	        }
	      }),

	      // Fetch the parser token for a given character. Useful for hacks
	      // that want to inspect the mode state (say, for completion).
	      getTokenAt: function(pos, precise) {
	        return takeToken(this, pos, precise)
	      },

	      getLineTokens: function(line, precise) {
	        return takeToken(this, Pos(line), precise, true)
	      },

	      getTokenTypeAt: function(pos) {
	        pos = clipPos(this.doc, pos);
	        var styles = getLineStyles(this, getLine(this.doc, pos.line));
	        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	        var type;
	        if (ch == 0) { type = styles[2]; }
	        else { for (;;) {
	          var mid = (before + after) >> 1;
	          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
	          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
	          else { type = styles[mid * 2 + 2]; break }
	        } }
	        var cut = type ? type.indexOf("overlay ") : -1;
	        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
	      },

	      getModeAt: function(pos) {
	        var mode = this.doc.mode;
	        if (!mode.innerMode) { return mode }
	        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
	      },

	      getHelper: function(pos, type) {
	        return this.getHelpers(pos, type)[0]
	      },

	      getHelpers: function(pos, type) {
	        var found = [];
	        if (!helpers.hasOwnProperty(type)) { return found }
	        var help = helpers[type], mode = this.getModeAt(pos);
	        if (typeof mode[type] == "string") {
	          if (help[mode[type]]) { found.push(help[mode[type]]); }
	        } else if (mode[type]) {
	          for (var i = 0; i < mode[type].length; i++) {
	            var val = help[mode[type][i]];
	            if (val) { found.push(val); }
	          }
	        } else if (mode.helperType && help[mode.helperType]) {
	          found.push(help[mode.helperType]);
	        } else if (help[mode.name]) {
	          found.push(help[mode.name]);
	        }
	        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
	          var cur = help._global[i$1];
	          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
	            { found.push(cur.val); }
	        }
	        return found
	      },

	      getStateAfter: function(line, precise) {
	        var doc = this.doc;
	        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	        return getContextBefore(this, line + 1, precise).state
	      },

	      cursorCoords: function(start, mode) {
	        var pos, range = this.doc.sel.primary();
	        if (start == null) { pos = range.head; }
	        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
	        else { pos = start ? range.from() : range.to(); }
	        return cursorCoords(this, pos, mode || "page")
	      },

	      charCoords: function(pos, mode) {
	        return charCoords(this, clipPos(this.doc, pos), mode || "page")
	      },

	      coordsChar: function(coords, mode) {
	        coords = fromCoordSystem(this, coords, mode || "page");
	        return coordsChar(this, coords.left, coords.top)
	      },

	      lineAtHeight: function(height, mode) {
	        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	        return lineAtHeight(this.doc, height + this.display.viewOffset)
	      },
	      heightAtLine: function(line, mode, includeWidgets) {
	        var end = false, lineObj;
	        if (typeof line == "number") {
	          var last = this.doc.first + this.doc.size - 1;
	          if (line < this.doc.first) { line = this.doc.first; }
	          else if (line > last) { line = last; end = true; }
	          lineObj = getLine(this.doc, line);
	        } else {
	          lineObj = line;
	        }
	        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
	          (end ? this.doc.height - heightAtLine(lineObj) : 0)
	      },

	      defaultTextHeight: function() { return textHeight(this.display) },
	      defaultCharWidth: function() { return charWidth(this.display) },

	      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

	      addWidget: function(pos, node, scroll, vert, horiz) {
	        var display = this.display;
	        pos = cursorCoords(this, clipPos(this.doc, pos));
	        var top = pos.bottom, left = pos.left;
	        node.style.position = "absolute";
	        node.setAttribute("cm-ignore-events", "true");
	        this.display.input.setUneditable(node);
	        display.sizer.appendChild(node);
	        if (vert == "over") {
	          top = pos.top;
	        } else if (vert == "above" || vert == "near") {
	          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	          // Default to positioning above (if specified and possible); otherwise default to positioning below
	          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	            { top = pos.top - node.offsetHeight; }
	          else if (pos.bottom + node.offsetHeight <= vspace)
	            { top = pos.bottom; }
	          if (left + node.offsetWidth > hspace)
	            { left = hspace - node.offsetWidth; }
	        }
	        node.style.top = top + "px";
	        node.style.left = node.style.right = "";
	        if (horiz == "right") {
	          left = display.sizer.clientWidth - node.offsetWidth;
	          node.style.right = "0px";
	        } else {
	          if (horiz == "left") { left = 0; }
	          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
	          node.style.left = left + "px";
	        }
	        if (scroll)
	          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
	      },

	      triggerOnKeyDown: methodOp(onKeyDown),
	      triggerOnKeyPress: methodOp(onKeyPress),
	      triggerOnKeyUp: onKeyUp,
	      triggerOnMouseDown: methodOp(onMouseDown),

	      execCommand: function(cmd) {
	        if (commands.hasOwnProperty(cmd))
	          { return commands[cmd].call(null, this) }
	      },

	      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

	      findPosH: function(from, amount, unit, visually) {
	        var dir = 1;
	        if (amount < 0) { dir = -1; amount = -amount; }
	        var cur = clipPos(this.doc, from);
	        for (var i = 0; i < amount; ++i) {
	          cur = findPosH(this.doc, cur, dir, unit, visually);
	          if (cur.hitSide) { break }
	        }
	        return cur
	      },

	      moveH: methodOp(function(dir, unit) {
	        var this$1 = this;

	        this.extendSelectionsBy(function (range) {
	          if (this$1.display.shift || this$1.doc.extend || range.empty())
	            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
	          else
	            { return dir < 0 ? range.from() : range.to() }
	        }, sel_move);
	      }),

	      deleteH: methodOp(function(dir, unit) {
	        var sel = this.doc.sel, doc = this.doc;
	        if (sel.somethingSelected())
	          { doc.replaceSelection("", null, "+delete"); }
	        else
	          { deleteNearSelection(this, function (range) {
	            var other = findPosH(doc, range.head, dir, unit, false);
	            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
	          }); }
	      }),

	      findPosV: function(from, amount, unit, goalColumn) {
	        var dir = 1, x = goalColumn;
	        if (amount < 0) { dir = -1; amount = -amount; }
	        var cur = clipPos(this.doc, from);
	        for (var i = 0; i < amount; ++i) {
	          var coords = cursorCoords(this, cur, "div");
	          if (x == null) { x = coords.left; }
	          else { coords.left = x; }
	          cur = findPosV(this, coords, dir, unit);
	          if (cur.hitSide) { break }
	        }
	        return cur
	      },

	      moveV: methodOp(function(dir, unit) {
	        var this$1 = this;

	        var doc = this.doc, goals = [];
	        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
	        doc.extendSelectionsBy(function (range) {
	          if (collapse)
	            { return dir < 0 ? range.from() : range.to() }
	          var headPos = cursorCoords(this$1, range.head, "div");
	          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
	          goals.push(headPos.left);
	          var pos = findPosV(this$1, headPos, dir, unit);
	          if (unit == "page" && range == doc.sel.primary())
	            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
	          return pos
	        }, sel_move);
	        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
	          { doc.sel.ranges[i].goalColumn = goals[i]; } }
	      }),

	      // Find the word at the given position (as returned by coordsChar).
	      findWordAt: function(pos) {
	        var doc = this.doc, line = getLine(doc, pos.line).text;
	        var start = pos.ch, end = pos.ch;
	        if (line) {
	          var helper = this.getHelper(pos, "wordChars");
	          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
	          var startChar = line.charAt(start);
	          var check = isWordChar(startChar, helper)
	            ? function (ch) { return isWordChar(ch, helper); }
	            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
	            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
	          while (start > 0 && check(line.charAt(start - 1))) { --start; }
	          while (end < line.length && check(line.charAt(end))) { ++end; }
	        }
	        return new Range(Pos(pos.line, start), Pos(pos.line, end))
	      },

	      toggleOverwrite: function(value) {
	        if (value != null && value == this.state.overwrite) { return }
	        if (this.state.overwrite = !this.state.overwrite)
	          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
	        else
	          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

	        signal(this, "overwriteToggle", this, this.state.overwrite);
	      },
	      hasFocus: function() { return this.display.input.getField() == activeElt() },
	      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

	      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
	      getScrollInfo: function() {
	        var scroller = this.display.scroller;
	        return {left: scroller.scrollLeft, top: scroller.scrollTop,
	                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
	      },

	      scrollIntoView: methodOp(function(range, margin) {
	        if (range == null) {
	          range = {from: this.doc.sel.primary().head, to: null};
	          if (margin == null) { margin = this.options.cursorScrollMargin; }
	        } else if (typeof range == "number") {
	          range = {from: Pos(range, 0), to: null};
	        } else if (range.from == null) {
	          range = {from: range, to: null};
	        }
	        if (!range.to) { range.to = range.from; }
	        range.margin = margin || 0;

	        if (range.from.line != null) {
	          scrollToRange(this, range);
	        } else {
	          scrollToCoordsRange(this, range.from, range.to, range.margin);
	        }
	      }),

	      setSize: methodOp(function(width, height) {
	        var this$1 = this;

	        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
	        if (width != null) { this.display.wrapper.style.width = interpret(width); }
	        if (height != null) { this.display.wrapper.style.height = interpret(height); }
	        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
	        var lineNo = this.display.viewFrom;
	        this.doc.iter(lineNo, this.display.viewTo, function (line) {
	          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
	            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
	          ++lineNo;
	        });
	        this.curOp.forceUpdate = true;
	        signal(this, "refresh", this);
	      }),

	      operation: function(f){return runInOp(this, f)},
	      startOperation: function(){return startOperation(this)},
	      endOperation: function(){return endOperation(this)},

	      refresh: methodOp(function() {
	        var oldHeight = this.display.cachedTextHeight;
	        regChange(this);
	        this.curOp.forceUpdate = true;
	        clearCaches(this);
	        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
	        updateGutterSpace(this.display);
	        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)
	          { estimateLineHeights(this); }
	        signal(this, "refresh", this);
	      }),

	      swapDoc: methodOp(function(doc) {
	        var old = this.doc;
	        old.cm = null;
	        // Cancel the current text selection if any (#5821)
	        if (this.state.selectingText) { this.state.selectingText(); }
	        attachDoc(this, doc);
	        clearCaches(this);
	        this.display.input.reset();
	        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
	        this.curOp.forceScroll = true;
	        signalLater(this, "swapDoc", this, old);
	        return old
	      }),

	      phrase: function(phraseText) {
	        var phrases = this.options.phrases;
	        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
	      },

	      getInputField: function(){return this.display.input.getField()},
	      getWrapperElement: function(){return this.display.wrapper},
	      getScrollerElement: function(){return this.display.scroller},
	      getGutterElement: function(){return this.display.gutters}
	    };
	    eventMixin(CodeMirror);

	    CodeMirror.registerHelper = function(type, name, value) {
	      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
	      helpers[type][name] = value;
	    };
	    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	      CodeMirror.registerHelper(type, name, value);
	      helpers[type]._global.push({pred: predicate, val: value});
	    };
	  }

	  // Used for horizontal relative motion. Dir is -1 or 1 (left or
	  // right), unit can be "char", "column" (like char, but doesn't
	  // cross line boundaries), "word" (across next word), or "group" (to
	  // the start of next group of word or non-word-non-whitespace
	  // chars). The visually param controls whether, in right-to-left
	  // text, direction 1 means to move towards the next index in the
	  // string, or towards the character to the right of the current
	  // position. The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosH(doc, pos, dir, unit, visually) {
	    var oldPos = pos;
	    var origDir = dir;
	    var lineObj = getLine(doc, pos.line);
	    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
	    function findNextLine() {
	      var l = pos.line + lineDir;
	      if (l < doc.first || l >= doc.first + doc.size) { return false }
	      pos = new Pos(l, pos.ch, pos.sticky);
	      return lineObj = getLine(doc, l)
	    }
	    function moveOnce(boundToLine) {
	      var next;
	      if (visually) {
	        next = moveVisually(doc.cm, lineObj, pos, dir);
	      } else {
	        next = moveLogically(lineObj, pos, dir);
	      }
	      if (next == null) {
	        if (!boundToLine && findNextLine())
	          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
	        else
	          { return false }
	      } else {
	        pos = next;
	      }
	      return true
	    }

	    if (unit == "char") {
	      moveOnce();
	    } else if (unit == "column") {
	      moveOnce(true);
	    } else if (unit == "word" || unit == "group") {
	      var sawType = null, group = unit == "group";
	      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	      for (var first = true;; first = false) {
	        if (dir < 0 && !moveOnce(!first)) { break }
	        var cur = lineObj.text.charAt(pos.ch) || "\n";
	        var type = isWordChar(cur, helper) ? "w"
	          : group && cur == "\n" ? "n"
	          : !group || /\s/.test(cur) ? null
	          : "p";
	        if (group && !first && !type) { type = "s"; }
	        if (sawType && sawType != type) {
	          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
	          break
	        }

	        if (type) { sawType = type; }
	        if (dir > 0 && !moveOnce(!first)) { break }
	      }
	    }
	    var result = skipAtomic(doc, pos, oldPos, origDir, true);
	    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
	    return result
	  }

	  // For relative vertical movement. Dir may be -1 or 1. Unit can be
	  // "page" or "line". The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosV(cm, pos, dir, unit) {
	    var doc = cm.doc, x = pos.left, y;
	    if (unit == "page") {
	      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
	      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

	    } else if (unit == "line") {
	      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	    }
	    var target;
	    for (;;) {
	      target = coordsChar(cm, x, y);
	      if (!target.outside) { break }
	      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
	      y += dir * 5;
	    }
	    return target
	  }

	  // CONTENTEDITABLE INPUT STYLE

	  var ContentEditableInput = function(cm) {
	    this.cm = cm;
	    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	    this.polling = new Delayed();
	    this.composing = null;
	    this.gracePeriod = false;
	    this.readDOMTimeout = null;
	  };

	  ContentEditableInput.prototype.init = function (display) {
	      var this$1 = this;

	    var input = this, cm = input.cm;
	    var div = input.div = display.lineDiv;
	    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

	    function belongsToInput(e) {
	      for (var t = e.target; t; t = t.parentNode) {
	        if (t == div) { return true }
	        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
	      }
	      return false
	    }

	    on(div, "paste", function (e) {
	      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
	      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
	    });

	    on(div, "compositionstart", function (e) {
	      this$1.composing = {data: e.data, done: false};
	    });
	    on(div, "compositionupdate", function (e) {
	      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
	    });
	    on(div, "compositionend", function (e) {
	      if (this$1.composing) {
	        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
	        this$1.composing.done = true;
	      }
	    });

	    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

	    on(div, "input", function () {
	      if (!this$1.composing) { this$1.readFromDOMSoon(); }
	    });

	    function onCopyCut(e) {
	      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
	      if (cm.somethingSelected()) {
	        setLastCopied({lineWise: false, text: cm.getSelections()});
	        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
	      } else if (!cm.options.lineWiseCopyCut) {
	        return
	      } else {
	        var ranges = copyableRanges(cm);
	        setLastCopied({lineWise: true, text: ranges.text});
	        if (e.type == "cut") {
	          cm.operation(function () {
	            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	            cm.replaceSelection("", null, "cut");
	          });
	        }
	      }
	      if (e.clipboardData) {
	        e.clipboardData.clearData();
	        var content = lastCopied.text.join("\n");
	        // iOS exposes the clipboard API, but seems to discard content inserted into it
	        e.clipboardData.setData("Text", content);
	        if (e.clipboardData.getData("Text") == content) {
	          e.preventDefault();
	          return
	        }
	      }
	      // Old-fashioned briefly-focus-a-textarea hack
	      var kludge = hiddenTextarea(), te = kludge.firstChild;
	      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	      te.value = lastCopied.text.join("\n");
	      var hadFocus = document.activeElement;
	      selectInput(te);
	      setTimeout(function () {
	        cm.display.lineSpace.removeChild(kludge);
	        hadFocus.focus();
	        if (hadFocus == div) { input.showPrimarySelection(); }
	      }, 50);
	    }
	    on(div, "copy", onCopyCut);
	    on(div, "cut", onCopyCut);
	  };

	  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
	    // Label for screenreaders, accessibility
	    if(label) {
	      this.div.setAttribute('aria-label', label);
	    } else {
	      this.div.removeAttribute('aria-label');
	    }
	  };

	  ContentEditableInput.prototype.prepareSelection = function () {
	    var result = prepareSelection(this.cm, false);
	    result.focus = document.activeElement == this.div;
	    return result
	  };

	  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
	    if (!info || !this.cm.display.view.length) { return }
	    if (info.focus || takeFocus) { this.showPrimarySelection(); }
	    this.showMultipleSelections(info);
	  };

	  ContentEditableInput.prototype.getSelection = function () {
	    return this.cm.display.wrapper.ownerDocument.getSelection()
	  };

	  ContentEditableInput.prototype.showPrimarySelection = function () {
	    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
	    var from = prim.from(), to = prim.to();

	    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
	      sel.removeAllRanges();
	      return
	    }

	    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
	    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	        cmp(minPos(curAnchor, curFocus), from) == 0 &&
	        cmp(maxPos(curAnchor, curFocus), to) == 0)
	      { return }

	    var view = cm.display.view;
	    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
	        {node: view[0].measure.map[2], offset: 0};
	    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
	    if (!end) {
	      var measure = view[view.length - 1].measure;
	      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
	    }

	    if (!start || !end) {
	      sel.removeAllRanges();
	      return
	    }

	    var old = sel.rangeCount && sel.getRangeAt(0), rng;
	    try { rng = range(start.node, start.offset, end.offset, end.node); }
	    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	    if (rng) {
	      if (!gecko && cm.state.focused) {
	        sel.collapse(start.node, start.offset);
	        if (!rng.collapsed) {
	          sel.removeAllRanges();
	          sel.addRange(rng);
	        }
	      } else {
	        sel.removeAllRanges();
	        sel.addRange(rng);
	      }
	      if (old && sel.anchorNode == null) { sel.addRange(old); }
	      else if (gecko) { this.startGracePeriod(); }
	    }
	    this.rememberSelection();
	  };

	  ContentEditableInput.prototype.startGracePeriod = function () {
	      var this$1 = this;

	    clearTimeout(this.gracePeriod);
	    this.gracePeriod = setTimeout(function () {
	      this$1.gracePeriod = false;
	      if (this$1.selectionChanged())
	        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
	    }, 20);
	  };

	  ContentEditableInput.prototype.showMultipleSelections = function (info) {
	    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	  };

	  ContentEditableInput.prototype.rememberSelection = function () {
	    var sel = this.getSelection();
	    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
	    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
	  };

	  ContentEditableInput.prototype.selectionInEditor = function () {
	    var sel = this.getSelection();
	    if (!sel.rangeCount) { return false }
	    var node = sel.getRangeAt(0).commonAncestorContainer;
	    return contains(this.div, node)
	  };

	  ContentEditableInput.prototype.focus = function () {
	    if (this.cm.options.readOnly != "nocursor") {
	      if (!this.selectionInEditor() || document.activeElement != this.div)
	        { this.showSelection(this.prepareSelection(), true); }
	      this.div.focus();
	    }
	  };
	  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
	  ContentEditableInput.prototype.getField = function () { return this.div };

	  ContentEditableInput.prototype.supportsTouch = function () { return true };

	  ContentEditableInput.prototype.receivedFocus = function () {
	    var input = this;
	    if (this.selectionInEditor())
	      { this.pollSelection(); }
	    else
	      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

	    function poll() {
	      if (input.cm.state.focused) {
	        input.pollSelection();
	        input.polling.set(input.cm.options.pollInterval, poll);
	      }
	    }
	    this.polling.set(this.cm.options.pollInterval, poll);
	  };

	  ContentEditableInput.prototype.selectionChanged = function () {
	    var sel = this.getSelection();
	    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
	  };

	  ContentEditableInput.prototype.pollSelection = function () {
	    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
	    var sel = this.getSelection(), cm = this.cm;
	    // On Android Chrome (version 56, at least), backspacing into an
	    // uneditable block element will put the cursor in that element,
	    // and then, because it's not editable, hide the virtual keyboard.
	    // Because Android doesn't allow us to actually detect backspace
	    // presses in a sane way, this code checks for when that happens
	    // and simulates a backspace press in this case.
	    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
	      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
	      this.blur();
	      this.focus();
	      return
	    }
	    if (this.composing) { return }
	    this.rememberSelection();
	    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
	    if (anchor && head) { runInOp(cm, function () {
	      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
	      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
	    }); }
	  };

	  ContentEditableInput.prototype.pollContent = function () {
	    if (this.readDOMTimeout != null) {
	      clearTimeout(this.readDOMTimeout);
	      this.readDOMTimeout = null;
	    }

	    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
	    var from = sel.from(), to = sel.to();
	    if (from.ch == 0 && from.line > cm.firstLine())
	      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
	    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
	      { to = Pos(to.line + 1, 0); }
	    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

	    var fromIndex, fromLine, fromNode;
	    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	      fromLine = lineNo(display.view[0].line);
	      fromNode = display.view[0].node;
	    } else {
	      fromLine = lineNo(display.view[fromIndex].line);
	      fromNode = display.view[fromIndex - 1].node.nextSibling;
	    }
	    var toIndex = findViewIndex(cm, to.line);
	    var toLine, toNode;
	    if (toIndex == display.view.length - 1) {
	      toLine = display.viewTo - 1;
	      toNode = display.lineDiv.lastChild;
	    } else {
	      toLine = lineNo(display.view[toIndex + 1].line) - 1;
	      toNode = display.view[toIndex + 1].node.previousSibling;
	    }

	    if (!fromNode) { return false }
	    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
	    while (newText.length > 1 && oldText.length > 1) {
	      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
	      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
	      else { break }
	    }

	    var cutFront = 0, cutEnd = 0;
	    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
	    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	      { ++cutFront; }
	    var newBot = lst(newText), oldBot = lst(oldText);
	    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
	    while (cutEnd < maxCutEnd &&
	           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	      { ++cutEnd; }
	    // Try to move start of change to start of selection if ambiguous
	    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
	      while (cutFront && cutFront > from.ch &&
	             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
	        cutFront--;
	        cutEnd++;
	      }
	    }

	    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
	    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

	    var chFrom = Pos(fromLine, cutFront);
	    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
	    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	      return true
	    }
	  };

	  ContentEditableInput.prototype.ensurePolled = function () {
	    this.forceCompositionEnd();
	  };
	  ContentEditableInput.prototype.reset = function () {
	    this.forceCompositionEnd();
	  };
	  ContentEditableInput.prototype.forceCompositionEnd = function () {
	    if (!this.composing) { return }
	    clearTimeout(this.readDOMTimeout);
	    this.composing = null;
	    this.updateFromDOM();
	    this.div.blur();
	    this.div.focus();
	  };
	  ContentEditableInput.prototype.readFromDOMSoon = function () {
	      var this$1 = this;

	    if (this.readDOMTimeout != null) { return }
	    this.readDOMTimeout = setTimeout(function () {
	      this$1.readDOMTimeout = null;
	      if (this$1.composing) {
	        if (this$1.composing.done) { this$1.composing = null; }
	        else { return }
	      }
	      this$1.updateFromDOM();
	    }, 80);
	  };

	  ContentEditableInput.prototype.updateFromDOM = function () {
	      var this$1 = this;

	    if (this.cm.isReadOnly() || !this.pollContent())
	      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
	  };

	  ContentEditableInput.prototype.setUneditable = function (node) {
	    node.contentEditable = "false";
	  };

	  ContentEditableInput.prototype.onKeyPress = function (e) {
	    if (e.charCode == 0 || this.composing) { return }
	    e.preventDefault();
	    if (!this.cm.isReadOnly())
	      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
	  };

	  ContentEditableInput.prototype.readOnlyChanged = function (val) {
	    this.div.contentEditable = String(val != "nocursor");
	  };

	  ContentEditableInput.prototype.onContextMenu = function () {};
	  ContentEditableInput.prototype.resetPosition = function () {};

	  ContentEditableInput.prototype.needsContentAttribute = true;

	  function posToDOM(cm, pos) {
	    var view = findViewForLine(cm, pos.line);
	    if (!view || view.hidden) { return null }
	    var line = getLine(cm.doc, pos.line);
	    var info = mapFromLineView(view, line, pos.line);

	    var order = getOrder(line, cm.doc.direction), side = "left";
	    if (order) {
	      var partPos = getBidiPartAt(order, pos.ch);
	      side = partPos % 2 ? "right" : "left";
	    }
	    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	    result.offset = result.collapse == "right" ? result.end : result.start;
	    return result
	  }

	  function isInGutter(node) {
	    for (var scan = node; scan; scan = scan.parentNode)
	      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
	    return false
	  }

	  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

	  function domTextBetween(cm, from, to, fromLine, toLine) {
	    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
	    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
	    function close() {
	      if (closing) {
	        text += lineSep;
	        if (extraLinebreak) { text += lineSep; }
	        closing = extraLinebreak = false;
	      }
	    }
	    function addText(str) {
	      if (str) {
	        close();
	        text += str;
	      }
	    }
	    function walk(node) {
	      if (node.nodeType == 1) {
	        var cmText = node.getAttribute("cm-text");
	        if (cmText) {
	          addText(cmText);
	          return
	        }
	        var markerID = node.getAttribute("cm-marker"), range;
	        if (markerID) {
	          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
	          if (found.length && (range = found[0].find(0)))
	            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
	          return
	        }
	        if (node.getAttribute("contenteditable") == "false") { return }
	        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
	        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

	        if (isBlock) { close(); }
	        for (var i = 0; i < node.childNodes.length; i++)
	          { walk(node.childNodes[i]); }

	        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
	        if (isBlock) { closing = true; }
	      } else if (node.nodeType == 3) {
	        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
	      }
	    }
	    for (;;) {
	      walk(from);
	      if (from == to) { break }
	      from = from.nextSibling;
	      extraLinebreak = false;
	    }
	    return text
	  }

	  function domToPos(cm, node, offset) {
	    var lineNode;
	    if (node == cm.display.lineDiv) {
	      lineNode = cm.display.lineDiv.childNodes[offset];
	      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
	      node = null; offset = 0;
	    } else {
	      for (lineNode = node;; lineNode = lineNode.parentNode) {
	        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
	        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
	      }
	    }
	    for (var i = 0; i < cm.display.view.length; i++) {
	      var lineView = cm.display.view[i];
	      if (lineView.node == lineNode)
	        { return locateNodeInLineView(lineView, node, offset) }
	    }
	  }

	  function locateNodeInLineView(lineView, node, offset) {
	    var wrapper = lineView.text.firstChild, bad = false;
	    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
	    if (node == wrapper) {
	      bad = true;
	      node = wrapper.childNodes[offset];
	      offset = 0;
	      if (!node) {
	        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	        return badPos(Pos(lineNo(line), line.text.length), bad)
	      }
	    }

	    var textNode = node.nodeType == 3 ? node : null, topNode = node;
	    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	      textNode = node.firstChild;
	      if (offset) { offset = textNode.nodeValue.length; }
	    }
	    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
	    var measure = lineView.measure, maps = measure.maps;

	    function find(textNode, topNode, offset) {
	      for (var i = -1; i < (maps ? maps.length : 0); i++) {
	        var map = i < 0 ? measure.map : maps[i];
	        for (var j = 0; j < map.length; j += 3) {
	          var curNode = map[j + 2];
	          if (curNode == textNode || curNode == topNode) {
	            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	            var ch = map[j] + offset;
	            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
	            return Pos(line, ch)
	          }
	        }
	      }
	    }
	    var found = find(textNode, topNode, offset);
	    if (found) { return badPos(found, bad) }

	    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	      found = find(after, after.firstChild, 0);
	      if (found)
	        { return badPos(Pos(found.line, found.ch - dist), bad) }
	      else
	        { dist += after.textContent.length; }
	    }
	    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
	      found = find(before, before.firstChild, -1);
	      if (found)
	        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
	      else
	        { dist$1 += before.textContent.length; }
	    }
	  }

	  // TEXTAREA INPUT STYLE

	  var TextareaInput = function(cm) {
	    this.cm = cm;
	    // See input.poll and input.reset
	    this.prevInput = "";

	    // Flag that indicates whether we expect input to appear real soon
	    // now (after some event like 'keypress' or 'input') and are
	    // polling intensively.
	    this.pollingFast = false;
	    // Self-resetting timeout for the poller
	    this.polling = new Delayed();
	    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	    this.hasSelection = false;
	    this.composing = null;
	  };

	  TextareaInput.prototype.init = function (display) {
	      var this$1 = this;

	    var input = this, cm = this.cm;
	    this.createField(display);
	    var te = this.textarea;

	    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

	    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	    if (ios) { te.style.width = "0px"; }

	    on(te, "input", function () {
	      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
	      input.poll();
	    });

	    on(te, "paste", function (e) {
	      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

	      cm.state.pasteIncoming = +new Date;
	      input.fastPoll();
	    });

	    function prepareCopyCut(e) {
	      if (signalDOMEvent(cm, e)) { return }
	      if (cm.somethingSelected()) {
	        setLastCopied({lineWise: false, text: cm.getSelections()});
	      } else if (!cm.options.lineWiseCopyCut) {
	        return
	      } else {
	        var ranges = copyableRanges(cm);
	        setLastCopied({lineWise: true, text: ranges.text});
	        if (e.type == "cut") {
	          cm.setSelections(ranges.ranges, null, sel_dontScroll);
	        } else {
	          input.prevInput = "";
	          te.value = ranges.text.join("\n");
	          selectInput(te);
	        }
	      }
	      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
	    }
	    on(te, "cut", prepareCopyCut);
	    on(te, "copy", prepareCopyCut);

	    on(display.scroller, "paste", function (e) {
	      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
	      if (!te.dispatchEvent) {
	        cm.state.pasteIncoming = +new Date;
	        input.focus();
	        return
	      }

	      // Pass the `paste` event to the textarea so it's handled by its event listener.
	      var event = new Event("paste");
	      event.clipboardData = e.clipboardData;
	      te.dispatchEvent(event);
	    });

	    // Prevent normal selection in the editor (we handle our own)
	    on(display.lineSpace, "selectstart", function (e) {
	      if (!eventInWidget(display, e)) { e_preventDefault(e); }
	    });

	    on(te, "compositionstart", function () {
	      var start = cm.getCursor("from");
	      if (input.composing) { input.composing.range.clear(); }
	      input.composing = {
	        start: start,
	        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	      };
	    });
	    on(te, "compositionend", function () {
	      if (input.composing) {
	        input.poll();
	        input.composing.range.clear();
	        input.composing = null;
	      }
	    });
	  };

	  TextareaInput.prototype.createField = function (_display) {
	    // Wraps and hides input textarea
	    this.wrapper = hiddenTextarea();
	    // The semihidden textarea that is focused when the editor is
	    // focused, and receives input.
	    this.textarea = this.wrapper.firstChild;
	  };

	  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
	    // Label for screenreaders, accessibility
	    if(label) {
	      this.textarea.setAttribute('aria-label', label);
	    } else {
	      this.textarea.removeAttribute('aria-label');
	    }
	  };

	  TextareaInput.prototype.prepareSelection = function () {
	    // Redraw the selection and/or cursor
	    var cm = this.cm, display = cm.display, doc = cm.doc;
	    var result = prepareSelection(cm);

	    // Move the hidden textarea near the cursor to prevent scrolling artifacts
	    if (cm.options.moveInputWithCursor) {
	      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                          headPos.top + lineOff.top - wrapOff.top));
	      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                           headPos.left + lineOff.left - wrapOff.left));
	    }

	    return result
	  };

	  TextareaInput.prototype.showSelection = function (drawn) {
	    var cm = this.cm, display = cm.display;
	    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
	    if (drawn.teTop != null) {
	      this.wrapper.style.top = drawn.teTop + "px";
	      this.wrapper.style.left = drawn.teLeft + "px";
	    }
	  };

	  // Reset the input to correspond to the selection (or to be empty,
	  // when not typing and nothing is selected)
	  TextareaInput.prototype.reset = function (typing) {
	    if (this.contextMenuPending || this.composing) { return }
	    var cm = this.cm;
	    if (cm.somethingSelected()) {
	      this.prevInput = "";
	      var content = cm.getSelection();
	      this.textarea.value = content;
	      if (cm.state.focused) { selectInput(this.textarea); }
	      if (ie && ie_version >= 9) { this.hasSelection = content; }
	    } else if (!typing) {
	      this.prevInput = this.textarea.value = "";
	      if (ie && ie_version >= 9) { this.hasSelection = null; }
	    }
	  };

	  TextareaInput.prototype.getField = function () { return this.textarea };

	  TextareaInput.prototype.supportsTouch = function () { return false };

	  TextareaInput.prototype.focus = function () {
	    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	      try { this.textarea.focus(); }
	      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	    }
	  };

	  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

	  TextareaInput.prototype.resetPosition = function () {
	    this.wrapper.style.top = this.wrapper.style.left = 0;
	  };

	  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

	  // Poll for input changes, using the normal rate of polling. This
	  // runs as long as the editor is focused.
	  TextareaInput.prototype.slowPoll = function () {
	      var this$1 = this;

	    if (this.pollingFast) { return }
	    this.polling.set(this.cm.options.pollInterval, function () {
	      this$1.poll();
	      if (this$1.cm.state.focused) { this$1.slowPoll(); }
	    });
	  };

	  // When an event has just come in that is likely to add or change
	  // something in the input textarea, we poll faster, to ensure that
	  // the change appears on the screen quickly.
	  TextareaInput.prototype.fastPoll = function () {
	    var missed = false, input = this;
	    input.pollingFast = true;
	    function p() {
	      var changed = input.poll();
	      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
	      else {input.pollingFast = false; input.slowPoll();}
	    }
	    input.polling.set(20, p);
	  };

	  // Read input from the textarea, and update the document to match.
	  // When something is selected, it is present in the textarea, and
	  // selected (unless it is huge, in which case a placeholder is
	  // used). When nothing is selected, the cursor sits after previously
	  // seen text (can be empty), which is stored in prevInput (we must
	  // not reset the textarea when typing, because that breaks IME).
	  TextareaInput.prototype.poll = function () {
	      var this$1 = this;

	    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
	    // Since this is called a *lot*, try to bail out as cheaply as
	    // possible when it is clear that nothing happened. hasSelection
	    // will be the case when there is a lot of text in the textarea,
	    // in which case reading its value would be expensive.
	    if (this.contextMenuPending || !cm.state.focused ||
	        (hasSelection(input) && !prevInput && !this.composing) ||
	        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	      { return false }

	    var text = input.value;
	    // If nothing changed, bail.
	    if (text == prevInput && !cm.somethingSelected()) { return false }
	    // Work around nonsensical selection resetting in IE9/10, and
	    // inexplicable appearance of private area unicode characters on
	    // some key combos in Mac (#2689).
	    if (ie && ie_version >= 9 && this.hasSelection === text ||
	        mac && /[\uf700-\uf7ff]/.test(text)) {
	      cm.display.input.reset();
	      return false
	    }

	    if (cm.doc.sel == cm.display.selForContextMenu) {
	      var first = text.charCodeAt(0);
	      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
	      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
	    }
	    // Find the part of the input that is actually new
	    var same = 0, l = Math.min(prevInput.length, text.length);
	    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

	    runInOp(cm, function () {
	      applyTextInput(cm, text.slice(same), prevInput.length - same,
	                     null, this$1.composing ? "*compose" : null);

	      // Don't leave long text in the textarea, since it makes further polling slow
	      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
	      else { this$1.prevInput = text; }

	      if (this$1.composing) {
	        this$1.composing.range.clear();
	        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
	                                           {className: "CodeMirror-composing"});
	      }
	    });
	    return true
	  };

	  TextareaInput.prototype.ensurePolled = function () {
	    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
	  };

	  TextareaInput.prototype.onKeyPress = function () {
	    if (ie && ie_version >= 9) { this.hasSelection = null; }
	    this.fastPoll();
	  };

	  TextareaInput.prototype.onContextMenu = function (e) {
	    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
	    if (input.contextMenuPending) { input.contextMenuPending(); }
	    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	    if (!pos || presto) { return } // Opera is difficult.

	    // Reset the current text selection only if the click is done outside of the selection
	    // and 'resetSelectionOnContextMenu' option is true.
	    var reset = cm.options.resetSelectionOnContextMenu;
	    if (reset && cm.doc.sel.contains(pos) == -1)
	      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

	    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
	    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
	    input.wrapper.style.cssText = "position: static";
	    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	    var oldScrollY;
	    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
	    display.input.focus();
	    if (webkit) { window.scrollTo(null, oldScrollY); }
	    display.input.reset();
	    // Adds "Select all" to context menu in FF
	    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
	    input.contextMenuPending = rehide;
	    display.selForContextMenu = cm.doc.sel;
	    clearTimeout(display.detectingSelectAll);

	    // Select-all will be greyed out if there's nothing to select, so
	    // this adds a zero-width space so that we can later check whether
	    // it got selected.
	    function prepareSelectAllHack() {
	      if (te.selectionStart != null) {
	        var selected = cm.somethingSelected();
	        var extval = "\u200b" + (selected ? te.value : "");
	        te.value = "\u21da"; // Used to catch context-menu undo
	        te.value = extval;
	        input.prevInput = selected ? "" : "\u200b";
	        te.selectionStart = 1; te.selectionEnd = extval.length;
	        // Re-set this, in case some other handler touched the
	        // selection in the meantime.
	        display.selForContextMenu = cm.doc.sel;
	      }
	    }
	    function rehide() {
	      if (input.contextMenuPending != rehide) { return }
	      input.contextMenuPending = false;
	      input.wrapper.style.cssText = oldWrapperCSS;
	      te.style.cssText = oldCSS;
	      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

	      // Try to detect the user choosing select-all
	      if (te.selectionStart != null) {
	        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
	        var i = 0, poll = function () {
	          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	              te.selectionEnd > 0 && input.prevInput == "\u200b") {
	            operation(cm, selectAll)(cm);
	          } else if (i++ < 10) {
	            display.detectingSelectAll = setTimeout(poll, 500);
	          } else {
	            display.selForContextMenu = null;
	            display.input.reset();
	          }
	        };
	        display.detectingSelectAll = setTimeout(poll, 200);
	      }
	    }

	    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
	    if (captureRightClick) {
	      e_stop(e);
	      var mouseup = function () {
	        off(window, "mouseup", mouseup);
	        setTimeout(rehide, 20);
	      };
	      on(window, "mouseup", mouseup);
	    } else {
	      setTimeout(rehide, 50);
	    }
	  };

	  TextareaInput.prototype.readOnlyChanged = function (val) {
	    if (!val) { this.reset(); }
	    this.textarea.disabled = val == "nocursor";
	  };

	  TextareaInput.prototype.setUneditable = function () {};

	  TextareaInput.prototype.needsContentAttribute = false;

	  function fromTextArea(textarea, options) {
	    options = options ? copyObj(options) : {};
	    options.value = textarea.value;
	    if (!options.tabindex && textarea.tabIndex)
	      { options.tabindex = textarea.tabIndex; }
	    if (!options.placeholder && textarea.placeholder)
	      { options.placeholder = textarea.placeholder; }
	    // Set autofocus to true if this textarea is focused, or if it has
	    // autofocus and no other element is focused.
	    if (options.autofocus == null) {
	      var hasFocus = activeElt();
	      options.autofocus = hasFocus == textarea ||
	        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	    }

	    function save() {textarea.value = cm.getValue();}

	    var realSubmit;
	    if (textarea.form) {
	      on(textarea.form, "submit", save);
	      // Deplorable hack to make the submit method do the right thing.
	      if (!options.leaveSubmitMethodAlone) {
	        var form = textarea.form;
	        realSubmit = form.submit;
	        try {
	          var wrappedSubmit = form.submit = function () {
	            save();
	            form.submit = realSubmit;
	            form.submit();
	            form.submit = wrappedSubmit;
	          };
	        } catch(e) {}
	      }
	    }

	    options.finishInit = function (cm) {
	      cm.save = save;
	      cm.getTextArea = function () { return textarea; };
	      cm.toTextArea = function () {
	        cm.toTextArea = isNaN; // Prevent this from being ran twice
	        save();
	        textarea.parentNode.removeChild(cm.getWrapperElement());
	        textarea.style.display = "";
	        if (textarea.form) {
	          off(textarea.form, "submit", save);
	          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
	            { textarea.form.submit = realSubmit; }
	        }
	      };
	    };

	    textarea.style.display = "none";
	    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
	      options);
	    return cm
	  }

	  function addLegacyProps(CodeMirror) {
	    CodeMirror.off = off;
	    CodeMirror.on = on;
	    CodeMirror.wheelEventPixels = wheelEventPixels;
	    CodeMirror.Doc = Doc;
	    CodeMirror.splitLines = splitLinesAuto;
	    CodeMirror.countColumn = countColumn;
	    CodeMirror.findColumn = findColumn;
	    CodeMirror.isWordChar = isWordCharBasic;
	    CodeMirror.Pass = Pass;
	    CodeMirror.signal = signal;
	    CodeMirror.Line = Line;
	    CodeMirror.changeEnd = changeEnd;
	    CodeMirror.scrollbarModel = scrollbarModel;
	    CodeMirror.Pos = Pos;
	    CodeMirror.cmpPos = cmp;
	    CodeMirror.modes = modes;
	    CodeMirror.mimeModes = mimeModes;
	    CodeMirror.resolveMode = resolveMode;
	    CodeMirror.getMode = getMode;
	    CodeMirror.modeExtensions = modeExtensions;
	    CodeMirror.extendMode = extendMode;
	    CodeMirror.copyState = copyState;
	    CodeMirror.startState = startState;
	    CodeMirror.innerMode = innerMode;
	    CodeMirror.commands = commands;
	    CodeMirror.keyMap = keyMap;
	    CodeMirror.keyName = keyName;
	    CodeMirror.isModifierKey = isModifierKey;
	    CodeMirror.lookupKey = lookupKey;
	    CodeMirror.normalizeKeyMap = normalizeKeyMap;
	    CodeMirror.StringStream = StringStream;
	    CodeMirror.SharedTextMarker = SharedTextMarker;
	    CodeMirror.TextMarker = TextMarker;
	    CodeMirror.LineWidget = LineWidget;
	    CodeMirror.e_preventDefault = e_preventDefault;
	    CodeMirror.e_stopPropagation = e_stopPropagation;
	    CodeMirror.e_stop = e_stop;
	    CodeMirror.addClass = addClass;
	    CodeMirror.contains = contains;
	    CodeMirror.rmClass = rmClass;
	    CodeMirror.keyNames = keyNames;
	  }

	  // EDITOR CONSTRUCTOR

	  defineOptions(CodeMirror);

	  addEditorMethods(CodeMirror);

	  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
	  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
	  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	    { CodeMirror.prototype[prop] = (function(method) {
	      return function() {return method.apply(this.doc, arguments)}
	    })(Doc.prototype[prop]); } }

	  eventMixin(Doc);
	  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

	  // Extra arguments are stored as the mode's dependencies, which is
	  // used by (legacy) mechanisms like loadmode.js to automatically
	  // load a mode. (Preferred mechanism is the require/define calls.)
	  CodeMirror.defineMode = function(name/*, mode, â¦*/) {
	    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
	    defineMode.apply(this, arguments);
	  };

	  CodeMirror.defineMIME = defineMIME;

	  // Minimal default mode.
	  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
	  CodeMirror.defineMIME("text/plain", "null");

	  // EXTENSIONS

	  CodeMirror.defineExtension = function (name, func) {
	    CodeMirror.prototype[name] = func;
	  };
	  CodeMirror.defineDocExtension = function (name, func) {
	    Doc.prototype[name] = func;
	  };

	  CodeMirror.fromTextArea = fromTextArea;

	  addLegacyProps(CodeMirror);

	  CodeMirror.version = "5.56.0";

	  return CodeMirror;

	})));
	});

	var codeMirrorStyle = "/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n  color: black;\n  direction: ltr;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  white-space: nowrap;\n}\n\n.CodeMirror-guttermarker { color: black; }\n.CodeMirror-guttermarker-subtle { color: #999; }\n\n/* CURSOR */\n\n.CodeMirror-cursor {\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.cm-fat-cursor .CodeMirror-cursor {\n  width: auto;\n  border: 0 !important;\n  background: #7e7;\n}\n.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n.cm-fat-cursor-mark {\n  background-color: rgba(20, 255, 20, 0.5);\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n}\n.cm-animate-fat-cursor {\n  width: auto;\n  border: 0;\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n  background-color: #7e7;\n}\n@-moz-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@-webkit-keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n@keyframes blink {\n  0% {}\n  50% { background-color: transparent; }\n  100% {}\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror-overwrite .CodeMirror-cursor {}\n\n.cm-tab { display: inline-block; text-decoration: inherit; }\n\n.CodeMirror-rulers {\n  position: absolute;\n  left: 0; right: 0; top: -50px; bottom: 0;\n  overflow: hidden;\n}\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  top: 0; bottom: 0;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\n.CodeMirror-composing { border-bottom: 2px solid; }\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  position: relative;\n  overflow: hidden;\n  background: white;\n}\n\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 50px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -50px; margin-right: -50px;\n  padding-bottom: 50px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 50px solid transparent;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actual scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  min-height: 100%;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  display: inline-block;\n  vertical-align: top;\n  margin-bottom: -50px;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  background: none !important;\n  border: none !important;\n}\n.CodeMirror-gutter-background {\n  position: absolute;\n  top: 0; bottom: 0;\n  z-index: 4;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\n\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre.CodeMirror-line,\n.CodeMirror pre.CodeMirror-line-like {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-font-variant-ligatures: contextual;\n  font-variant-ligatures: contextual;\n}\n.CodeMirror-wrap pre.CodeMirror-line,\n.CodeMirror-wrap pre.CodeMirror-line-like {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-rtl pre { direction: rtl; }\n\n.CodeMirror-code {\n  outline: none;\n}\n\n/* Force content-box sizing for the elements where we expect it */\n.CodeMirror-scroll,\n.CodeMirror-sizer,\n.CodeMirror-gutter,\n.CodeMirror-gutters,\n.CodeMirror-linenumber {\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n\n.CodeMirror-cursor {\n  position: absolute;\n  pointer-events: none;\n}\n.CodeMirror-measure pre { position: static; }\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\ndiv.CodeMirror-dragcursors {\n  visibility: visible;\n}\n\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n.CodeMirror-crosshair { cursor: crosshair; }\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\n\n.cm-searching {\n  background-color: #ffa;\n  background-color: rgba(255, 255, 0, .4);\n}\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: ''; }\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none; }\n";

	var darculaStyle = "/**\n    Name: IntelliJ IDEA darcula theme\n    From IntelliJ IDEA by JetBrains\n */\n\n.cm-s-darcula  { font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace, serif;}\n.cm-s-darcula.CodeMirror { background: #2B2B2B; color: #A9B7C6; }\n\n.cm-s-darcula span.cm-meta { color: #BBB529; }\n.cm-s-darcula span.cm-number { color: #6897BB; }\n.cm-s-darcula span.cm-keyword { color: #CC7832; line-height: 1em; font-weight: bold; }\n.cm-s-darcula span.cm-def { color: #A9B7C6; font-style: italic; }\n.cm-s-darcula span.cm-variable { color: #A9B7C6; }\n.cm-s-darcula span.cm-variable-2 { color: #A9B7C6; }\n.cm-s-darcula span.cm-variable-3 { color: #9876AA; }\n.cm-s-darcula span.cm-type { color: #AABBCC; font-weight: bold; }\n.cm-s-darcula span.cm-property { color: #FFC66D; }\n.cm-s-darcula span.cm-operator { color: #A9B7C6; }\n.cm-s-darcula span.cm-string { color: #6A8759; }\n.cm-s-darcula span.cm-string-2 { color: #6A8759; }\n.cm-s-darcula span.cm-comment { color: #61A151; font-style: italic; }\n.cm-s-darcula span.cm-link { color: #CC7832; }\n.cm-s-darcula span.cm-atom { color: #CC7832; }\n.cm-s-darcula span.cm-error { color: #BC3F3C; }\n.cm-s-darcula span.cm-tag { color: #629755; font-weight: bold; font-style: italic; text-decoration: underline; }\n.cm-s-darcula span.cm-attribute { color: #6897bb; }\n.cm-s-darcula span.cm-qualifier { color: #6A8759; }\n.cm-s-darcula span.cm-bracket { color: #A9B7C6; }\n.cm-s-darcula span.cm-builtin { color: #FF9E59; }\n.cm-s-darcula span.cm-special { color: #FF9E59; }\n.cm-s-darcula span.cm-matchhighlight { color: #FFFFFF; background-color: rgba(50, 89, 48, .7); font-weight: normal;}\n.cm-s-darcula span.cm-searching { color: #FFFFFF; background-color: rgba(61, 115, 59, .7); font-weight: normal;}\n\n.cm-s-darcula .CodeMirror-cursor { border-left: 1px solid #A9B7C6; }\n.cm-s-darcula .CodeMirror-activeline-background { background: #323232; }\n.cm-s-darcula .CodeMirror-gutters { background: #313335; border-right: 1px solid #313335; }\n.cm-s-darcula .CodeMirror-guttermarker { color: #FFEE80; }\n.cm-s-darcula .CodeMirror-guttermarker-subtle { color: #D0D0D0; }\n.cm-s-darcula .CodeMirrir-linenumber { color: #606366; }\n.cm-s-darcula .CodeMirror-matchingbracket { background-color: #3B514D; color: #FFEF28 !important; font-weight: bold; }\n\n.cm-s-darcula div.CodeMirror-selected { background: #214283; }\n\n.CodeMirror-hints.darcula {\n  font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;\n  color: #9C9E9E;\n  background-color: #3B3E3F !important;\n}\n\n.CodeMirror-hints.darcula .CodeMirror-hint-active {\n  background-color: #494D4E !important;\n  color: #9C9E9E !important;\n}\n";

	var examplesStyle = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-example-container {\n    width: 100vw;\n    height: 100vh;\n    display: flex;\n    flex-direction: row;\n    align-items: stretch;\n\n}\n\n.facet-example-editor-container {\n    flex-grow: 1;\n    flex-shrink: 0;\n    width: 10%;\n    display: flex;\n    flex-direction: column;\n    border-right: solid 5px #909090;\n}\n\n.facet-example-editor-header {\n    width: 100%;\n    height: 50px;\n    background-color: #909090;\n}\n\n.facet-example-editor-button {\n    float: left;\n    width: 100px;\n    height: calc(100% - 2px);\n    background-color: rgb(63,63,63);\n    border-top: 1px solid rgb(83,83,83);\n    border-left: 1px solid rgb(83,83,83);\n    border-right: 1px solid rgb(83,83,83);\n    border-bottom: 1px solid #909090;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    user-select: none;\n    -ms-user-select: none;\n    cursor: pointer;\n\n    color: rgb(245,245,245);\n    font-family: monospace;\n    font-size: 16px;\n}\n\n.facet-example-editor-button-selected {\n    background-color: rgb(43,43,43);\n    border-bottom: 1px solid rgb(43,43,43);\n}\n\n.facet-example-editor-button-run {\n    float: right;\n    width: 100px;\n    height: calc(100% - 20px);\n    margin-top: 9px;\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    user-select: none;\n    -ms-user-select: none;\n    cursor: pointer;\n\n    background-color: rgb(103,43,43);\n\n    color: rgb(245,245,245);\n    font-family: monospace;\n    font-size: 16px;\n\n    border: 1px solid red;\n}\n\n.facet-example-editor-body {\n    flex-grow: 1;\n    width: 100%;\n    height: 10%;\n    position: relative;\n}\n\n.facet-example-editor {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n}\n\n.facet-example-preview {\n    flex-grow: 1;\n    flex-shrink: 0;\n    width: 10%;\n    border-left: solid 5px #909090;\n\n    display: flex;\n    flex-direction: column;\n}\n\n.facet-example-preview-header {\n    width: 100%;\n    height: 50px;\n    background-color: #909090;\n}\n\n.facet-example-select {\n    display: block;\n    font-size: 14px;\n    font-family: monospace;\n    color: #444;\n    line-height: 20px;\n    padding: 2px 10px 5px 10px;\n    width: 300px;\n    max-width: 600px;\n    box-sizing: border-box;\n    margin-top: 10px;\n    margin-right: 20px;\n    border: 1px solid #aaa;\n    box-shadow: 0 1px 0 1px rgba(0,0,0,.04);\n    border-radius: 0;\n    -moz-appearance: none;\n    -webkit-appearance: none;\n    appearance: none;\n    background-color: #fff;\n    background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007CB2%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'),\n    linear-gradient(to bottom, #ffffff 0%,#e5e5e5 100%);\n    background-repeat: no-repeat, repeat;\n    background-position: right .7em top 50%, 0 0;\n    background-size: .65em auto, 100%;\n    float: right;\n}\n.facet-example-select::-ms-expand {\n    display: none;\n}\n.facet-example-select:hover {\n    border-color: #888;\n}\n.facet-example-select:focus {\n    border-color: #aaa;\n    box-shadow: 0 0 1px 3px rgba(59, 153, 252, .7);\n    box-shadow: 0 0 0 3px -moz-mac-focusring;\n    color: #222;\n    outline: none;\n}\n.facet-example-select option {\n    font-weight: normal;\n}\n\n.facet-example-preview-iframe {\n    border: none;\n    flex-grow: 1;\n    width: 100%;\n    height: 10%;\n}\n";

	var javascript = createCommonjsModule(function (module, exports) {
	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE

	(function(mod) {
	  mod(codemirror);
	})(function(CodeMirror) {

	CodeMirror.defineMode("javascript", function(config, parserConfig) {
	  var indentUnit = config.indentUnit;
	  var statementIndent = parserConfig.statementIndent;
	  var jsonldMode = parserConfig.jsonld;
	  var jsonMode = parserConfig.json || jsonldMode;
	  var isTS = parserConfig.typescript;
	  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

	  // Tokenizer

	  var keywords = function(){
	    function kw(type) {return {type: type, style: "keyword"};}
	    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
	    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

	    return {
	      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
	      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
	      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
	      "function": kw("function"), "catch": kw("catch"),
	      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
	      "in": operator, "typeof": operator, "instanceof": operator,
	      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
	      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
	      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
	      "await": C
	    };
	  }();

	  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
	  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

	  function readRegexp(stream) {
	    var escaped = false, next, inSet = false;
	    while ((next = stream.next()) != null) {
	      if (!escaped) {
	        if (next == "/" && !inSet) return;
	        if (next == "[") inSet = true;
	        else if (inSet && next == "]") inSet = false;
	      }
	      escaped = !escaped && next == "\\";
	    }
	  }

	  // Used as scratch variables to communicate multiple values without
	  // consing up tons of objects.
	  var type, content;
	  function ret(tp, style, cont) {
	    type = tp; content = cont;
	    return style;
	  }
	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (ch == '"' || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
	      return ret("number", "number");
	    } else if (ch == "." && stream.match("..")) {
	      return ret("spread", "meta");
	    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
	      return ret(ch);
	    } else if (ch == "=" && stream.eat(">")) {
	      return ret("=>", "operator");
	    } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
	      return ret("number", "number");
	    } else if (/\d/.test(ch)) {
	      stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
	      return ret("number", "number");
	    } else if (ch == "/") {
	      if (stream.eat("*")) {
	        state.tokenize = tokenComment;
	        return tokenComment(stream, state);
	      } else if (stream.eat("/")) {
	        stream.skipToEnd();
	        return ret("comment", "comment");
	      } else if (expressionAllowed(stream, state, 1)) {
	        readRegexp(stream);
	        stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
	        return ret("regexp", "string-2");
	      } else {
	        stream.eat("=");
	        return ret("operator", "operator", stream.current());
	      }
	    } else if (ch == "`") {
	      state.tokenize = tokenQuasi;
	      return tokenQuasi(stream, state);
	    } else if (ch == "#" && stream.peek() == "!") {
	      stream.skipToEnd();
	      return ret("meta", "meta");
	    } else if (ch == "#" && stream.eatWhile(wordRE)) {
	      return ret("variable", "property")
	    } else if (ch == "<" && stream.match("!--") ||
	               (ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start)))) {
	      stream.skipToEnd();
	      return ret("comment", "comment")
	    } else if (isOperatorChar.test(ch)) {
	      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
	        if (stream.eat("=")) {
	          if (ch == "!" || ch == "=") stream.eat("=");
	        } else if (/[<>*+\-]/.test(ch)) {
	          stream.eat(ch);
	          if (ch == ">") stream.eat(ch);
	        }
	      }
	      if (ch == "?" && stream.eat(".")) return ret(".")
	      return ret("operator", "operator", stream.current());
	    } else if (wordRE.test(ch)) {
	      stream.eatWhile(wordRE);
	      var word = stream.current();
	      if (state.lastType != ".") {
	        if (keywords.propertyIsEnumerable(word)) {
	          var kw = keywords[word];
	          return ret(kw.type, kw.style, word)
	        }
	        if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false))
	          return ret("async", "keyword", word)
	      }
	      return ret("variable", "variable", word)
	    }
	  }

	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, next;
	      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
	        state.tokenize = tokenBase;
	        return ret("jsonld-keyword", "meta");
	      }
	      while ((next = stream.next()) != null) {
	        if (next == quote && !escaped) break;
	        escaped = !escaped && next == "\\";
	      }
	      if (!escaped) state.tokenize = tokenBase;
	      return ret("string", "string");
	    };
	  }

	  function tokenComment(stream, state) {
	    var maybeEnd = false, ch;
	    while (ch = stream.next()) {
	      if (ch == "/" && maybeEnd) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ret("comment", "comment");
	  }

	  function tokenQuasi(stream, state) {
	    var escaped = false, next;
	    while ((next = stream.next()) != null) {
	      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      escaped = !escaped && next == "\\";
	    }
	    return ret("quasi", "string-2", stream.current());
	  }

	  var brackets = "([{}])";
	  // This is a crude lookahead trick to try and notice that we're
	  // parsing the argument patterns for a fat-arrow function before we
	  // actually hit the arrow token. It only works if the arrow is on
	  // the same line as the arguments and there's no strange noise
	  // (comments) in between. Fallback is to only notice when we hit the
	  // arrow, and not declare the arguments as locals for the arrow
	  // body.
	  function findFatArrow(stream, state) {
	    if (state.fatArrowAt) state.fatArrowAt = null;
	    var arrow = stream.string.indexOf("=>", stream.start);
	    if (arrow < 0) return;

	    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
	      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
	      if (m) arrow = m.index;
	    }

	    var depth = 0, sawSomething = false;
	    for (var pos = arrow - 1; pos >= 0; --pos) {
	      var ch = stream.string.charAt(pos);
	      var bracket = brackets.indexOf(ch);
	      if (bracket >= 0 && bracket < 3) {
	        if (!depth) { ++pos; break; }
	        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
	      } else if (bracket >= 3 && bracket < 6) {
	        ++depth;
	      } else if (wordRE.test(ch)) {
	        sawSomething = true;
	      } else if (/["'\/`]/.test(ch)) {
	        for (;; --pos) {
	          if (pos == 0) return
	          var next = stream.string.charAt(pos - 1);
	          if (next == ch && stream.string.charAt(pos - 2) != "\\") { pos--; break }
	        }
	      } else if (sawSomething && !depth) {
	        ++pos;
	        break;
	      }
	    }
	    if (sawSomething && !depth) state.fatArrowAt = pos;
	  }

	  // Parser

	  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

	  function JSLexical(indented, column, type, align, prev, info) {
	    this.indented = indented;
	    this.column = column;
	    this.type = type;
	    this.prev = prev;
	    this.info = info;
	    if (align != null) this.align = align;
	  }

	  function inScope(state, varname) {
	    for (var v = state.localVars; v; v = v.next)
	      if (v.name == varname) return true;
	    for (var cx = state.context; cx; cx = cx.prev) {
	      for (var v = cx.vars; v; v = v.next)
	        if (v.name == varname) return true;
	    }
	  }

	  function parseJS(state, style, type, content, stream) {
	    var cc = state.cc;
	    // Communicate our context to the combinators.
	    // (Less wasteful than consing up a hundred closures on every call.)
	    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

	    if (!state.lexical.hasOwnProperty("align"))
	      state.lexical.align = true;

	    while(true) {
	      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
	      if (combinator(type, content)) {
	        while(cc.length && cc[cc.length - 1].lex)
	          cc.pop()();
	        if (cx.marked) return cx.marked;
	        if (type == "variable" && inScope(state, content)) return "variable-2";
	        return style;
	      }
	    }
	  }

	  // Combinator utils

	  var cx = {state: null, column: null, marked: null, cc: null};
	  function pass() {
	    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
	  }
	  function cont() {
	    pass.apply(null, arguments);
	    return true;
	  }
	  function inList(name, list) {
	    for (var v = list; v; v = v.next) if (v.name == name) return true
	    return false;
	  }
	  function register(varname) {
	    var state = cx.state;
	    cx.marked = "def";
	    if (state.context) {
	      if (state.lexical.info == "var" && state.context && state.context.block) {
	        // FIXME function decls are also not block scoped
	        var newContext = registerVarScoped(varname, state.context);
	        if (newContext != null) {
	          state.context = newContext;
	          return
	        }
	      } else if (!inList(varname, state.localVars)) {
	        state.localVars = new Var(varname, state.localVars);
	        return
	      }
	    }
	    // Fall through means this is global
	    if (parserConfig.globalVars && !inList(varname, state.globalVars))
	      state.globalVars = new Var(varname, state.globalVars);
	  }
	  function registerVarScoped(varname, context) {
	    if (!context) {
	      return null
	    } else if (context.block) {
	      var inner = registerVarScoped(varname, context.prev);
	      if (!inner) return null
	      if (inner == context.prev) return context
	      return new Context(inner, context.vars, true)
	    } else if (inList(varname, context.vars)) {
	      return context
	    } else {
	      return new Context(context.prev, new Var(varname, context.vars), false)
	    }
	  }

	  function isModifier(name) {
	    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
	  }

	  // Combinators

	  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block; }
	  function Var(name, next) { this.name = name; this.next = next; }

	  var defaultVars = new Var("this", new Var("arguments", null));
	  function pushcontext() {
	    cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
	    cx.state.localVars = defaultVars;
	  }
	  function pushblockcontext() {
	    cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
	    cx.state.localVars = null;
	  }
	  function popcontext() {
	    cx.state.localVars = cx.state.context.vars;
	    cx.state.context = cx.state.context.prev;
	  }
	  popcontext.lex = true;
	  function pushlex(type, info) {
	    var result = function() {
	      var state = cx.state, indent = state.indented;
	      if (state.lexical.type == "stat") indent = state.lexical.indented;
	      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
	        indent = outer.indented;
	      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
	    };
	    result.lex = true;
	    return result;
	  }
	  function poplex() {
	    var state = cx.state;
	    if (state.lexical.prev) {
	      if (state.lexical.type == ")")
	        state.indented = state.lexical.indented;
	      state.lexical = state.lexical.prev;
	    }
	  }
	  poplex.lex = true;

	  function expect(wanted) {
	    function exp(type) {
	      if (type == wanted) return cont();
	      else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
	      else return cont(exp);
	    }    return exp;
	  }

	  function statement(type, value) {
	    if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
	    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
	    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
	    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
	    if (type == "debugger") return cont(expect(";"));
	    if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
	    if (type == ";") return cont();
	    if (type == "if") {
	      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
	        cx.state.cc.pop()();
	      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
	    }
	    if (type == "function") return cont(functiondef);
	    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
	    if (type == "class" || (isTS && value == "interface")) {
	      cx.marked = "keyword";
	      return cont(pushlex("form", type == "class" ? type : value), className, poplex)
	    }
	    if (type == "variable") {
	      if (isTS && value == "declare") {
	        cx.marked = "keyword";
	        return cont(statement)
	      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
	        cx.marked = "keyword";
	        if (value == "enum") return cont(enumdef);
	        else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
	        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
	      } else if (isTS && value == "namespace") {
	        cx.marked = "keyword";
	        return cont(pushlex("form"), expression, statement, poplex)
	      } else if (isTS && value == "abstract") {
	        cx.marked = "keyword";
	        return cont(statement)
	      } else {
	        return cont(pushlex("stat"), maybelabel);
	      }
	    }
	    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
	                                      block, poplex, poplex, popcontext);
	    if (type == "case") return cont(expression, expect(":"));
	    if (type == "default") return cont(expect(":"));
	    if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
	    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
	    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
	    if (type == "async") return cont(statement)
	    if (value == "@") return cont(expression, statement)
	    return pass(pushlex("stat"), expression, expect(";"), poplex);
	  }
	  function maybeCatchBinding(type) {
	    if (type == "(") return cont(funarg, expect(")"))
	  }
	  function expression(type, value) {
	    return expressionInner(type, value, false);
	  }
	  function expressionNoComma(type, value) {
	    return expressionInner(type, value, true);
	  }
	  function parenExpr(type) {
	    if (type != "(") return pass()
	    return cont(pushlex(")"), maybeexpression, expect(")"), poplex)
	  }
	  function expressionInner(type, value, noComma) {
	    if (cx.state.fatArrowAt == cx.stream.start) {
	      var body = noComma ? arrowBodyNoComma : arrowBody;
	      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
	      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
	    }

	    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
	    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
	    if (type == "function") return cont(functiondef, maybeop);
	    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
	    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
	    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
	    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
	    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
	    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
	    if (type == "quasi") return pass(quasi, maybeop);
	    if (type == "new") return cont(maybeTarget(noComma));
	    if (type == "import") return cont(expression);
	    return cont();
	  }
	  function maybeexpression(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expression);
	  }

	  function maybeoperatorComma(type, value) {
	    if (type == ",") return cont(maybeexpression);
	    return maybeoperatorNoComma(type, value, false);
	  }
	  function maybeoperatorNoComma(type, value, noComma) {
	    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
	    var expr = noComma == false ? expression : expressionNoComma;
	    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
	    if (type == "operator") {
	      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
	      if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
	        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
	      if (value == "?") return cont(expression, expect(":"), expr);
	      return cont(expr);
	    }
	    if (type == "quasi") { return pass(quasi, me); }
	    if (type == ";") return;
	    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
	    if (type == ".") return cont(property, me);
	    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
	    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
	    if (type == "regexp") {
	      cx.state.lastType = cx.marked = "operator";
	      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
	      return cont(expr)
	    }
	  }
	  function quasi(type, value) {
	    if (type != "quasi") return pass();
	    if (value.slice(value.length - 2) != "${") return cont(quasi);
	    return cont(expression, continueQuasi);
	  }
	  function continueQuasi(type) {
	    if (type == "}") {
	      cx.marked = "string-2";
	      cx.state.tokenize = tokenQuasi;
	      return cont(quasi);
	    }
	  }
	  function arrowBody(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expression);
	  }
	  function arrowBodyNoComma(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expressionNoComma);
	  }
	  function maybeTarget(noComma) {
	    return function(type) {
	      if (type == ".") return cont(noComma ? targetNoComma : target);
	      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
	      else return pass(noComma ? expressionNoComma : expression);
	    };
	  }
	  function target(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
	  }
	  function targetNoComma(_, value) {
	    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
	  }
	  function maybelabel(type) {
	    if (type == ":") return cont(poplex, statement);
	    return pass(maybeoperatorComma, expect(";"), poplex);
	  }
	  function property(type) {
	    if (type == "variable") {cx.marked = "property"; return cont();}
	  }
	  function objprop(type, value) {
	    if (type == "async") {
	      cx.marked = "property";
	      return cont(objprop);
	    } else if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      if (value == "get" || value == "set") return cont(getterSetter);
	      var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params
	      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
	        cx.state.fatArrowAt = cx.stream.pos + m[0].length;
	      return cont(afterprop);
	    } else if (type == "number" || type == "string") {
	      cx.marked = jsonldMode ? "property" : (cx.style + " property");
	      return cont(afterprop);
	    } else if (type == "jsonld-keyword") {
	      return cont(afterprop);
	    } else if (isTS && isModifier(value)) {
	      cx.marked = "keyword";
	      return cont(objprop)
	    } else if (type == "[") {
	      return cont(expression, maybetype, expect("]"), afterprop);
	    } else if (type == "spread") {
	      return cont(expressionNoComma, afterprop);
	    } else if (value == "*") {
	      cx.marked = "keyword";
	      return cont(objprop);
	    } else if (type == ":") {
	      return pass(afterprop)
	    }
	  }
	  function getterSetter(type) {
	    if (type != "variable") return pass(afterprop);
	    cx.marked = "property";
	    return cont(functiondef);
	  }
	  function afterprop(type) {
	    if (type == ":") return cont(expressionNoComma);
	    if (type == "(") return pass(functiondef);
	  }
	  function commasep(what, end, sep) {
	    function proceed(type, value) {
	      if (sep ? sep.indexOf(type) > -1 : type == ",") {
	        var lex = cx.state.lexical;
	        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
	        return cont(function(type, value) {
	          if (type == end || value == end) return pass()
	          return pass(what)
	        }, proceed);
	      }
	      if (type == end || value == end) return cont();
	      if (sep && sep.indexOf(";") > -1) return pass(what)
	      return cont(expect(end));
	    }
	    return function(type, value) {
	      if (type == end || value == end) return cont();
	      return pass(what, proceed);
	    };
	  }
	  function contCommasep(what, end, info) {
	    for (var i = 3; i < arguments.length; i++)
	      cx.cc.push(arguments[i]);
	    return cont(pushlex(end, info), commasep(what, end), poplex);
	  }
	  function block(type) {
	    if (type == "}") return cont();
	    return pass(statement, block);
	  }
	  function maybetype(type, value) {
	    if (isTS) {
	      if (type == ":") return cont(typeexpr);
	      if (value == "?") return cont(maybetype);
	    }
	  }
	  function maybetypeOrIn(type, value) {
	    if (isTS && (type == ":" || value == "in")) return cont(typeexpr)
	  }
	  function mayberettype(type) {
	    if (isTS && type == ":") {
	      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
	      else return cont(typeexpr)
	    }
	  }
	  function isKW(_, value) {
	    if (value == "is") {
	      cx.marked = "keyword";
	      return cont()
	    }
	  }
	  function typeexpr(type, value) {
	    if (value == "keyof" || value == "typeof" || value == "infer") {
	      cx.marked = "keyword";
	      return cont(value == "typeof" ? expressionNoComma : typeexpr)
	    }
	    if (type == "variable" || value == "void") {
	      cx.marked = "type";
	      return cont(afterType)
	    }
	    if (value == "|" || value == "&") return cont(typeexpr)
	    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
	    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
	    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
	    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
	    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
	  }
	  function maybeReturnType(type) {
	    if (type == "=>") return cont(typeexpr)
	  }
	  function typeprop(type, value) {
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      return cont(typeprop)
	    } else if (value == "?" || type == "number" || type == "string") {
	      return cont(typeprop)
	    } else if (type == ":") {
	      return cont(typeexpr)
	    } else if (type == "[") {
	      return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop)
	    } else if (type == "(") {
	      return pass(functiondecl, typeprop)
	    }
	  }
	  function typearg(type, value) {
	    if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
	    if (type == ":") return cont(typeexpr)
	    if (type == "spread") return cont(typearg)
	    return pass(typeexpr)
	  }
	  function afterType(type, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
	    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
	    if (type == "[") return cont(typeexpr, expect("]"), afterType)
	    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
	    if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
	  }
	  function maybeTypeArgs(_, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
	  }
	  function typeparam() {
	    return pass(typeexpr, maybeTypeDefault)
	  }
	  function maybeTypeDefault(_, value) {
	    if (value == "=") return cont(typeexpr)
	  }
	  function vardef(_, value) {
	    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
	    return pass(pattern, maybetype, maybeAssign, vardefCont);
	  }
	  function pattern(type, value) {
	    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
	    if (type == "variable") { register(value); return cont(); }
	    if (type == "spread") return cont(pattern);
	    if (type == "[") return contCommasep(eltpattern, "]");
	    if (type == "{") return contCommasep(proppattern, "}");
	  }
	  function proppattern(type, value) {
	    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
	      register(value);
	      return cont(maybeAssign);
	    }
	    if (type == "variable") cx.marked = "property";
	    if (type == "spread") return cont(pattern);
	    if (type == "}") return pass();
	    if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
	    return cont(expect(":"), pattern, maybeAssign);
	  }
	  function eltpattern() {
	    return pass(pattern, maybeAssign)
	  }
	  function maybeAssign(_type, value) {
	    if (value == "=") return cont(expressionNoComma);
	  }
	  function vardefCont(type) {
	    if (type == ",") return cont(vardef);
	  }
	  function maybeelse(type, value) {
	    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
	  }
	  function forspec(type, value) {
	    if (value == "await") return cont(forspec);
	    if (type == "(") return cont(pushlex(")"), forspec1, poplex);
	  }
	  function forspec1(type) {
	    if (type == "var") return cont(vardef, forspec2);
	    if (type == "variable") return cont(forspec2);
	    return pass(forspec2)
	  }
	  function forspec2(type, value) {
	    if (type == ")") return cont()
	    if (type == ";") return cont(forspec2)
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
	    return pass(expression, forspec2)
	  }
	  function functiondef(type, value) {
	    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
	    if (type == "variable") {register(value); return cont(functiondef);}
	    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
	    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
	  }
	  function functiondecl(type, value) {
	    if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
	    if (type == "variable") {register(value); return cont(functiondecl);}
	    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
	    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
	  }
	  function typename(type, value) {
	    if (type == "keyword" || type == "variable") {
	      cx.marked = "type";
	      return cont(typename)
	    } else if (value == "<") {
	      return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
	    }
	  }
	  function funarg(type, value) {
	    if (value == "@") cont(expression, funarg);
	    if (type == "spread") return cont(funarg);
	    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
	    if (isTS && type == "this") return cont(maybetype, maybeAssign)
	    return pass(pattern, maybetype, maybeAssign);
	  }
	  function classExpression(type, value) {
	    // Class expressions may have an optional name.
	    if (type == "variable") return className(type, value);
	    return classNameAfter(type, value);
	  }
	  function className(type, value) {
	    if (type == "variable") {register(value); return cont(classNameAfter);}
	  }
	  function classNameAfter(type, value) {
	    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
	    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
	      if (value == "implements") cx.marked = "keyword";
	      return cont(isTS ? typeexpr : expression, classNameAfter);
	    }
	    if (type == "{") return cont(pushlex("}"), classBody, poplex);
	  }
	  function classBody(type, value) {
	    if (type == "async" ||
	        (type == "variable" &&
	         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
	         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
	      cx.marked = "keyword";
	      return cont(classBody);
	    }
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      return cont(classfield, classBody);
	    }
	    if (type == "number" || type == "string") return cont(classfield, classBody);
	    if (type == "[")
	      return cont(expression, maybetype, expect("]"), classfield, classBody)
	    if (value == "*") {
	      cx.marked = "keyword";
	      return cont(classBody);
	    }
	    if (isTS && type == "(") return pass(functiondecl, classBody)
	    if (type == ";" || type == ",") return cont(classBody);
	    if (type == "}") return cont();
	    if (value == "@") return cont(expression, classBody)
	  }
	  function classfield(type, value) {
	    if (value == "?") return cont(classfield)
	    if (type == ":") return cont(typeexpr, maybeAssign)
	    if (value == "=") return cont(expressionNoComma)
	    var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
	    return pass(isInterface ? functiondecl : functiondef)
	  }
	  function afterExport(type, value) {
	    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
	    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
	    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
	    return pass(statement);
	  }
	  function exportField(type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
	    if (type == "variable") return pass(expressionNoComma, exportField);
	  }
	  function afterImport(type) {
	    if (type == "string") return cont();
	    if (type == "(") return pass(expression);
	    return pass(importSpec, maybeMoreImports, maybeFrom);
	  }
	  function importSpec(type, value) {
	    if (type == "{") return contCommasep(importSpec, "}");
	    if (type == "variable") register(value);
	    if (value == "*") cx.marked = "keyword";
	    return cont(maybeAs);
	  }
	  function maybeMoreImports(type) {
	    if (type == ",") return cont(importSpec, maybeMoreImports)
	  }
	  function maybeAs(_type, value) {
	    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
	  }
	  function maybeFrom(_type, value) {
	    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
	  }
	  function arrayLiteral(type) {
	    if (type == "]") return cont();
	    return pass(commasep(expressionNoComma, "]"));
	  }
	  function enumdef() {
	    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
	  }
	  function enummember() {
	    return pass(pattern, maybeAssign);
	  }

	  function isContinuedStatement(state, textAfter) {
	    return state.lastType == "operator" || state.lastType == "," ||
	      isOperatorChar.test(textAfter.charAt(0)) ||
	      /[,.]/.test(textAfter.charAt(0));
	  }

	  function expressionAllowed(stream, state, backUp) {
	    return state.tokenize == tokenBase &&
	      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
	      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
	  }

	  // Interface

	  return {
	    startState: function(basecolumn) {
	      var state = {
	        tokenize: tokenBase,
	        lastType: "sof",
	        cc: [],
	        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
	        localVars: parserConfig.localVars,
	        context: parserConfig.localVars && new Context(null, null, false),
	        indented: basecolumn || 0
	      };
	      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
	        state.globalVars = parserConfig.globalVars;
	      return state;
	    },

	    token: function(stream, state) {
	      if (stream.sol()) {
	        if (!state.lexical.hasOwnProperty("align"))
	          state.lexical.align = false;
	        state.indented = stream.indentation();
	        findFatArrow(stream, state);
	      }
	      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
	      var style = state.tokenize(stream, state);
	      if (type == "comment") return style;
	      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
	      return parseJS(state, style, type, content, stream);
	    },

	    indent: function(state, textAfter) {
	      if (state.tokenize == tokenComment) return CodeMirror.Pass;
	      if (state.tokenize != tokenBase) return 0;
	      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
	      // Kludge to prevent 'maybelse' from blocking lexical scope pops
	      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
	        var c = state.cc[i];
	        if (c == poplex) lexical = lexical.prev;
	        else if (c != maybeelse) break;
	      }
	      while ((lexical.type == "stat" || lexical.type == "form") &&
	             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
	                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
	                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
	        lexical = lexical.prev;
	      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
	        lexical = lexical.prev;
	      var type = lexical.type, closing = firstChar == type;

	      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
	      else if (type == "form" && firstChar == "{") return lexical.indented;
	      else if (type == "form") return lexical.indented + indentUnit;
	      else if (type == "stat")
	        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
	      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
	        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
	      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
	      else return lexical.indented + (closing ? 0 : indentUnit);
	    },

	    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
	    blockCommentStart: jsonMode ? null : "/*",
	    blockCommentEnd: jsonMode ? null : "*/",
	    blockCommentContinue: jsonMode ? null : " * ",
	    lineComment: jsonMode ? null : "//",
	    fold: "brace",
	    closeBrackets: "()[]{}''\"\"``",

	    helperType: jsonMode ? "json" : "javascript",
	    jsonldMode: jsonldMode,
	    jsonMode: jsonMode,

	    expressionAllowed: expressionAllowed,

	    skipExpression: function(state) {
	      var top = state.cc[state.cc.length - 1];
	      if (top == expression || top == expressionNoComma) state.cc.pop();
	    }
	  };
	});

	CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

	CodeMirror.defineMIME("text/javascript", "javascript");
	CodeMirror.defineMIME("text/ecmascript", "javascript");
	CodeMirror.defineMIME("application/javascript", "javascript");
	CodeMirror.defineMIME("application/x-javascript", "javascript");
	CodeMirror.defineMIME("application/ecmascript", "javascript");
	CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
	CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
	CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

	});
	});

	var xml = createCommonjsModule(function (module, exports) {
	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE

	(function(mod) {
	  mod(codemirror);
	})(function(CodeMirror) {

	var htmlConfig = {
	  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
	                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
	                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
	                    'track': true, 'wbr': true, 'menuitem': true},
	  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
	                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
	                     'th': true, 'tr': true},
	  contextGrabbers: {
	    'dd': {'dd': true, 'dt': true},
	    'dt': {'dd': true, 'dt': true},
	    'li': {'li': true},
	    'option': {'option': true, 'optgroup': true},
	    'optgroup': {'optgroup': true},
	    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
	          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
	          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
	          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
	          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
	    'rp': {'rp': true, 'rt': true},
	    'rt': {'rp': true, 'rt': true},
	    'tbody': {'tbody': true, 'tfoot': true},
	    'td': {'td': true, 'th': true},
	    'tfoot': {'tbody': true},
	    'th': {'td': true, 'th': true},
	    'thead': {'tbody': true, 'tfoot': true},
	    'tr': {'tr': true}
	  },
	  doNotIndent: {"pre": true},
	  allowUnquoted: true,
	  allowMissing: true,
	  caseFold: true
	};

	var xmlConfig = {
	  autoSelfClosers: {},
	  implicitlyClosed: {},
	  contextGrabbers: {},
	  doNotIndent: {},
	  allowUnquoted: false,
	  allowMissing: false,
	  allowMissingTagName: false,
	  caseFold: false
	};

	CodeMirror.defineMode("xml", function(editorConf, config_) {
	  var indentUnit = editorConf.indentUnit;
	  var config = {};
	  var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
	  for (var prop in defaults) config[prop] = defaults[prop];
	  for (var prop in config_) config[prop] = config_[prop];

	  // Return variables for tokenizers
	  var type, setStyle;

	  function inText(stream, state) {
	    function chain(parser) {
	      state.tokenize = parser;
	      return parser(stream, state);
	    }

	    var ch = stream.next();
	    if (ch == "<") {
	      if (stream.eat("!")) {
	        if (stream.eat("[")) {
	          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
	          else return null;
	        } else if (stream.match("--")) {
	          return chain(inBlock("comment", "-->"));
	        } else if (stream.match("DOCTYPE", true, true)) {
	          stream.eatWhile(/[\w\._\-]/);
	          return chain(doctype(1));
	        } else {
	          return null;
	        }
	      } else if (stream.eat("?")) {
	        stream.eatWhile(/[\w\._\-]/);
	        state.tokenize = inBlock("meta", "?>");
	        return "meta";
	      } else {
	        type = stream.eat("/") ? "closeTag" : "openTag";
	        state.tokenize = inTag;
	        return "tag bracket";
	      }
	    } else if (ch == "&") {
	      var ok;
	      if (stream.eat("#")) {
	        if (stream.eat("x")) {
	          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
	        } else {
	          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
	        }
	      } else {
	        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
	      }
	      return ok ? "atom" : "error";
	    } else {
	      stream.eatWhile(/[^&<]/);
	      return null;
	    }
	  }
	  inText.isInText = true;

	  function inTag(stream, state) {
	    var ch = stream.next();
	    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
	      state.tokenize = inText;
	      type = ch == ">" ? "endTag" : "selfcloseTag";
	      return "tag bracket";
	    } else if (ch == "=") {
	      type = "equals";
	      return null;
	    } else if (ch == "<") {
	      state.tokenize = inText;
	      state.state = baseState;
	      state.tagName = state.tagStart = null;
	      var next = state.tokenize(stream, state);
	      return next ? next + " tag error" : "tag error";
	    } else if (/[\'\"]/.test(ch)) {
	      state.tokenize = inAttribute(ch);
	      state.stringStartCol = stream.column();
	      return state.tokenize(stream, state);
	    } else {
	      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
	      return "word";
	    }
	  }

	  function inAttribute(quote) {
	    var closure = function(stream, state) {
	      while (!stream.eol()) {
	        if (stream.next() == quote) {
	          state.tokenize = inTag;
	          break;
	        }
	      }
	      return "string";
	    };
	    closure.isInAttribute = true;
	    return closure;
	  }

	  function inBlock(style, terminator) {
	    return function(stream, state) {
	      while (!stream.eol()) {
	        if (stream.match(terminator)) {
	          state.tokenize = inText;
	          break;
	        }
	        stream.next();
	      }
	      return style;
	    }
	  }

	  function doctype(depth) {
	    return function(stream, state) {
	      var ch;
	      while ((ch = stream.next()) != null) {
	        if (ch == "<") {
	          state.tokenize = doctype(depth + 1);
	          return state.tokenize(stream, state);
	        } else if (ch == ">") {
	          if (depth == 1) {
	            state.tokenize = inText;
	            break;
	          } else {
	            state.tokenize = doctype(depth - 1);
	            return state.tokenize(stream, state);
	          }
	        }
	      }
	      return "meta";
	    };
	  }

	  function Context(state, tagName, startOfLine) {
	    this.prev = state.context;
	    this.tagName = tagName;
	    this.indent = state.indented;
	    this.startOfLine = startOfLine;
	    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
	      this.noIndent = true;
	  }
	  function popContext(state) {
	    if (state.context) state.context = state.context.prev;
	  }
	  function maybePopContext(state, nextTagName) {
	    var parentTagName;
	    while (true) {
	      if (!state.context) {
	        return;
	      }
	      parentTagName = state.context.tagName;
	      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
	          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
	        return;
	      }
	      popContext(state);
	    }
	  }

	  function baseState(type, stream, state) {
	    if (type == "openTag") {
	      state.tagStart = stream.column();
	      return tagNameState;
	    } else if (type == "closeTag") {
	      return closeTagNameState;
	    } else {
	      return baseState;
	    }
	  }
	  function tagNameState(type, stream, state) {
	    if (type == "word") {
	      state.tagName = stream.current();
	      setStyle = "tag";
	      return attrState;
	    } else if (config.allowMissingTagName && type == "endTag") {
	      setStyle = "tag bracket";
	      return attrState(type, stream, state);
	    } else {
	      setStyle = "error";
	      return tagNameState;
	    }
	  }
	  function closeTagNameState(type, stream, state) {
	    if (type == "word") {
	      var tagName = stream.current();
	      if (state.context && state.context.tagName != tagName &&
	          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
	        popContext(state);
	      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
	        setStyle = "tag";
	        return closeState;
	      } else {
	        setStyle = "tag error";
	        return closeStateErr;
	      }
	    } else if (config.allowMissingTagName && type == "endTag") {
	      setStyle = "tag bracket";
	      return closeState(type, stream, state);
	    } else {
	      setStyle = "error";
	      return closeStateErr;
	    }
	  }

	  function closeState(type, _stream, state) {
	    if (type != "endTag") {
	      setStyle = "error";
	      return closeState;
	    }
	    popContext(state);
	    return baseState;
	  }
	  function closeStateErr(type, stream, state) {
	    setStyle = "error";
	    return closeState(type, stream, state);
	  }

	  function attrState(type, _stream, state) {
	    if (type == "word") {
	      setStyle = "attribute";
	      return attrEqState;
	    } else if (type == "endTag" || type == "selfcloseTag") {
	      var tagName = state.tagName, tagStart = state.tagStart;
	      state.tagName = state.tagStart = null;
	      if (type == "selfcloseTag" ||
	          config.autoSelfClosers.hasOwnProperty(tagName)) {
	        maybePopContext(state, tagName);
	      } else {
	        maybePopContext(state, tagName);
	        state.context = new Context(state, tagName, tagStart == state.indented);
	      }
	      return baseState;
	    }
	    setStyle = "error";
	    return attrState;
	  }
	  function attrEqState(type, stream, state) {
	    if (type == "equals") return attrValueState;
	    if (!config.allowMissing) setStyle = "error";
	    return attrState(type, stream, state);
	  }
	  function attrValueState(type, stream, state) {
	    if (type == "string") return attrContinuedState;
	    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
	    setStyle = "error";
	    return attrState(type, stream, state);
	  }
	  function attrContinuedState(type, stream, state) {
	    if (type == "string") return attrContinuedState;
	    return attrState(type, stream, state);
	  }

	  return {
	    startState: function(baseIndent) {
	      var state = {tokenize: inText,
	                   state: baseState,
	                   indented: baseIndent || 0,
	                   tagName: null, tagStart: null,
	                   context: null};
	      if (baseIndent != null) state.baseIndent = baseIndent;
	      return state
	    },

	    token: function(stream, state) {
	      if (!state.tagName && stream.sol())
	        state.indented = stream.indentation();

	      if (stream.eatSpace()) return null;
	      type = null;
	      var style = state.tokenize(stream, state);
	      if ((style || type) && style != "comment") {
	        setStyle = null;
	        state.state = state.state(type || style, stream, state);
	        if (setStyle)
	          style = setStyle == "error" ? style + " error" : setStyle;
	      }
	      return style;
	    },

	    indent: function(state, textAfter, fullLine) {
	      var context = state.context;
	      // Indent multi-line strings (e.g. css).
	      if (state.tokenize.isInAttribute) {
	        if (state.tagStart == state.indented)
	          return state.stringStartCol + 1;
	        else
	          return state.indented + indentUnit;
	      }
	      if (context && context.noIndent) return CodeMirror.Pass;
	      if (state.tokenize != inTag && state.tokenize != inText)
	        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
	      // Indent the starts of attribute names.
	      if (state.tagName) {
	        if (config.multilineTagIndentPastTag !== false)
	          return state.tagStart + state.tagName.length + 2;
	        else
	          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
	      }
	      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
	      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
	      if (tagAfter && tagAfter[1]) { // Closing tag spotted
	        while (context) {
	          if (context.tagName == tagAfter[2]) {
	            context = context.prev;
	            break;
	          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
	            context = context.prev;
	          } else {
	            break;
	          }
	        }
	      } else if (tagAfter) { // Opening tag spotted
	        while (context) {
	          var grabbers = config.contextGrabbers[context.tagName];
	          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
	            context = context.prev;
	          else
	            break;
	        }
	      }
	      while (context && context.prev && !context.startOfLine)
	        context = context.prev;
	      if (context) return context.indent + indentUnit;
	      else return state.baseIndent || 0;
	    },

	    electricInput: /<\/[\s\w:]+>$/,
	    blockCommentStart: "<!--",
	    blockCommentEnd: "-->",

	    configuration: config.htmlMode ? "html" : "xml",
	    helperType: config.htmlMode ? "html" : "xml",

	    skipAttribute: function(state) {
	      if (state.state == attrValueState)
	        state.state = attrState;
	    },

	    xmlCurrentTag: function(state) {
	      return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null
	    },

	    xmlCurrentContext: function(state) {
	      var context = [];
	      for (var cx = state.context; cx; cx = cx.prev)
	        if (cx.tagName) context.push(cx.tagName);
	      return context.reverse()
	    }
	  };
	});

	CodeMirror.defineMIME("text/xml", "xml");
	CodeMirror.defineMIME("application/xml", "xml");
	if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
	  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

	});
	});

	var css$1 = createCommonjsModule(function (module, exports) {
	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE

	(function(mod) {
	  mod(codemirror);
	})(function(CodeMirror) {

	CodeMirror.defineMode("css", function(config, parserConfig) {
	  var inline = parserConfig.inline;
	  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

	  var indentUnit = config.indentUnit,
	      tokenHooks = parserConfig.tokenHooks,
	      documentTypes = parserConfig.documentTypes || {},
	      mediaTypes = parserConfig.mediaTypes || {},
	      mediaFeatures = parserConfig.mediaFeatures || {},
	      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
	      propertyKeywords = parserConfig.propertyKeywords || {},
	      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
	      fontProperties = parserConfig.fontProperties || {},
	      counterDescriptors = parserConfig.counterDescriptors || {},
	      colorKeywords = parserConfig.colorKeywords || {},
	      valueKeywords = parserConfig.valueKeywords || {},
	      allowNested = parserConfig.allowNested,
	      lineComment = parserConfig.lineComment,
	      supportsAtComponent = parserConfig.supportsAtComponent === true;

	  var type, override;
	  function ret(style, tp) { type = tp; return style; }

	  // Tokenizers

	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (tokenHooks[ch]) {
	      var result = tokenHooks[ch](stream, state);
	      if (result !== false) return result;
	    }
	    if (ch == "@") {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("def", stream.current());
	    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
	      return ret(null, "compare");
	    } else if (ch == "\"" || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "#") {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("atom", "hash");
	    } else if (ch == "!") {
	      stream.match(/^\s*\w*/);
	      return ret("keyword", "important");
	    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
	      stream.eatWhile(/[\w.%]/);
	      return ret("number", "unit");
	    } else if (ch === "-") {
	      if (/[\d.]/.test(stream.peek())) {
	        stream.eatWhile(/[\w.%]/);
	        return ret("number", "unit");
	      } else if (stream.match(/^-[\w\\\-]*/)) {
	        stream.eatWhile(/[\w\\\-]/);
	        if (stream.match(/^\s*:/, false))
	          return ret("variable-2", "variable-definition");
	        return ret("variable-2", "variable");
	      } else if (stream.match(/^\w+-/)) {
	        return ret("meta", "meta");
	      }
	    } else if (/[,+>*\/]/.test(ch)) {
	      return ret(null, "select-op");
	    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
	      return ret("qualifier", "qualifier");
	    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
	      return ret(null, ch);
	    } else if (stream.match(/[\w-.]+(?=\()/)) {
	      if (/^(url(-prefix)?|domain|regexp)$/.test(stream.current().toLowerCase())) {
	        state.tokenize = tokenParenthesized;
	      }
	      return ret("variable callee", "variable");
	    } else if (/[\w\\\-]/.test(ch)) {
	      stream.eatWhile(/[\w\\\-]/);
	      return ret("property", "word");
	    } else {
	      return ret(null, null);
	    }
	  }

	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, ch;
	      while ((ch = stream.next()) != null) {
	        if (ch == quote && !escaped) {
	          if (quote == ")") stream.backUp(1);
	          break;
	        }
	        escaped = !escaped && ch == "\\";
	      }
	      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
	      return ret("string", "string");
	    };
	  }

	  function tokenParenthesized(stream, state) {
	    stream.next(); // Must be '('
	    if (!stream.match(/\s*[\"\')]/, false))
	      state.tokenize = tokenString(")");
	    else
	      state.tokenize = null;
	    return ret(null, "(");
	  }

	  // Context management

	  function Context(type, indent, prev) {
	    this.type = type;
	    this.indent = indent;
	    this.prev = prev;
	  }

	  function pushContext(state, stream, type, indent) {
	    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
	    return type;
	  }

	  function popContext(state) {
	    if (state.context.prev)
	      state.context = state.context.prev;
	    return state.context.type;
	  }

	  function pass(type, stream, state) {
	    return states[state.context.type](type, stream, state);
	  }
	  function popAndPass(type, stream, state, n) {
	    for (var i = n || 1; i > 0; i--)
	      state.context = state.context.prev;
	    return pass(type, stream, state);
	  }

	  // Parser

	  function wordAsValue(stream) {
	    var word = stream.current().toLowerCase();
	    if (valueKeywords.hasOwnProperty(word))
	      override = "atom";
	    else if (colorKeywords.hasOwnProperty(word))
	      override = "keyword";
	    else
	      override = "variable";
	  }

	  var states = {};

	  states.top = function(type, stream, state) {
	    if (type == "{") {
	      return pushContext(state, stream, "block");
	    } else if (type == "}" && state.context.prev) {
	      return popContext(state);
	    } else if (supportsAtComponent && /@component/i.test(type)) {
	      return pushContext(state, stream, "atComponentBlock");
	    } else if (/^@(-moz-)?document$/i.test(type)) {
	      return pushContext(state, stream, "documentTypes");
	    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
	      return pushContext(state, stream, "atBlock");
	    } else if (/^@(font-face|counter-style)/i.test(type)) {
	      state.stateArg = type;
	      return "restricted_atBlock_before";
	    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
	      return "keyframes";
	    } else if (type && type.charAt(0) == "@") {
	      return pushContext(state, stream, "at");
	    } else if (type == "hash") {
	      override = "builtin";
	    } else if (type == "word") {
	      override = "tag";
	    } else if (type == "variable-definition") {
	      return "maybeprop";
	    } else if (type == "interpolation") {
	      return pushContext(state, stream, "interpolation");
	    } else if (type == ":") {
	      return "pseudo";
	    } else if (allowNested && type == "(") {
	      return pushContext(state, stream, "parens");
	    }
	    return state.context.type;
	  };

	  states.block = function(type, stream, state) {
	    if (type == "word") {
	      var word = stream.current().toLowerCase();
	      if (propertyKeywords.hasOwnProperty(word)) {
	        override = "property";
	        return "maybeprop";
	      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
	        override = "string-2";
	        return "maybeprop";
	      } else if (allowNested) {
	        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
	        return "block";
	      } else {
	        override += " error";
	        return "maybeprop";
	      }
	    } else if (type == "meta") {
	      return "block";
	    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
	      override = "error";
	      return "block";
	    } else {
	      return states.top(type, stream, state);
	    }
	  };

	  states.maybeprop = function(type, stream, state) {
	    if (type == ":") return pushContext(state, stream, "prop");
	    return pass(type, stream, state);
	  };

	  states.prop = function(type, stream, state) {
	    if (type == ";") return popContext(state);
	    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
	    if (type == "}" || type == "{") return popAndPass(type, stream, state);
	    if (type == "(") return pushContext(state, stream, "parens");

	    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
	      override += " error";
	    } else if (type == "word") {
	      wordAsValue(stream);
	    } else if (type == "interpolation") {
	      return pushContext(state, stream, "interpolation");
	    }
	    return "prop";
	  };

	  states.propBlock = function(type, _stream, state) {
	    if (type == "}") return popContext(state);
	    if (type == "word") { override = "property"; return "maybeprop"; }
	    return state.context.type;
	  };

	  states.parens = function(type, stream, state) {
	    if (type == "{" || type == "}") return popAndPass(type, stream, state);
	    if (type == ")") return popContext(state);
	    if (type == "(") return pushContext(state, stream, "parens");
	    if (type == "interpolation") return pushContext(state, stream, "interpolation");
	    if (type == "word") wordAsValue(stream);
	    return "parens";
	  };

	  states.pseudo = function(type, stream, state) {
	    if (type == "meta") return "pseudo";

	    if (type == "word") {
	      override = "variable-3";
	      return state.context.type;
	    }
	    return pass(type, stream, state);
	  };

	  states.documentTypes = function(type, stream, state) {
	    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
	      override = "tag";
	      return state.context.type;
	    } else {
	      return states.atBlock(type, stream, state);
	    }
	  };

	  states.atBlock = function(type, stream, state) {
	    if (type == "(") return pushContext(state, stream, "atBlock_parens");
	    if (type == "}" || type == ";") return popAndPass(type, stream, state);
	    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

	    if (type == "interpolation") return pushContext(state, stream, "interpolation");

	    if (type == "word") {
	      var word = stream.current().toLowerCase();
	      if (word == "only" || word == "not" || word == "and" || word == "or")
	        override = "keyword";
	      else if (mediaTypes.hasOwnProperty(word))
	        override = "attribute";
	      else if (mediaFeatures.hasOwnProperty(word))
	        override = "property";
	      else if (mediaValueKeywords.hasOwnProperty(word))
	        override = "keyword";
	      else if (propertyKeywords.hasOwnProperty(word))
	        override = "property";
	      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
	        override = "string-2";
	      else if (valueKeywords.hasOwnProperty(word))
	        override = "atom";
	      else if (colorKeywords.hasOwnProperty(word))
	        override = "keyword";
	      else
	        override = "error";
	    }
	    return state.context.type;
	  };

	  states.atComponentBlock = function(type, stream, state) {
	    if (type == "}")
	      return popAndPass(type, stream, state);
	    if (type == "{")
	      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
	    if (type == "word")
	      override = "error";
	    return state.context.type;
	  };

	  states.atBlock_parens = function(type, stream, state) {
	    if (type == ")") return popContext(state);
	    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
	    return states.atBlock(type, stream, state);
	  };

	  states.restricted_atBlock_before = function(type, stream, state) {
	    if (type == "{")
	      return pushContext(state, stream, "restricted_atBlock");
	    if (type == "word" && state.stateArg == "@counter-style") {
	      override = "variable";
	      return "restricted_atBlock_before";
	    }
	    return pass(type, stream, state);
	  };

	  states.restricted_atBlock = function(type, stream, state) {
	    if (type == "}") {
	      state.stateArg = null;
	      return popContext(state);
	    }
	    if (type == "word") {
	      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
	          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
	        override = "error";
	      else
	        override = "property";
	      return "maybeprop";
	    }
	    return "restricted_atBlock";
	  };

	  states.keyframes = function(type, stream, state) {
	    if (type == "word") { override = "variable"; return "keyframes"; }
	    if (type == "{") return pushContext(state, stream, "top");
	    return pass(type, stream, state);
	  };

	  states.at = function(type, stream, state) {
	    if (type == ";") return popContext(state);
	    if (type == "{" || type == "}") return popAndPass(type, stream, state);
	    if (type == "word") override = "tag";
	    else if (type == "hash") override = "builtin";
	    return "at";
	  };

	  states.interpolation = function(type, stream, state) {
	    if (type == "}") return popContext(state);
	    if (type == "{" || type == ";") return popAndPass(type, stream, state);
	    if (type == "word") override = "variable";
	    else if (type != "variable" && type != "(" && type != ")") override = "error";
	    return "interpolation";
	  };

	  return {
	    startState: function(base) {
	      return {tokenize: null,
	              state: inline ? "block" : "top",
	              stateArg: null,
	              context: new Context(inline ? "block" : "top", base || 0, null)};
	    },

	    token: function(stream, state) {
	      if (!state.tokenize && stream.eatSpace()) return null;
	      var style = (state.tokenize || tokenBase)(stream, state);
	      if (style && typeof style == "object") {
	        type = style[1];
	        style = style[0];
	      }
	      override = style;
	      if (type != "comment")
	        state.state = states[state.state](type, stream, state);
	      return override;
	    },

	    indent: function(state, textAfter) {
	      var cx = state.context, ch = textAfter && textAfter.charAt(0);
	      var indent = cx.indent;
	      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
	      if (cx.prev) {
	        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
	                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
	          // Resume indentation from parent context.
	          cx = cx.prev;
	          indent = cx.indent;
	        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
	            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
	          // Dedent relative to current context.
	          indent = Math.max(0, cx.indent - indentUnit);
	        }
	      }
	      return indent;
	    },

	    electricChars: "}",
	    blockCommentStart: "/*",
	    blockCommentEnd: "*/",
	    blockCommentContinue: " * ",
	    lineComment: lineComment,
	    fold: "brace"
	  };
	});

	  function keySet(array) {
	    var keys = {};
	    for (var i = 0; i < array.length; ++i) {
	      keys[array[i].toLowerCase()] = true;
	    }
	    return keys;
	  }

	  var documentTypes_ = [
	    "domain", "regexp", "url", "url-prefix"
	  ], documentTypes = keySet(documentTypes_);

	  var mediaTypes_ = [
	    "all", "aural", "braille", "handheld", "print", "projection", "screen",
	    "tty", "tv", "embossed"
	  ], mediaTypes = keySet(mediaTypes_);

	  var mediaFeatures_ = [
	    "width", "min-width", "max-width", "height", "min-height", "max-height",
	    "device-width", "min-device-width", "max-device-width", "device-height",
	    "min-device-height", "max-device-height", "aspect-ratio",
	    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
	    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
	    "max-color", "color-index", "min-color-index", "max-color-index",
	    "monochrome", "min-monochrome", "max-monochrome", "resolution",
	    "min-resolution", "max-resolution", "scan", "grid", "orientation",
	    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
	    "pointer", "any-pointer", "hover", "any-hover"
	  ], mediaFeatures = keySet(mediaFeatures_);

	  var mediaValueKeywords_ = [
	    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
	    "interlace", "progressive"
	  ], mediaValueKeywords = keySet(mediaValueKeywords_);

	  var propertyKeywords_ = [
	    "align-content", "align-items", "align-self", "alignment-adjust",
	    "alignment-baseline", "anchor-point", "animation", "animation-delay",
	    "animation-direction", "animation-duration", "animation-fill-mode",
	    "animation-iteration-count", "animation-name", "animation-play-state",
	    "animation-timing-function", "appearance", "azimuth", "backdrop-filter",
	    "backface-visibility", "background", "background-attachment",
	    "background-blend-mode", "background-clip", "background-color",
	    "background-image", "background-origin", "background-position",
	    "background-position-x", "background-position-y", "background-repeat",
	    "background-size", "baseline-shift", "binding", "bleed", "block-size",
	    "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target",
	    "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius",
	    "border-bottom-right-radius", "border-bottom-style", "border-bottom-width",
	    "border-collapse", "border-color", "border-image", "border-image-outset",
	    "border-image-repeat", "border-image-slice", "border-image-source",
	    "border-image-width", "border-left", "border-left-color", "border-left-style",
	    "border-left-width", "border-radius", "border-right", "border-right-color",
	    "border-right-style", "border-right-width", "border-spacing", "border-style",
	    "border-top", "border-top-color", "border-top-left-radius",
	    "border-top-right-radius", "border-top-style", "border-top-width",
	    "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing",
	    "break-after", "break-before", "break-inside", "caption-side", "caret-color",
	    "clear", "clip", "color", "color-profile", "column-count", "column-fill",
	    "column-gap", "column-rule", "column-rule-color", "column-rule-style",
	    "column-rule-width", "column-span", "column-width", "columns", "contain",
	    "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after",
	    "cue-before", "cursor", "direction", "display", "dominant-baseline",
	    "drop-initial-after-adjust", "drop-initial-after-align",
	    "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size",
	    "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position",
	    "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow",
	    "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into",
	    "font", "font-family", "font-feature-settings", "font-kerning",
	    "font-language-override", "font-optical-sizing", "font-size",
	    "font-size-adjust", "font-stretch", "font-style", "font-synthesis",
	    "font-variant", "font-variant-alternates", "font-variant-caps",
	    "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric",
	    "font-variant-position", "font-variation-settings", "font-weight", "gap",
	    "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows",
	    "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start",
	    "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start",
	    "grid-template", "grid-template-areas", "grid-template-columns",
	    "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon",
	    "image-orientation", "image-rendering", "image-resolution", "inline-box-align",
	    "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline",
	    "inset-inline-end", "inset-inline-start", "isolation", "justify-content",
	    "justify-items", "justify-self", "left", "letter-spacing", "line-break",
	    "line-height", "line-height-step", "line-stacking", "line-stacking-ruby",
	    "line-stacking-shift", "line-stacking-strategy", "list-style",
	    "list-style-image", "list-style-position", "list-style-type", "margin",
	    "margin-bottom", "margin-left", "margin-right", "margin-top", "marks",
	    "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed",
	    "marquee-style", "max-block-size", "max-height", "max-inline-size",
	    "max-width", "min-block-size", "min-height", "min-inline-size", "min-width",
	    "mix-blend-mode", "move-to", "nav-down", "nav-index", "nav-left", "nav-right",
	    "nav-up", "object-fit", "object-position", "offset", "offset-anchor",
	    "offset-distance", "offset-path", "offset-position", "offset-rotate",
	    "opacity", "order", "orphans", "outline", "outline-color", "outline-offset",
	    "outline-style", "outline-width", "overflow", "overflow-style",
	    "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom",
	    "padding-left", "padding-right", "padding-top", "page", "page-break-after",
	    "page-break-before", "page-break-inside", "page-policy", "pause",
	    "pause-after", "pause-before", "perspective", "perspective-origin", "pitch",
	    "pitch-range", "place-content", "place-items", "place-self", "play-during",
	    "position", "presentation-level", "punctuation-trim", "quotes",
	    "region-break-after", "region-break-before", "region-break-inside",
	    "region-fragment", "rendering-intent", "resize", "rest", "rest-after",
	    "rest-before", "richness", "right", "rotate", "rotation", "rotation-point",
	    "row-gap", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span",
	    "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block",
	    "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom",
	    "scroll-margin-inline", "scroll-margin-inline-end",
	    "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right",
	    "scroll-margin-top", "scroll-padding", "scroll-padding-block",
	    "scroll-padding-block-end", "scroll-padding-block-start",
	    "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end",
	    "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right",
	    "scroll-padding-top", "scroll-snap-align", "scroll-snap-type",
	    "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside",
	    "size", "speak", "speak-as", "speak-header", "speak-numeral",
	    "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size",
	    "table-layout", "target", "target-name", "target-new", "target-position",
	    "text-align", "text-align-last", "text-combine-upright", "text-decoration",
	    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
	    "text-decoration-skip-ink", "text-decoration-style", "text-emphasis",
	    "text-emphasis-color", "text-emphasis-position", "text-emphasis-style",
	    "text-height", "text-indent", "text-justify", "text-orientation",
	    "text-outline", "text-overflow", "text-rendering", "text-shadow",
	    "text-size-adjust", "text-space-collapse", "text-transform",
	    "text-underline-position", "text-wrap", "top", "transform", "transform-origin",
	    "transform-style", "transition", "transition-delay", "transition-duration",
	    "transition-property", "transition-timing-function", "translate",
	    "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance",
	    "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate",
	    "voice-stress", "voice-volume", "volume", "white-space", "widows", "width",
	    "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index",
	    // SVG-specific
	    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
	    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
	    "color-interpolation", "color-interpolation-filters",
	    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
	    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
	    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
	    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
	    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
	    "glyph-orientation-vertical", "text-anchor", "writing-mode"
	  ], propertyKeywords = keySet(propertyKeywords_);

	  var nonStandardPropertyKeywords_ = [
	    "border-block", "border-block-color", "border-block-end",
	    "border-block-end-color", "border-block-end-style", "border-block-end-width",
	    "border-block-start", "border-block-start-color", "border-block-start-style",
	    "border-block-start-width", "border-block-style", "border-block-width",
	    "border-inline", "border-inline-color", "border-inline-end",
	    "border-inline-end-color", "border-inline-end-style",
	    "border-inline-end-width", "border-inline-start", "border-inline-start-color",
	    "border-inline-start-style", "border-inline-start-width",
	    "border-inline-style", "border-inline-width", "margin-block",
	    "margin-block-end", "margin-block-start", "margin-inline", "margin-inline-end",
	    "margin-inline-start", "padding-block", "padding-block-end",
	    "padding-block-start", "padding-inline", "padding-inline-end",
	    "padding-inline-start", "scroll-snap-stop", "scrollbar-3d-light-color",
	    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
	    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
	    "scrollbar-track-color", "searchfield-cancel-button", "searchfield-decoration",
	    "searchfield-results-button", "searchfield-results-decoration", "shape-inside", "zoom"
	  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

	  var fontProperties_ = [
	    "font-display", "font-family", "src", "unicode-range", "font-variant",
	     "font-feature-settings", "font-stretch", "font-weight", "font-style"
	  ], fontProperties = keySet(fontProperties_);

	  var counterDescriptors_ = [
	    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
	    "speak-as", "suffix", "symbols", "system"
	  ], counterDescriptors = keySet(counterDescriptors_);

	  var colorKeywords_ = [
	    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
	    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
	    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
	    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
	    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
	    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
	    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
	    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
	    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
	    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
	    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
	    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
	    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
	    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
	    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
	    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
	    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
	    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
	    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
	    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
	    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
	    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
	    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
	    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
	    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
	    "whitesmoke", "yellow", "yellowgreen"
	  ], colorKeywords = keySet(colorKeywords_);

	  var valueKeywords_ = [
	    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
	    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
	    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
	    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
	    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
	    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
	    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
	    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
	    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
	    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
	    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
	    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
	    "compact", "condensed", "contain", "content", "contents",
	    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
	    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
	    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
	    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
	    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
	    "dot-dash", "dot-dot-dash",
	    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
	    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
	    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
	    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
	    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
	    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
	    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
	    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
	    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
	    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
	    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
	    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
	    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
	    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
	    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
	    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
	    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
	    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
	    "katakana", "katakana-iroha", "keep-all", "khmer",
	    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
	    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
	    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
	    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
	    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
	    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
	    "media-controls-background", "media-current-time-display",
	    "media-fullscreen-button", "media-mute-button", "media-play-button",
	    "media-return-to-realtime-button", "media-rewind-button",
	    "media-seek-back-button", "media-seek-forward-button", "media-slider",
	    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
	    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
	    "menu", "menulist", "menulist-button", "menulist-text",
	    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
	    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
	    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
	    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
	    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
	    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
	    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
	    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
	    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
	    "progress", "push-button", "radial-gradient", "radio", "read-only",
	    "read-write", "read-write-plaintext-only", "rectangle", "region",
	    "relative", "repeat", "repeating-linear-gradient",
	    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
	    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
	    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
	    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
	    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
	    "searchfield-cancel-button", "searchfield-decoration",
	    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
	    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
	    "simp-chinese-formal", "simp-chinese-informal", "single",
	    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
	    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
	    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
	    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
	    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
	    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
	    "table-caption", "table-cell", "table-column", "table-column-group",
	    "table-footer-group", "table-header-group", "table-row", "table-row-group",
	    "tamil",
	    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
	    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
	    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
	    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
	    "trad-chinese-formal", "trad-chinese-informal", "transform",
	    "translate", "translate3d", "translateX", "translateY", "translateZ",
	    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
	    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
	    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
	    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
	    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
	    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
	    "xx-large", "xx-small"
	  ], valueKeywords = keySet(valueKeywords_);

	  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
	    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
	    .concat(valueKeywords_);
	  CodeMirror.registerHelper("hintWords", "css", allWords);

	  function tokenCComment(stream, state) {
	    var maybeEnd = false, ch;
	    while ((ch = stream.next()) != null) {
	      if (maybeEnd && ch == "/") {
	        state.tokenize = null;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ["comment", "comment"];
	  }

	  CodeMirror.defineMIME("text/css", {
	    documentTypes: documentTypes,
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    fontProperties: fontProperties,
	    counterDescriptors: counterDescriptors,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (!stream.eat("*")) return false;
	        state.tokenize = tokenCComment;
	        return tokenCComment(stream, state);
	      }
	    },
	    name: "css"
	  });

	  CodeMirror.defineMIME("text/x-scss", {
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    fontProperties: fontProperties,
	    allowNested: true,
	    lineComment: "//",
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ["comment", "comment"];
	        } else if (stream.eat("*")) {
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        } else {
	          return ["operator", "operator"];
	        }
	      },
	      ":": function(stream) {
	        if (stream.match(/\s*\{/, false))
	          return [null, null]
	        return false;
	      },
	      "$": function(stream) {
	        stream.match(/^[\w-]+/);
	        if (stream.match(/^\s*:/, false))
	          return ["variable-2", "variable-definition"];
	        return ["variable-2", "variable"];
	      },
	      "#": function(stream) {
	        if (!stream.eat("{")) return false;
	        return [null, "interpolation"];
	      }
	    },
	    name: "css",
	    helperType: "scss"
	  });

	  CodeMirror.defineMIME("text/x-less", {
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    mediaValueKeywords: mediaValueKeywords,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    fontProperties: fontProperties,
	    allowNested: true,
	    lineComment: "//",
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ["comment", "comment"];
	        } else if (stream.eat("*")) {
	          state.tokenize = tokenCComment;
	          return tokenCComment(stream, state);
	        } else {
	          return ["operator", "operator"];
	        }
	      },
	      "@": function(stream) {
	        if (stream.eat("{")) return [null, "interpolation"];
	        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
	        stream.eatWhile(/[\w\\\-]/);
	        if (stream.match(/^\s*:/, false))
	          return ["variable-2", "variable-definition"];
	        return ["variable-2", "variable"];
	      },
	      "&": function() {
	        return ["atom", "atom"];
	      }
	    },
	    name: "css",
	    helperType: "less"
	  });

	  CodeMirror.defineMIME("text/x-gss", {
	    documentTypes: documentTypes,
	    mediaTypes: mediaTypes,
	    mediaFeatures: mediaFeatures,
	    propertyKeywords: propertyKeywords,
	    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
	    fontProperties: fontProperties,
	    counterDescriptors: counterDescriptors,
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords,
	    supportsAtComponent: true,
	    tokenHooks: {
	      "/": function(stream, state) {
	        if (!stream.eat("*")) return false;
	        state.tokenize = tokenCComment;
	        return tokenCComment(stream, state);
	      }
	    },
	    name: "css",
	    helperType: "gss"
	  });

	});
	});

	var htmlmixed = createCommonjsModule(function (module, exports) {
	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE

	(function(mod) {
	  mod(codemirror, xml, javascript, css$1);
	})(function(CodeMirror) {

	  var defaultTags = {
	    script: [
	      ["lang", /(javascript|babel)/i, "javascript"],
	      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
	      ["type", /./, "text/plain"],
	      [null, null, "javascript"]
	    ],
	    style:  [
	      ["lang", /^css$/i, "css"],
	      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
	      ["type", /./, "text/plain"],
	      [null, null, "css"]
	    ]
	  };

	  function maybeBackup(stream, pat, style) {
	    var cur = stream.current(), close = cur.search(pat);
	    if (close > -1) {
	      stream.backUp(cur.length - close);
	    } else if (cur.match(/<\/?$/)) {
	      stream.backUp(cur.length);
	      if (!stream.match(pat, false)) stream.match(cur);
	    }
	    return style;
	  }

	  var attrRegexpCache = {};
	  function getAttrRegexp(attr) {
	    var regexp = attrRegexpCache[attr];
	    if (regexp) return regexp;
	    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
	  }

	  function getAttrValue(text, attr) {
	    var match = text.match(getAttrRegexp(attr));
	    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
	  }

	  function getTagRegexp(tagName, anchored) {
	    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
	  }

	  function addTags(from, to) {
	    for (var tag in from) {
	      var dest = to[tag] || (to[tag] = []);
	      var source = from[tag];
	      for (var i = source.length - 1; i >= 0; i--)
	        dest.unshift(source[i]);
	    }
	  }

	  function findMatchingMode(tagInfo, tagText) {
	    for (var i = 0; i < tagInfo.length; i++) {
	      var spec = tagInfo[i];
	      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
	    }
	  }

	  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
	    var htmlMode = CodeMirror.getMode(config, {
	      name: "xml",
	      htmlMode: true,
	      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
	      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
	    });

	    var tags = {};
	    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
	    addTags(defaultTags, tags);
	    if (configTags) addTags(configTags, tags);
	    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
	      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);

	    function html(stream, state) {
	      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName;
	      if (tag && !/[<>\s\/]/.test(stream.current()) &&
	          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
	          tags.hasOwnProperty(tagName)) {
	        state.inTag = tagName + " ";
	      } else if (state.inTag && tag && />$/.test(stream.current())) {
	        var inTag = /^([\S]+) (.*)/.exec(state.inTag);
	        state.inTag = null;
	        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
	        var mode = CodeMirror.getMode(config, modeSpec);
	        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
	        state.token = function (stream, state) {
	          if (stream.match(endTagA, false)) {
	            state.token = html;
	            state.localState = state.localMode = null;
	            return null;
	          }
	          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
	        };
	        state.localMode = mode;
	        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
	      } else if (state.inTag) {
	        state.inTag += stream.current();
	        if (stream.eol()) state.inTag += " ";
	      }
	      return style;
	    }
	    return {
	      startState: function () {
	        var state = CodeMirror.startState(htmlMode);
	        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
	      },

	      copyState: function (state) {
	        var local;
	        if (state.localState) {
	          local = CodeMirror.copyState(state.localMode, state.localState);
	        }
	        return {token: state.token, inTag: state.inTag,
	                localMode: state.localMode, localState: local,
	                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
	      },

	      token: function (stream, state) {
	        return state.token(stream, state);
	      },

	      indent: function (state, textAfter, line) {
	        if (!state.localMode || /^\s*<\//.test(textAfter))
	          return htmlMode.indent(state.htmlState, textAfter, line);
	        else if (state.localMode.indent)
	          return state.localMode.indent(state.localState, textAfter, line);
	        else
	          return CodeMirror.Pass;
	      },

	      innerMode: function (state) {
	        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
	      }
	    };
	  }, "xml", "javascript", "css");

	  CodeMirror.defineMIME("text/html", "htmlmixed");
	});
	});

	var blueprintHTML = "<!--\n  ~  Copyright (c) 2020 Uncharted Software Inc.\n  ~  http://www.uncharted.software/\n  ~\n  ~   Permission is hereby granted, free of charge, to any person obtaining a copy of\n  ~  this software and associated documentation files (the \"Software\"), to deal in\n  ~  the Software without restriction, including without limitation the rights to\n  ~  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  ~  of the Software, and to permit persons to whom the Software is furnished to do\n  ~  so, subject to the following conditions:\n  ~\n  ~  The above copyright notice and this permission notice shall be included in all\n  ~  copies or substantial portions of the Software.\n  ~\n  ~  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n  ~  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  ~  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  ~  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  ~  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  ~  SOFTWARE.\n  ~\n  -->\n\n<h1>facet-blueprint</h1>\nThe <code>facet-blueprint</code> element represents the building\nblocks of facets, it implements the basic layout for every facets and their\ncontent, each <code>facet-blueprint</code> includes the following\n5 slots:\n<br /><br />\n\n<!-- simple `facet-blueprint` to display its sections -->\n<div class=\"facet-container\">\n    <facet-blueprint>\n        <div slot=\"header\" class=\"slot-header\">header</div>\n        <div slot=\"footer\" class=\"slot-footer\">footer</div>\n        <div slot=\"left\" class=\"slot-left\">left</div>\n        <div slot=\"right\" class=\"slot-right\">right</div>\n        <div slot=\"content\" class=\"slot-content\">content</div>\n    </facet-blueprint>\n</div>\n\n<br />\n<b>header, left, right and footer</b> are not used by facet implementations and\nare reserved to hold user customizations.<br />\n<b>content</b> is where facets will render their elements.<br />\n\n<br />\n<code>facet-blueprint</code> elements can be, and often are,\nnested:<br /><br />\n\n<!-- nested `facet-blueprint` -->\n<div class=\"facet-container\">\n    <facet-blueprint>\n        <div slot=\"header\" class=\"slot-header\">outer header</div>\n        <div slot=\"footer\" class=\"slot-footer\">outer footer</div>\n        <div slot=\"left\" class=\"slot-left\">outer left</div>\n        <div slot=\"right\" class=\"slot-right\">outer right</div>\n        <div slot=\"content\" class=\"slot-content\">\n            <div>outer content</div><br />\n            <facet-blueprint>\n                <div slot=\"header\" class=\"slot-header\">inner header</div>\n                <div slot=\"footer\" class=\"slot-footer\">inner footer</div>\n                <div slot=\"left\" class=\"slot-left\">inner left</div>\n                <div slot=\"right\" class=\"slot-right\">inner right</div>\n                <div slot=\"content\" class=\"slot-content\">inner content</div>\n            </facet-blueprint>\n        </div>\n    </facet-blueprint>\n</div>\n\n<br />\nSince every facet is built on top of a <code>facet-blueprint</code>\nit is safe to assume that they expose the same 5 slots than a\n<code>facet-blueprint</code>.<br />\n\n<br />\nAccess to each slot is provided through the <code>slot</code>\nproperty defined in the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/slot\">\n    shadow DOM API\n</a>.\n<br />\n\n<br />\nIn JavaScript, developers can specify the default behaviour of each section by\nextending the <code>FacetBlueprint</code> class (or any other facet\nclass) and overloading the methods:<br />\n<code>renderContent</code><br />\n<code>renderHeader</code><br />\n<code>renderFooter</code><br />\n<code>renderLeft</code><br />\n<code>renderRight</code><br />\n";

	var blueprintCSS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-container {\n    width: 300px;\n}\n\n.slot-header {\n    background-color: #ff0000;\n    padding: 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n}\n\n.slot-footer {\n    background-color: #00ff00;\n    padding: 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: gray;\n    text-align: center;\n    border: 1px solid black;\n}\n\n.slot-left {\n    background-color: #0000ff;\n    padding: 0 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    max-width: 44px;\n}\n\n.slot-right {\n    background-color: #ffff00;\n    padding: 0 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: gray;\n    text-align: center;\n    border: 1px solid black;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    max-width: 44px;\n}\n\n.slot-content {\n    background-color: #ff00ff;\n    padding: 15px 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n}\n\n/* text styles */\ncode {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n";

	var blueprintJS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n/* */\n";

	var termHTML = "<!--\n  ~  Copyright (c) 2020 Uncharted Software Inc.\n  ~  http://www.uncharted.software/\n  ~\n  ~   Permission is hereby granted, free of charge, to any person obtaining a copy of\n  ~  this software and associated documentation files (the \"Software\"), to deal in\n  ~  the Software without restriction, including without limitation the rights to\n  ~  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  ~  of the Software, and to permit persons to whom the Software is furnished to do\n  ~  so, subject to the following conditions:\n  ~\n  ~  The above copyright notice and this permission notice shall be included in all\n  ~  copies or substantial portions of the Software.\n  ~\n  ~  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n  ~  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  ~  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  ~  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  ~  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  ~  SOFTWARE.\n  ~\n  -->\n\n<div class=\"facet-container\">\n    <facet-terms data='{\n        \"label\": \"Simple Facets\",\n        \"values\": [\n            { \"ratio\": 0.05, \"label\": \"5%\" },\n            { \"ratio\": 0.15, \"label\": \"15%\" },\n            { \"ratio\": 0.25, \"label\": \"25%\" },\n            { \"ratio\": 0.35, \"label\": \"35%\" },\n            { \"ratio\": 0.45, \"label\": \"45%\" },\n            { \"ratio\": 0.55, \"label\": \"55%\" },\n            { \"ratio\": 0.65, \"label\": \"65%\" },\n            { \"ratio\": 0.75, \"label\": \"75%\" }\n        ]\n    }'>\n    </facet-terms>\n\n    <facet-terms subselection=\"[null, null, null, null, 0.35, 0.25, 0.15, 0.05]\" data='{\n        \"label\": \"Subselection\",\n        \"values\": [\n            { \"ratio\": 0.05, \"label\": \"5%\" },\n            { \"ratio\": 0.15, \"label\": \"15%\" },\n            { \"ratio\": 0.25, \"label\": \"25%\" },\n            { \"ratio\": 0.35, \"label\": \"35%\" },\n            { \"ratio\": 0.45, \"label\": \"45%\" },\n            { \"ratio\": 0.55, \"label\": \"55%\" },\n            { \"ratio\": 0.65, \"label\": \"65%\" },\n            { \"ratio\": 0.75, \"label\": \"75%\" }\n        ]\n    }'>\n    </facet-terms>\n\n    <facet-terms disabled subselection=\"[null, null, null, null, 0.35, 0.25, 0.15, 0.05]\" data='{\n        \"label\": \"Subselection + Disabled Selection\",\n        \"values\": [\n            { \"ratio\": 0.05, \"label\": \"5%\" },\n            { \"ratio\": 0.15, \"label\": \"15%\" },\n            { \"ratio\": 0.25, \"label\": \"25%\" },\n            { \"ratio\": 0.35, \"label\": \"35%\" },\n            { \"ratio\": 0.45, \"label\": \"45%\" },\n            { \"ratio\": 0.55, \"label\": \"55%\" },\n            { \"ratio\": 0.65, \"label\": \"65%\" },\n            { \"ratio\": 0.75, \"label\": \"75%\" }\n        ]\n    }'>\n    </facet-terms>\n\n    <facet-terms data='{\n        \"label\": \"Customized Facets\",\n        \"values\": [\n            {\n                \"ratio\": 0.11,\n                \"label\": \"Phil Laliberte\",\n                \"annotation\": \"(Scott Dafreed)\",\n                \"value\": 11,\n                \"metadata\": \"img/phillaliberte@2x.png\"\n            },\n            {\n                \"ratio\": 0.12,\n                \"label\": \"Chris Dickson\",\n                \"value\": 12,\n                \"metadata\": \"img/chrisdickson@2x.png\"\n            },\n            {\n                \"ratio\": 0.13,\n                \"label\": \"Sean McIntyre\",\n                \"value\": 13,\n                \"metadata\": \"img/seanmcintyre@2x.png\"\n            }\n        ]\n    }'>\n        <facet-template target=\"facet-terms-value\">\n            <div slot=\"left\" class=\"image-left\" template-style=\"background-image:url('${metadata}')\"></div>\n            <div slot=\"value\" class=\"big-value\">${value}</div>\n        </facet-template>\n    </facet-terms>\n\n    <facet-terms data='{\n        \"label\": \"About Us...\",\n        \"values\": [\n            {\n                \"type\": \"facet-terms-value#products\",\n                \"ratio\": 0.66,\n                \"label\": \"Products\",\n                \"value\": 66\n            },\n            {\n                \"type\": \"facet-terms-value#employee\",\n                \"ratio\": 0.96,\n                \"label\": \"Employee Satisfaction\",\n                \"value\": 96\n            }\n        ]\n    }'>\n        <facet-template target=\"facet-terms-value#products\">\n            <div slot=\"header\" class=\"geotime-header\"></div>\n        </facet-template>\n        <facet-template target=\"facet-terms-value#employee\">\n            <div slot=\"header\" class=\"employee-header\"></div>\n        </facet-template>\n    </facet-terms>\n</div>\n";

	var termCSS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-container {\n    width: 300px;\n}\n\n.example-header {\n    background-color: #e5e5e5;\n    border: 5px solid white;\n    padding: 3px;\n    font-family: monospace;\n    font-size: 14px;\n    color: #454545;\n}\n\n.image-left {\n    margin: 5px;\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    background-size: cover;\n}\n\n.big-value {\n    font-size: 16px;\n    line-height: 24px;\n    white-space: nowrap;\n}\n\n.geotime-header {\n    height: 100px;\n    background-image: url(\"img/geotime.png\");\n    background-size: contain;\n    margin: 5px;\n}\n\n.employee-header {\n    height: 100px;\n    background-image: url(\"img/hackathon-ar-action.jpg\");\n    background-size: cover;\n    margin: 5px;\n}\n\n.slot-header {\n    background-color: #ff0000;\n    padding: 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n}\n\n.slot-footer {\n    background-color: #00ff00;\n    padding: 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: gray;\n    text-align: center;\n    border: 1px solid black;\n}\n\n.slot-left {\n    background-color: #0000ff;\n    padding: 0 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    max-width: 44px;\n}\n\n.slot-right {\n    background-color: #ffff00;\n    padding: 0 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: gray;\n    text-align: center;\n    border: 1px solid black;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    max-width: 44px;\n}\n\n/* text styles */\ncode {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n\n.annotation {\n    color: #767676;\n    font-family: monospace;\n    font-size: 13px;\n    margin: 6px 0;\n}\n\n.code-block {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n";

	var termJS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n/* */\n";

	var barsHTML = "<!--\n  ~  Copyright (c) 2020 Uncharted Software Inc.\n  ~  http://www.uncharted.software/\n  ~\n  ~   Permission is hereby granted, free of charge, to any person obtaining a copy of\n  ~  this software and associated documentation files (the \"Software\"), to deal in\n  ~  the Software without restriction, including without limitation the rights to\n  ~  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  ~  of the Software, and to permit persons to whom the Software is furnished to do\n  ~  so, subject to the following conditions:\n  ~\n  ~  The above copyright notice and this permission notice shall be included in all\n  ~  copies or substantial portions of the Software.\n  ~\n  ~  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n  ~  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  ~  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  ~  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  ~  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  ~  SOFTWARE.\n  ~\n  -->\n\n<div class=\"container\">\n    <facet-bars id=\"facet00\"></facet-bars>\n\n    <facet-bars id=\"facet01\" data='{\n        \"label\": \"Array Data\",\n        \"values\": [\n            { \"ratio\": 0.1 },\n            { \"ratio\": 0.2 },\n            { \"ratio\": 0.3 },\n            { \"ratio\": 0.4 },\n            { \"ratio\": 0.5 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 1.0 }\n        ]\n    }'>\n    </facet-bars>\n\n    <facet-bars id=\"facet02\" data='{\n        \"label\": \"Array Data + Subselection\",\n        \"values\": [\n            { \"ratio\": 1.0 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.5 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 1.0 }\n        ]\n    }' subselection='[\n            0.0,\n            0.1,\n            0.2,\n            0.3,\n            0.4,\n            0.5,\n            0.4,\n            0.3,\n            0.2,\n            0.1,\n            0.0\n        ]'>\n    </facet-bars>\n\n    <facet-bars id=\"facet02d\" disabled data='{\n        \"label\": \"Array Data + Subselection + Disabled Selection\",\n        \"values\": [\n            { \"ratio\": 1.0 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.5 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 1.0 }\n        ]\n    }' subselection='[\n            0.0,\n            0.1,\n            0.2,\n            0.3,\n            0.4,\n            0.5,\n            0.4,\n            0.3,\n            0.2,\n            0.1,\n            0.0\n        ]'>\n    </facet-bars>\n\n    <facet-bars id=\"facet03\" data='{\n        \"label\": \"... Auto Labels + Zoom Bar + No Delimiters\",\n        \"values\": [\n            { \"ratio\": 0.1 },\n            { \"ratio\": 0.2 },\n            { \"ratio\": 0.3 },\n            { \"ratio\": 0.4 },\n            { \"ratio\": 0.5 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 1.0 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.5 },\n            { \"ratio\": 0.4 },\n            { \"ratio\": 0.3 },\n            { \"ratio\": 0.2 },\n            { \"ratio\": 0.1 },\n            { \"ratio\": 0.2 },\n            { \"ratio\": 0.3 },\n            { \"ratio\": 0.4 },\n            { \"ratio\": 0.5 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 1.0 },\n            { \"ratio\": 0.9 },\n            { \"ratio\": 0.8 },\n            { \"ratio\": 0.7 },\n            { \"ratio\": 0.6 },\n            { \"ratio\": 0.5 },\n            { \"ratio\": 0.4 },\n            { \"ratio\": 0.3 },\n            { \"ratio\": 0.2 },\n\t\t\t{ \"ratio\": 0.1 }\n        ]\n    }'>\n        <facet-bars-labels slot=\"labels\" automatic-labels=\"true\" draw-delimiters=\"false\"></facet-bars-labels>\n        <facet-plugin-zoom-bar slot=\"footer\"></facet-plugin-zoom-bar>\n    </facet-bars>\n\n    <facet-bars id=\"facet04\" view=\"[38, 48]\" data='{\n        \"label\": \"... Object Data + Labels + View\",\n        \"values\": {\n            \"20\": { \"ratio\": 0.1, \"label\": [\"JAN\"] },\n            \"21\": { \"ratio\": 0.2, \"label\": [\"JAN\"] },\n            \"22\": { \"ratio\": 0.3, \"label\": [\"JAN\"] },\n            \"23\": { \"ratio\": 0.4, \"label\": [\"FEB\"] },\n            \"24\": { \"ratio\": 0.5, \"label\": [\"FEB\"] },\n            \"25\": { \"ratio\": 0.6, \"label\": [\"FEB\"] },\n            \"26\": { \"ratio\": 0.7, \"label\": [\"MAR\"] },\n            \"27\": { \"ratio\": 0.8, \"label\": [\"MAR\"] },\n            \"28\": { \"ratio\": 0.9, \"label\": [\"MAR\"] },\n            \"29\": { \"ratio\": 1.0, \"label\": [\"APR\"] },\n            \"30\": { \"ratio\": 0.9, \"label\": [\"APR\"] },\n            \"31\": { \"ratio\": 0.8, \"label\": [\"APR\"] },\n            \"32\": { \"ratio\": 0.7, \"label\": [\"MAY\"] },\n            \"33\": { \"ratio\": 0.6, \"label\": [\"MAY\"] },\n            \"34\": { \"ratio\": 0.5, \"label\": [\"MAY\"] },\n            \"35\": { \"ratio\": 0.4, \"label\": [\"JUN\"] },\n            \"36\": { \"ratio\": 0.3, \"label\": [\"JUN\"] },\n            \"37\": { \"ratio\": 0.2, \"label\": [\"JUN\"] },\n            \"38\": { \"ratio\": 0.1, \"label\": [\"JUL\"] },\n            \"39\": { \"ratio\": 0.2, \"label\": [\"JUL\"] },\n            \"40\": { \"ratio\": 0.3, \"label\": [\"JUL\"] },\n            \"41\": { \"ratio\": 0.4, \"label\": [\"AUG\"] },\n            \"42\": { \"ratio\": 0.5, \"label\": [\"AUG\"] },\n            \"43\": { \"ratio\": 0.6, \"label\": [\"AUG\"] },\n            \"44\": { \"ratio\": 0.7, \"label\": [\"SEP\"] },\n            \"45\": { \"ratio\": 0.8, \"label\": [\"SEP\"] },\n            \"46\": { \"ratio\": 0.9, \"label\": [\"SEP\"] },\n            \"47\": { \"ratio\": 1.0, \"label\": [\"OCT\"] },\n            \"48\": { \"ratio\": 0.9, \"label\": [\"OCT\"] },\n            \"49\": { \"ratio\": 0.8, \"label\": [\"OCT\"] },\n            \"50\": { \"ratio\": 0.7, \"label\": [\"NOV\"] },\n            \"51\": { \"ratio\": 0.6, \"label\": [\"NOV\"] },\n            \"52\": { \"ratio\": 0.5, \"label\": [\"NOV\"] },\n            \"53\": { \"ratio\": 0.4, \"label\": [\"DEC\"] },\n            \"54\": { \"ratio\": 0.3, \"label\": [\"DEC\"] },\n            \"55\": { \"ratio\": 0.2, \"label\": [\"DEC\"] }\n        }\n    }'>\n        <facet-plugin-zoom-bar slot=\"footer\"></facet-plugin-zoom-bar>\n    </facet-bars>\n\n    <facet-bars id=\"facet05\" domain=\"[0, 100]\" view=\"[38, 48]\" data='{\n        \"label\": \"... Stacked Labels + Domain\",\n        \"values\": {\n            \"20\": { \"ratio\": 0.1, \"label\": [\"JAN\", \"Q1\"] },\n            \"21\": { \"ratio\": 0.2, \"label\": [\"JAN\", \"Q1\"] },\n            \"22\": { \"ratio\": 0.3, \"label\": [\"JAN\", \"Q1\"] },\n            \"23\": { \"ratio\": 0.4, \"label\": [\"FEB\", \"Q1\"] },\n            \"24\": { \"ratio\": 0.5, \"label\": [\"FEB\", \"Q1\"] },\n            \"25\": { \"ratio\": 0.6, \"label\": [\"FEB\", \"Q1\"] },\n            \"26\": { \"ratio\": 0.7, \"label\": [\"MAR\", \"Q1\"] },\n            \"27\": { \"ratio\": 0.8, \"label\": [\"MAR\", \"Q1\"] },\n            \"28\": { \"ratio\": 0.9, \"label\": [\"MAR\", \"Q1\"] },\n            \"29\": { \"ratio\": 1.0, \"label\": [\"APR\", \"Q2\"] },\n            \"30\": { \"ratio\": 0.9, \"label\": [\"APR\", \"Q2\"] },\n            \"31\": { \"ratio\": 0.8, \"label\": [\"APR\", \"Q2\"] },\n            \"32\": { \"ratio\": 0.7, \"label\": [\"MAY\", \"Q2\"] },\n            \"33\": { \"ratio\": 0.6, \"label\": [\"MAY\", \"Q2\"] },\n            \"34\": { \"ratio\": 0.5, \"label\": [\"MAY\", \"Q2\"] },\n            \"35\": { \"ratio\": 0.4, \"label\": [\"JUN\", \"Q2\"] },\n            \"36\": { \"ratio\": 0.3, \"label\": [\"JUN\", \"Q2\"] },\n            \"37\": { \"ratio\": 0.2, \"label\": [\"JUN\", \"Q2\"] },\n            \"38\": { \"ratio\": 0.1, \"label\": [\"JUL\", \"Q3\"] },\n            \"39\": { \"ratio\": 0.2, \"label\": [\"JUL\", \"Q3\"] },\n            \"40\": { \"ratio\": 0.3, \"label\": [\"JUL\", \"Q3\"] },\n            \"41\": { \"ratio\": 0.4, \"label\": [\"AUG\", \"Q3\"] },\n            \"42\": { \"ratio\": 0.5, \"label\": [\"AUG\", \"Q3\"] },\n            \"43\": { \"ratio\": 0.6, \"label\": [\"AUG\", \"Q3\"] },\n            \"44\": { \"ratio\": 0.7, \"label\": [\"SEP\", \"Q3\"] },\n            \"45\": { \"ratio\": 0.8, \"label\": [\"SEP\", \"Q3\"] },\n            \"46\": { \"ratio\": 0.9, \"label\": [\"SEP\", \"Q3\"] },\n            \"47\": { \"ratio\": 1.0, \"label\": [\"OCT\", \"Q4\"] },\n            \"48\": { \"ratio\": 0.9, \"label\": [\"OCT\", \"Q4\"] },\n            \"49\": { \"ratio\": 0.8, \"label\": [\"OCT\", \"Q4\"] },\n            \"50\": { \"ratio\": 0.7, \"label\": [\"NOV\", \"Q4\"] },\n            \"51\": { \"ratio\": 0.6, \"label\": [\"NOV\", \"Q4\"] },\n            \"52\": { \"ratio\": 0.5, \"label\": [\"NOV\", \"Q4\"] },\n            \"53\": { \"ratio\": 0.4, \"label\": [\"DEC\", \"Q4\"] },\n            \"54\": { \"ratio\": 0.3, \"label\": [\"DEC\", \"Q4\"] },\n            \"55\": { \"ratio\": 0.2, \"label\": [\"DEC\", \"Q4\"] }\n        }\n    }'>\n        <facet-plugin-zoom-bar slot=\"footer\"></facet-plugin-zoom-bar>\n    </facet-bars>\n\n    <facet-bars id=\"facet06\"></facet-bars>\n</div>\n";

	var barsCSS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.container {\n    width: 300px;\n}\n";

	var barsJS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\nconst kLabelsTemplate = [\n    [\n        {\n            count: 2,\n            values: [\n                'Q1',\n                'Q2',\n                'Q3',\n                'Q4',\n            ],\n        },\n        {\n            count: 8,\n            values: [\n                '1990',\n                '1991',\n                '1992',\n                '1993',\n                '1994',\n                '1995',\n                '1996',\n                '1997',\n                '1998',\n                '1999',\n                '2000',\n                '2001',\n                '2002',\n                '2003',\n                '2004',\n                '2005',\n                '2006',\n                '2007',\n                '2008',\n                '2009',\n                '2010',\n                '2011',\n                '2012',\n                '2013',\n                '2014',\n                '2015',\n                '2016',\n                '2017',\n                '2018',\n                '2019',\n            ],\n        },\n        {\n            count: 80,\n            values: [\n                '90\\'s',\n                '00\\'s',\n                '10\\'s',\n            ],\n        },\n    ],\n    [\n        {\n            count: 3,\n            values: [\n                'Jan',\n                'Feb',\n                'Mar',\n                'Apr',\n                'May',\n                'Jun',\n                'Jul',\n                'Aug',\n                'Sep',\n                'Oct',\n                'Nov',\n                'Dec',\n            ],\n        },\n        {\n            count: 9,\n            values: [\n                'Q1',\n                'Q2',\n                'Q3',\n                'Q4',\n            ],\n        },\n        {\n            count: 36,\n            values: [\n                '1990',\n                '1991',\n                '1992',\n                '1993',\n                '1994',\n                '1995',\n                '1996',\n                '1997',\n                '1998',\n                '1999',\n                '2000',\n                '2001',\n                '2002',\n                '2003',\n                '2004',\n                '2005',\n                '2006',\n                '2007',\n                '2008',\n                '2009',\n                '2010',\n                '2011',\n                '2012',\n                '2013',\n                '2014',\n                '2015',\n                '2016',\n                '2017',\n                '2018',\n                '2019',\n            ],\n        },\n    ],\n    [\n        {\n            count: 1,\n            values: [\n                '1',\n                '2',\n                '3',\n                '4',\n                '5',\n                '6',\n                '7',\n                '8',\n                '9',\n                '10',\n                '11',\n                '12',\n                '13',\n                '14',\n                '15',\n                '16',\n                '17',\n                '18',\n                '19',\n                '20',\n                '21',\n                '22',\n                '23',\n                '24',\n                '25',\n                '26',\n                '27',\n                '28',\n                '29',\n                '30',\n            ],\n        },\n        {\n            count: 30,\n            values: [\n                'Jan',\n                'Feb',\n                'Mar',\n                'Apr',\n                'May',\n                'Jun',\n                'Jul',\n                'Aug',\n                'Sep',\n                'Oct',\n                'Nov',\n                'Dec',\n            ],\n        },\n        {\n            count: 360,\n            values: [\n                '1990',\n                '1991',\n                '1992',\n                '1993',\n                '1994',\n                '1995',\n                '1996',\n                '1997',\n                '1998',\n                '1999',\n                '2000',\n                '2001',\n                '2002',\n                '2003',\n                '2004',\n                '2005',\n                '2006',\n                '2007',\n                '2008',\n                '2009',\n                '2010',\n                '2011',\n                '2012',\n                '2013',\n                '2014',\n                '2015',\n                '2016',\n                '2017',\n                '2018',\n                '2019',\n            ],\n        },\n    ],\n];\n\nconst kZoomLevelViews = [\n    {\n        min: 8,\n        max: 100000,\n    },\n    {\n        min: 6,\n        max: 40,\n    },\n    {\n        min: 0,\n        max: 75,\n    },\n];\n\nfunction getLabel(zoomLevel, detailLevel, i) {\n    return kLabelsTemplate[zoomLevel][detailLevel]\n        .values[Math.floor(\n            i / kLabelsTemplate[zoomLevel][detailLevel].count,\n        ) % kLabelsTemplate[zoomLevel][detailLevel].values.length];\n}\n\n\nfunction getDummyData(range, zoomLevel, oldData = { values: {} } ) {\n    const values = Object.assign({}, oldData.values);\n    for (let i = range[0]; i < range[1]; ++i) {\n        values[i] = {\n            ratio: Math.random(),\n            label: [\n                getLabel(zoomLevel, 0, i),\n                getLabel(zoomLevel, 1, i),\n                getLabel(zoomLevel, 2, i),\n            ],\n        };\n    }\n    return {\n        label: 'Zoom Interactions',\n        values,\n    };\n}\n\nfunction nullifyValues(oldData) {\n    const values = Object.assign({}, oldData.values);\n    const keys = Object.keys(values);\n    for (let i = 0, n = keys.length; i < n; ++i) {\n        values[keys[i]].ratio = null;\n    }\n    return {\n        label: 'Zoom Interactions',\n        values,\n    };\n}\n\nfunction changeZoomLevel(facet, zoomBar, data, oldZoom, newZoom, loaded, loadCount) {\n    return new Promise(resolve => {\n        const oldZoomLength = kLabelsTemplate[oldZoom][2].count * kLabelsTemplate[oldZoom][2].values.length;\n        const newZoomLength = kLabelsTemplate[newZoom][2].count * kLabelsTemplate[newZoom][2].values.length;\n        const view = facet.view;\n        const min = Math.max(0, Math.round((view[0] / oldZoomLength) * newZoomLength));\n        const max = Math.min(newZoomLength, Math.round((view[1] / oldZoomLength) * newZoomLength));\n        const selection = facet.selection;\n        facet.data = nullifyValues(data);\n        facet.selection = null;\n        zoomBar.enabled = false;\n\n        setTimeout(() => {\n            loaded[0] = Math.max(min - loadCount, 0);\n            loaded[1] = Math.min(max + loadCount, newZoomLength);\n            const newData = getDummyData(loaded, newZoom);\n            facet.data = newData;\n            facet.view = [min, max];\n\n            // facet.domain = [0, newZoomLength];\n            facet.domain = newZoom === 0 ? [0, newZoomLength] : loaded;\n\n            if (selection) {\n                facet.selection = [\n                    Math.max(0, Math.floor((selection[0] / oldZoomLength) * newZoomLength)),\n                    Math.min(newZoomLength, Math.ceil((selection[1] / oldZoomLength) * newZoomLength)),\n                ];\n            }\n\n            zoomBar.enabled = true;\n            resolve(newData);\n        }, 1000);\n    });\n}\n\nfunction main() {\n    const facet = document.querySelector('#facet06');\n    if (facet) {\n        const zoomBar = document.createElement('facet-plugin-zoom-bar');\n        zoomBar.setAttribute('slot', 'footer');\n        facet.append(zoomBar);\n\n        const loadCount = 40;\n        const loaded = [0, loadCount];\n        let zoomLevel = 0;\n        let data = getDummyData(loaded, zoomLevel);\n        facet.data = data;\n        facet.view = [0, 32];\n        facet.domain = [0, kLabelsTemplate[zoomLevel][2].count * kLabelsTemplate[zoomLevel][2].values.length];\n\n        facet.addEventListener('facet-element-updated', evt => {\n            if (evt.detail.changedProperties.has('view')) {\n                const domain = facet.domain;\n                const view = facet.view;\n                const length = view[1] - view[0];\n\n                if (length >= kZoomLevelViews[zoomLevel].max) {\n                    changeZoomLevel(facet, zoomBar, data, zoomLevel, zoomLevel - 1, loaded, loadCount).then(newData => {\n                        data = newData;\n                        --zoomLevel;\n                    });\n                } else if (length <= kZoomLevelViews[zoomLevel].min) {\n                    changeZoomLevel(facet, zoomBar, data, zoomLevel, zoomLevel + 1, loaded, loadCount).then(newData => {\n                        data = newData;\n                        ++zoomLevel;\n                    });\n                } else {\n                    const maxOOV = Math.round(length * 0.5);\n                    let dataUpdated = false;\n\n                    if (view[0] < loaded[0] - maxOOV) {\n                        const bound = Math.max(domain[0], loaded[0] - loadCount);\n                        data = getDummyData([bound, loaded[0]], zoomLevel, data);\n                        dataUpdated = true;\n                        loaded[0] = bound;\n                    }\n\n                    if (view[1] > loaded[1] + maxOOV) {\n                        const bound = Math.min(domain[1], loaded[1] + loadCount);\n                        data = getDummyData([loaded[1], bound], zoomLevel, data);\n                        dataUpdated = true;\n                        loaded[1] = bound;\n                    }\n\n                    if (dataUpdated) {\n                        facet.data = data;\n                    }\n                }\n            }\n        });\n    }\n}\n\nwindow.addEventListener('load', function () {\n    setTimeout(main, 2000);\n});\n";

	var timelineHTML = "<!--\n  ~  Copyright (c) 2020 Uncharted Software Inc.\n  ~  http://www.uncharted.software/\n  ~\n  ~   Permission is hereby granted, free of charge, to any person obtaining a copy of\n  ~  this software and associated documentation files (the \"Software\"), to deal in\n  ~  the Software without restriction, including without limitation the rights to\n  ~  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  ~  of the Software, and to permit persons to whom the Software is furnished to do\n  ~  so, subject to the following conditions:\n  ~\n  ~  The above copyright notice and this permission notice shall be included in all\n  ~  copies or substantial portions of the Software.\n  ~\n  ~  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n  ~  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  ~  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  ~  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  ~  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  ~  SOFTWARE.\n  ~\n  -->\n\n<div class=\"facet-container\">\n    <facet-timeline id=\"facet-01\"></facet-timeline>\n\n    <facet-timeline id=\"facet-02\" data='[\n        { \"ratio\": 0.1 },\n        { \"ratio\": 0.2 },\n        { \"ratio\": 0.3 },\n        { \"ratio\": 0.4 },\n        { \"ratio\": 0.5 },\n        { \"ratio\": 0.6 },\n        { \"ratio\": 0.7 },\n        { \"ratio\": 0.8 },\n        { \"ratio\": 0.9 },\n        { \"ratio\": 1.0 }\n    ]'></facet-timeline>\n\n    <facet-timeline id=\"facet-02d\" disabled data='[\n        { \"ratio\": 0.1 },\n        { \"ratio\": 0.2 },\n        { \"ratio\": 0.3 },\n        { \"ratio\": 0.4 },\n        { \"ratio\": 0.5 },\n        { \"ratio\": 0.6 },\n        { \"ratio\": 0.7 },\n        { \"ratio\": 0.8 },\n        { \"ratio\": 0.9 },\n        { \"ratio\": 1.0 }\n    ]'></facet-timeline>\n\n    <facet-timeline id=\"facet-02\" data='[\n        { \"ratio\": 0.1, \"label\": [\"Mon 27\"] },\n        { \"ratio\": 0.2, \"label\": [\"Tue 28\"] },\n        { \"ratio\": 0.3, \"label\": [\"Wed 29\"] },\n        { \"ratio\": 0.4, \"label\": [\"Thu 30\"] },\n        { \"ratio\": 0.5, \"label\": [\"Fri 31\"] },\n        { \"ratio\": 0.6, \"label\": [\"Sat 01\"] },\n        { \"ratio\": 0.7, \"label\": [\"Sun 02\"] },\n        { \"ratio\": 0.8, \"label\": [\"Mon 03\"] },\n        { \"ratio\": 0.9, \"label\": [\"Tue 04\"] },\n        { \"ratio\": 1.0, \"label\": [\"Wed 05\"] }\n    ]' domain=\"[0.5, 8.7]\"></facet-timeline>\n\n    <facet-timeline id=\"facet-03\" data='[\n        { \"ratio\": 0.1, \"label\": [\"Mon 27\", \"Dec 2019\"] },\n        { \"ratio\": 0.2, \"label\": [\"Tue 28\", \"Dec 2019\"] },\n        { \"ratio\": 0.3, \"label\": [\"Wed 29\", \"Dec 2019\"] },\n        { \"ratio\": 0.4, \"label\": [\"Thu 30\", \"Dec 2019\"] },\n        { \"ratio\": 0.5, \"label\": [\"Fri 31\", \"Dec 2019\"] },\n        { \"ratio\": 0.6, \"label\": [\"Sat 01\", \"Jan 2020\"] },\n        { \"ratio\": 0.7, \"label\": [\"Sun 02\", \"Jan 2020\"] },\n        { \"ratio\": 0.8, \"label\": [\"Mon 03\", \"Jan 2020\"] },\n        { \"ratio\": 0.9, \"label\": [\"Tue 04\", \"Jan 2020\"] },\n        { \"ratio\": 1.0, \"label\": [\"Wed 05\", \"Jan 2020\"] }\n    ]'></facet-timeline>\n\n    <facet-timeline id=\"facet-04\" data='[\n        { \"ratio\": 0.1, \"label\": [\"Mon 27\", \"Dec\", \"2019\"] },\n        { \"ratio\": 0.2, \"label\": [\"Tue 28\", \"Dec\", \"2019\"] },\n        { \"ratio\": 0.3, \"label\": [\"Wed 29\", \"Dec\", \"2019\"] },\n        { \"ratio\": 0.4, \"label\": [\"Thu 30\", \"Dec\", \"2019\"] },\n        { \"ratio\": 0.5, \"label\": [\"Fri 31\", \"Dec\", \"2019\"] },\n        { \"ratio\": 0.6, \"label\": [\"Sat 01\", \"Jan\", \"2020\"] },\n        { \"ratio\": 0.7, \"label\": [\"Sun 02\", \"Jan\", \"2020\"] },\n        { \"ratio\": 0.8, \"label\": [\"Mon 03\", \"Jan\", \"2020\"] },\n        { \"ratio\": 0.9, \"label\": [\"Tue 04\", \"Jan\", \"2020\"] },\n        { \"ratio\": 1.0, \"label\": [\"Wed 05\", \"Jan\", \"2020\"] }\n    ]' filter='[{\"value\": 0.0005, \"label\": \"label left\"}, {\"value\": 6.5, \"label\":\"label right\"}]'></facet-timeline>\n\n    <facet-timeline id=\"facet-05\">\n        <facet-plugin-scrollbar slot=\"scrollbar\"></facet-plugin-scrollbar>\n        <facet-plugin-zoom-controls slot=\"left\"></facet-plugin-zoom-controls>\n    </facet-timeline>\n</div>\n";

	var timelineCSS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-container {\n    width: 100%;\n    display: flex;\n    flex-direction: column;\n}\n\nfacet-timeline {\n    padding: 10px 0;\n}\n";

	var timelineJS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n/* */\n\nfunction main() {\n    /* facet-05 */\n    const facet05 = document.getElementById('facet-05');\n    const facet05Data = [];\n    const facet05Length = 365;\n    const date = new Date();\n    date.setUTCMilliseconds(-86400000 * facet05Length);\n    for (let i = 0; i < facet05Length; ++i) {\n        const value = {\n            ratio: Math.random(),\n            label: [\n                date.toLocaleDateString('default', { weekday: 'short', day: 'numeric' }),\n                date.toLocaleDateString('default', { month: 'short', year: 'numeric' }),\n            ],\n        };\n        value.minDateLabel = date.toLocaleString();\n        date.setUTCMilliseconds(86400000);\n        value.maxDateLabel = date.toLocaleString();\n\n        facet05Data.push(value);\n    }\n    facet05.data = facet05Data;\n}\n\nwindow.addEventListener('load', function () {\n    main();\n});\n";

	var listHTML = "<!--\n  ~  Copyright (c) 2020 Uncharted Software Inc.\n  ~  http://www.uncharted.software/\n  ~\n  ~   Permission is hereby granted, free of charge, to any person obtaining a copy of\n  ~  this software and associated documentation files (the \"Software\"), to deal in\n  ~  the Software without restriction, including without limitation the rights to\n  ~  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  ~  of the Software, and to permit persons to whom the Software is furnished to do\n  ~  so, subject to the following conditions:\n  ~\n  ~  The above copyright notice and this permission notice shall be included in all\n  ~  copies or substantial portions of the Software.\n  ~\n  ~  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n  ~  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  ~  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  ~  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  ~  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  ~  SOFTWARE.\n  ~\n  -->\n\n<h1>facet-list</h1>\n<!-- default facet list -->\n<div class=\"facet-container\">\n    <facet-list data='[\n        {\n            \"type\": \"facet-terms\",\n            \"data\": {\n                \"label\": \"Facet Terms\",\n                \"values\": [\n                    { \"ratio\": 0.5, \"label\": \"Fifty\", \"value\": 50 },\n                    { \"ratio\": 0.7, \"label\": \"Seventy\", \"value\": 70 },\n                    { \"ratio\": 0.9, \"label\": \"Ninety\", \"value\": 90 }\n                ]\n            }\n        },\n        {\n            \"type\": \"facet-bars\",\n            \"data\": {\n                \"label\": \"Facet Bars\",\n                \"values\": [\n                    { \"ratio\": 0.1 },\n                    { \"ratio\": 0.2 },\n                    { \"ratio\": 0.3 },\n                    { \"ratio\": 0.4 },\n                    { \"ratio\": 0.5 },\n                    { \"ratio\": 0.6 },\n                    { \"ratio\": 0.7 },\n                    { \"ratio\": 0.8 },\n                    { \"ratio\": 0.9 },\n                    { \"ratio\": 1.0 }\n                ]\n            }\n        }\n    ]'>\n        <div slot=\"header\" class=\"example-header\">Standard Facet List + Header</div>\n    </facet-list>\n</div>\n\n<br />\n<!-- facet list of customized facets -->\n<div class=\"facet-container\">\n    <facet-list data='[\n        {\n            \"type\": \"facet-terms\",\n            \"data\": {\n                \"label\": \"Facet Terms\",\n                \"values\": [\n                    {\n                        \"ratio\": 0.11,\n                        \"label\": \"Phil Laliberte\",\n                        \"annotation\": \"(Scott Dafreed)\",\n                        \"value\": 11,\n                        \"metadata\": \"img/phillaliberte@2x.png\"\n                    },\n                    {\n                        \"ratio\": 0.12,\n                        \"label\": \"Chris Dickson\",\n                        \"value\": 12,\n                        \"metadata\": \"img/chrisdickson@2x.png\"\n                    },\n                    {\n                        \"ratio\": 0.13,\n                        \"label\": \"Sean McIntyre\",\n                        \"value\": 13,\n                        \"metadata\": \"img/seanmcintyre@2x.png\"\n                    }\n                ]\n            }\n        },\n        {\n            \"type\": \"facet-bars\",\n            \"data\": {\n                \"label\": \"Facet Bars\",\n                \"values\": [\n                    { \"ratio\": 0.1 },\n                    { \"ratio\": 0.2 },\n                    { \"ratio\": 0.3 },\n                    { \"ratio\": 0.4 },\n                    { \"ratio\": 0.5 },\n                    { \"ratio\": 0.6 },\n                    { \"ratio\": 0.7 },\n                    { \"ratio\": 0.8 },\n                    { \"ratio\": 0.9 },\n                    { \"ratio\": 1.0 }\n                ]\n            }\n        }\n    ]'>\n        <div slot=\"header\" class=\"example-header\">List of Customized Facets</div>\n        <facet-template target=\"facet-terms\">\n            <facet-template target=\"facet-terms-value\">\n                <div slot=\"left\" class=\"image-left\" template-style=\"background-image:url('${metadata}')\"></div>\n                <div slot=\"value\" class=\"big-value\">${value}</div>\n            </facet-template>\n            <span slot=\"footer-label\">a ton more...</span>\n        </facet-template>\n        <facet-template target=\"facet-bars\">\n            <div slot=\"header\" class=\"histogram-header\">Customized Header</div>\n            <div slot=\"left\" class=\"gradient-scale\"></div>\n        </facet-template>\n    </facet-list>\n</div></div>\n\n<br />\n<!-- inspired facets 2.0 list -->\n<div class=\"inspired-container\">\n    <facet-list data='[\n        {\n            \"type\": \"facet-terms\",\n            \"data\": {\n                \"values\": [\n                    { \"ratio\": 0.1428571429, \"label\": \"Programs\", \"value\": 14.28 },\n                    { \"ratio\": 0.2857142857, \"label\": \"Favorites\", \"value\": 28.57 },\n                    { \"ratio\": 0.4285714286, \"label\": \"Documents\", \"value\": 42.85 },\n                    { \"ratio\": 0.5714285714, \"label\": \"Settings\", \"value\": 57.14 },\n                    { \"ratio\": 0.7142857143, \"label\": \"Find\", \"value\": 71.24 },\n                    { \"ratio\": 0.8571428571, \"label\": \"Help\", \"value\": 85.71 },\n                    { \"ratio\": 1.0, \"label\": \"Run!\", \"value\": \"100.00\" }\n                ]\n            }\n        },\n        {\n            \"type\": \"facet-bars\",\n            \"data\": {\n                \"values\": [\n                    { \"ratio\": 0.1 },\n                    { \"ratio\": 0.2 },\n                    { \"ratio\": 0.3 },\n                    { \"ratio\": 0.4 },\n                    { \"ratio\": 0.5 },\n                    { \"ratio\": 0.6 },\n                    { \"ratio\": 0.7 },\n                    { \"ratio\": 0.8 },\n                    { \"ratio\": 0.9 },\n                    { \"ratio\": 1.0 }\n                ],\n                \"metadata\": \"Shut Down...\"\n            }\n        }\n    ]'>\n        <div slot=\"header\" class=\"inspired-header\">Facets Update</div>\n        <div slot=\"left\" class=\"inspired-left\">\n            <div class=\"inspired-left-text\">\n                <span class=\"inspired-left-facets\">Facets</span>\n                <span class=\"inspired-left-2\">3.0</span>\n            </div>\n        </div>\n        <facet-template target=\"facet-terms\">\n            <div slot=\"header\"></div>\n            <div slot=\"footer\"></div>\n        </facet-template>\n        <facet-template target=\"facet-bars\">\n            <div slot=\"header\" class=\"histogram-header\">${metadata}</div>\n            <div slot=\"footer\"></div>\n        </facet-template>\n    </facet-list>\n</div>\n\n<h3>Definition</h3>\n<code>facet-list</code> is a standalone HTML component that renders a list of\nany facet instances, as described in its <code>data</code> attribute:<br />\n\n<br />\n<!-- simple facet list -->\n<div class=\"facet-container\">\n    <facet-list data='[\n        {\n            \"type\": \"facet-terms\",\n            \"data\": {\n                \"label\": \"Facet Terms\",\n                \"values\": [{ \"ratio\": 0.5, \"label\": \"Fifty\", \"value\": 50 }]\n            }\n        },\n        {\n            \"type\": \"facet-bars\",\n            \"data\": {\n                \"label\": \"Facet Bars\",\n                \"values\": [\n                    { \"ratio\": 0.1 },\n                    { \"ratio\": 0.2 },\n                    { \"ratio\": 0.3 },\n                    { \"ratio\": 0.4 },\n                    { \"ratio\": 0.5 },\n                    { \"ratio\": 0.6 },\n                    { \"ratio\": 0.7 },\n                    { \"ratio\": 0.8 },\n                    { \"ratio\": 0.9 },\n                    { \"ratio\": 1.0 }\n                ]\n            }\n        }\n    ]'>\n    </facet-list>\n</div>\n\n<br />\n<code>facet-list</code> components behave as a <code>div</code> element, meaning\nthat they use the full width of its parent element:<br />\n\n<br />\n<!-- facet list with variable width parent -->\n<div style=\"width:75%\">\n    <facet-list data='[\n        {\n            \"type\": \"facet-terms\",\n            \"data\": {\n                \"label\": \"Facet Terms\",\n                \"values\": [{ \"ratio\": 0.5, \"label\": \"Fifty\", \"value\": 50 }]\n            }\n        },\n        {\n            \"type\": \"facet-bars\",\n            \"data\": {\n                \"label\": \"Facet Bars\",\n                \"values\": [\n                    { \"ratio\": 0.1 },\n                    { \"ratio\": 0.2 },\n                    { \"ratio\": 0.3 },\n                    { \"ratio\": 0.4 },\n                    { \"ratio\": 0.5 },\n                    { \"ratio\": 0.6 },\n                    { \"ratio\": 0.7 },\n                    { \"ratio\": 0.8 },\n                    { \"ratio\": 0.9 },\n                    { \"ratio\": 1.0 }\n                ]\n            }\n        }\n    ]'>\n    </facet-list>\n</div>\n<div class=\"annotation\">In the example above, the parent container of the\n    <code>facet-list</code> element has a width of 80%, resize the window to see\n    how the <code>facet-list</code> reacts.\n</div>\n\n<br />\nThe data schema for a <code>facet-list</code> is defined as:<br /><br />\n<div class=\"code-block\"><pre>\nexport interface FacetListDataElement {\n    type: string;\n    data: any;\n}\n\nexport type FacetListData = FacetListDataElement[];\n</pre></div>\n<div class=\"annotation\">\n    different ways of binding data to facets are explored in the\n    <a href=\"example.html?ex=working%20with%20js\">working with js</a> example\n</div>\n\n<br />\n<code>type</code> is the tag name of the facet that will be instantiated i.e.\n<code>facet-term</code><br />\n<code>data</code> is the data that will be bound to the facet instance.<br />\n\n<h3>Customization</h3>\nAs described in the <a href=\"example.html?ex=facet-template\">facet-blueprint</a>\nexample, <code>facet-list</code> instances support customization through the\nslots inherited from their parent <code>facet-blueprint</code> element:<br />\n\n<br />\n<!-- facet term slots inherited from facet-blueprint -->\n<div class=\"facet-container\">\n    <facet-list data='[\n        {\n            \"type\": \"facet-terms\",\n            \"data\": {\n                \"label\": \"Facet Terms\",\n                \"values\": [{ \"ratio\": 0.5, \"label\": \"Fifty\", \"value\": 50 }]\n            }\n        },\n        {\n            \"type\": \"facet-bars\",\n            \"data\": {\n                \"label\": \"Facet Bars\",\n                \"values\": [\n                    { \"ratio\": 0.1 },\n                    { \"ratio\": 0.2 },\n                    { \"ratio\": 0.3 },\n                    { \"ratio\": 0.4 },\n                    { \"ratio\": 0.5 },\n                    { \"ratio\": 0.6 },\n                    { \"ratio\": 0.7 },\n                    { \"ratio\": 0.8 },\n                    { \"ratio\": 0.9 },\n                    { \"ratio\": 1.0 }\n                ]\n            }\n        }\n    ]'>\n        <div slot=\"header\" class=\"slot-header\">header</div>\n        <div slot=\"footer\" class=\"slot-footer\">footer</div>\n        <div slot=\"left\" class=\"slot-left\">left</div>\n        <div slot=\"right\" class=\"slot-right\">right</div>\n    </facet-list>\n</div>\n\n<br />\neach of the facets in a <code>facet-list</code> also exposes the slots inherited\nfrom their respective <code>facet-blueprint</code> parents:<br />\n\n<br />\n<!-- facet term slots inherited from facet-blueprint -->\n<div style=\"width: 400px\">\n    <facet-list data='[\n        {\n            \"type\": \"facet-terms\",\n            \"data\": {\n                \"label\": \"Facet Terms\",\n                \"values\": [{ \"ratio\": 0.5, \"label\": \"Fifty\", \"value\": 50 }]\n            }\n        },\n        {\n            \"type\": \"facet-bars\",\n            \"data\": {\n                \"label\": \"Facet Bars\",\n                \"values\": [\n                    { \"ratio\": 0.1 },\n                    { \"ratio\": 0.2 },\n                    { \"ratio\": 0.3 },\n                    { \"ratio\": 0.4 },\n                    { \"ratio\": 0.5 },\n                    { \"ratio\": 0.6 },\n                    { \"ratio\": 0.7 },\n                    { \"ratio\": 0.8 },\n                    { \"ratio\": 0.9 },\n                    { \"ratio\": 1.0 }\n                ]\n            }\n        }\n    ]'>\n        <div slot=\"header\" class=\"slot-header\">header</div>\n        <div slot=\"footer\" class=\"slot-footer\">footer</div>\n        <div slot=\"left\" class=\"slot-left\">left</div>\n        <div slot=\"right\" class=\"slot-right\">right</div>\n        <facet-template target=\"facet-terms\">\n            <div slot=\"header\" class=\"slot-header\">header</div>\n            <div slot=\"footer\" class=\"slot-footer\">footer</div>\n            <div slot=\"left\" class=\"slot-left\">left</div>\n            <div slot=\"right\" class=\"slot-right\">right</div>\n        </facet-template>\n        <facet-template target=\"facet-bars\">\n            <div slot=\"header\" class=\"slot-header\">header</div>\n            <div slot=\"footer\" class=\"slot-footer\">footer</div>\n            <div slot=\"left\" class=\"slot-left\">left</div>\n            <div slot=\"right\" class=\"slot-right\">right</div>\n        </facet-template>\n    </facet-list>\n</div>\n<div class=\"annotation\">\n    The methods to access the slots exposed by the facets within a\n    <code>facet-list</code> are explored in the\n    <a href=\"example.html?ex=facet-template\">facet-template</a> example.<br />\n</div>\n\n<br />\n<br />\n<br />\n";

	var listCSS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-container {\n    width: 300px;\n}\n\n.example-header {\n    background-color: #e5e5e5;\n    border: 5px solid white;\n    padding: 3px;\n    font-family: monospace;\n    font-size: 14px;\n    color: #454545;\n}\n\n.image-left {\n    margin: 5px;\n    width: 40px;\n    height: 40px;\n    border-radius: 50%;\n    background-size: cover;\n}\n\n.histogram-header {\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 14px;\n    line-height: 16px;\n    margin: 5px;\n    padding: 5px;\n    color: #efefef;\n    background-color: #255DCC;\n}\n\n.gradient-scale {\n    height: 100%;\n    width: 7px;\n    background-image: linear-gradient(transparent, transparent 8px, green 8px, #ddff00, orange 65px, red 80px, transparent 80px);\n    transform: translate(16px, -4px);\n}\n\n.inspired-container {\n    width: 300px;\n    border-left: ridge 2px #ffffff;\n    border-top: ridge 2px #ffffff;\n    border-right: ridge 2px #909090;\n    border-bottom: ridge 2px #909090;\n}\n\n.inspired-header {\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 14px;\n    line-height: 35px;\n    height: 35px;\n    padding-left: 45px;\n    background: linear-gradient(0.25turn, rgb(0,13,123), rgb(0,13,123) 35px, rgb(192,192,192) 35px);\n}\n\n.inspired-left {\n    width: 35px;\n    height: 100%;\n    position: relative;\n    background: linear-gradient(1turn, rgb(0,26,169), rgb(0,37,244) 50px, rgb(0,13,123) 180px);\n}\n\n.inspired-left-text {\n    width: 200px;\n    height: 45px;\n    color: white;\n\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 28px;\n    line-height: 45px;\n\n    position: absolute;\n    bottom: 0;\n    left: 0;\n\n    transform: rotate(-90deg) translate(42%, -82px);\n}\n\n.inspired-left-facets {\n    font-weight: 600;\n}\n\n.inspired-left-2 {\n    font-weight: 100;\n    margin-left: -6px;\n}\n\n.slot-header {\n    background-color: #ff0000;\n    padding: 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n}\n\n.slot-footer {\n    background-color: #00ff00;\n    padding: 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: gray;\n    text-align: center;\n    border: 1px solid black;\n}\n\n.slot-left {\n    background-color: #0000ff;\n    padding: 0 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    max-width: 44px;\n}\n\n.slot-right {\n    background-color: #ffff00;\n    padding: 0 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: gray;\n    text-align: center;\n    border: 1px solid black;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    max-width: 44px;\n}\n\n.big-value {\n    font-size: 16px;\n    line-height: 24px;\n    white-space: nowrap;\n}\n\n/* text styles */\ncode {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n\n.annotation {\n    color: #767676;\n    font-family: monospace;\n    font-size: 13px;\n    margin: 6px 0;\n}\n\n.code-block {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n";

	var listJS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n/* */\n";

	var templateHTML = "<!--\n  ~  Copyright (c) 2020 Uncharted Software Inc.\n  ~  http://www.uncharted.software/\n  ~\n  ~   Permission is hereby granted, free of charge, to any person obtaining a copy of\n  ~  this software and associated documentation files (the \"Software\"), to deal in\n  ~  the Software without restriction, including without limitation the rights to\n  ~  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  ~  of the Software, and to permit persons to whom the Software is furnished to do\n  ~  so, subject to the following conditions:\n  ~\n  ~  The above copyright notice and this permission notice shall be included in all\n  ~  copies or substantial portions of the Software.\n  ~\n  ~  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n  ~  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  ~  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  ~  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  ~  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  ~  SOFTWARE.\n  ~\n  -->\n\n<h1>facet-template</h1>\n<!-- stacked term facets -->\n<div class=\"facet-container\">\n    <facet-list data='[\n\t\t{\n\t\t\t\"type\": \"facet-term#product\",\n\t\t\t\"data\": {\n\t\t\t\t\"ratio\": 0.66,\n\t\t\t\t\"label\": \"Product Performance\",\n\t\t\t\t\"annotation\": \"GeoTime\",\n\t\t\t\t\"value\": 66\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"facet-term#sentiment\",\n\t\t\t\"data\": {\n\t\t\t\t\"ratio\": 0.82,\n\t\t\t\t\"label\": \"Product Feedback\",\n\t\t\t\t\"annotation\": \"Positive\",\n\t\t\t\t\"value\": 82,\n\t\t\t\t\"metadata\": \"green\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"facet-histogram\",\n\t\t\t\"data\": {\n\t\t\t\t\"values\": [\n                    { \"ratio\": 0.1, \"labels\": { \"left\": 0, \"right\": 1 } },\n                    { \"ratio\": 0.2, \"labels\": { \"left\": 1, \"right\": 2 } },\n                    { \"ratio\": 0.3, \"labels\": { \"left\": 2, \"right\": 3 } },\n                    { \"ratio\": 0.4, \"labels\": { \"left\": 3, \"right\": 4 } },\n                    { \"ratio\": 0.5, \"labels\": { \"left\": 4, \"right\": 5 } },\n                    { \"ratio\": 0.6, \"labels\": { \"left\": 5, \"right\": 6 } },\n                    { \"ratio\": 0.7, \"labels\": { \"left\": 6, \"right\": 7 } },\n                    { \"ratio\": 0.8, \"labels\": { \"left\": 7, \"right\": 8 } },\n                    { \"ratio\": 0.9, \"labels\": { \"left\": 8, \"right\": 9 } },\n                    { \"ratio\": 1.0, \"labels\": { \"left\": 9, \"right\": 10 } }\n                ],\n\t\t\t\t\"metadata\": \"Adoption Rate\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"facet-blueprint#map\",\n\t\t\t\"data\": {\n\t\t\t\t\"title\": \"Product Headquarters\",\n\t\t\t\t\"url\": \"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d2886.9015894001313!2d-79.36674028410965!3d43.650215779121446!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x89d4cb3b866028bd%3A0x69cd93192feba9ab!2sUncharted%20Software!5e0!3m2!1sen!2sca!4v1569255437594!5m2!1sen!2sca\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"facet-term#video\",\n\t\t\t\"data\": {\n\t\t\t\t\"ratio\": 0.75,\n\t\t\t\t\"label\": \"Video Views\",\n\t\t\t\t\"annotation\": \"(lifetime)\",\n\t\t\t\t\"value\": \"1,414\",\n\t\t\t\t\"metadata\": \"iFMq_PMB4fM\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"facet-term\",\n\t\t\t\"data\": {\n\t\t\t\t\"ratio\": 0.50,\n\t\t\t\t\"label\": \"Local Agencies\",\n\t\t\t\t\"value\": 447\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"facet-term\",\n\t\t\t\"data\": {\n\t\t\t\t\"ratio\": 0.10,\n\t\t\t\t\"label\": \"Federal Agencies\",\n\t\t\t\t\"value\": 26\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"facet-term\",\n\t\t\t\"data\": {\n\t\t\t\t\"ratio\": 0.06,\n\t\t\t\t\"label\": \"Global Agencies\",\n\t\t\t\t\"annotation\": \"GeoTime\",\n\t\t\t\t\"value\": 4\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"type\": \"facet-histogram\",\n\t\t\t\"data\": {\n\t\t\t\t\"values\": [\n                    { \"ratio\": 0.1, \"labels\": { \"left\": 0, \"right\": 1 } },\n                    { \"ratio\": 0.2, \"labels\": { \"left\": 1, \"right\": 2 } },\n                    { \"ratio\": 0.3, \"labels\": { \"left\": 2, \"right\": 3 } },\n                    { \"ratio\": 0.4, \"labels\": { \"left\": 3, \"right\": 4 } },\n                    { \"ratio\": 0.5, \"labels\": { \"left\": 4, \"right\": 5 } },\n                    { \"ratio\": 0.6, \"labels\": { \"left\": 5, \"right\": 6 } },\n                    { \"ratio\": 0.7, \"labels\": { \"left\": 6, \"right\": 7 } },\n                    { \"ratio\": 0.8, \"labels\": { \"left\": 7, \"right\": 8 } },\n                    { \"ratio\": 0.9, \"labels\": { \"left\": 8, \"right\": 9 } },\n                    { \"ratio\": 1.0, \"labels\": { \"left\": 9, \"right\": 10 } }\n                ],\n\t\t\t\t\"metadata\": \"Crimes Solved\"\n\t\t\t}\n\t\t}\n\t]'>\n        <div slot=\"header\" class=\"example-header\">Product Facets</div>\n        <facet-template target=\"facet-term#product\">\n            <div slot=\"header\" class=\"geotime-header\"></div>\n        </facet-template>\n        <facet-template target=\"facet-term#sentiment\">\n            <div slot=\"right\" class=\"color-right\" template-style=\"background-color:${metadata};\"></div>\n        </facet-template>\n        <facet-template target=\"facet-histogram\">\n            <div slot=\"header\" class=\"histogram-header\">${metadata}</div>\n        </facet-template>\n        <facet-template target=\"facet-blueprint#map\">\n            <div slot=\"header\" class=\"histogram-header\">${title}</div>\n            <div slot=\"content\" class=\"media-content\">\n                <iframe\n                    src=\"${url}\"\n                    width=\"290\"\n                    height=\"300\"\n                    frameborder=\"0\"\n                    style=\"border:0;\"\n                    allowfullscreen=\"\">\n                </iframe>\n            </div>\n        </facet-template>\n        <facet-template target=\"facet-term#video\">\n            <div slot=\"header\" class=\"video-content\">\n                <iframe\n                    width=\"290\"\n                    height=\"163\"\n                    src=\"https://www.youtube.com/embed/${metadata}\"\n                    frameborder=\"0\"\n                    allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\n                    allowfullscreen>\n                </iframe>\n            </div>\n        </facet-template>\n    </facet-list>\n</div>\n\n<br />\n<h3>Definition</h3>\n<code>facet-template</code> is a standalone HTML component meant to allow\ncustomization of facets inside facet containers, like <code>facet-list</code>,\nwhile providing access to the data set to each facet through the use of familiar\nES6 template strings syntax:<br />\n\n<br />\n<div class=\"code-block\"><pre>\n&lt;facet-template target=\"facet-term\"&gt;\n\t&lt;div slot=\"header\"&gt;${metadata.title}&lt;/div&gt;\n&lt;/facet-template&gt;\n</pre></div>\n\n<br />\n<h3>Setup</h3>\n\nA <code>facet-template</code> instance creates a template for a single facet type\nas defined in its <code>target</code> attribute. Once a target has been defined\nthe content of the <code>facet-template</code> instance acts as the template of\nfor the facet type. At this point the slots defined for each facet are accessible\ndirectly from the <code>slot</code> attribute of the <code>facet-template</code>\nchildren.<br />\n\n<h3>Accessing data</h3>\n\nThe data defined for each facet is accessible within a <code>facet-template</code>\nthrough the use of delimter characters, for example, if the data for a facet is:\n<br />\n\n<br />\n<div class=\"code-block\"><pre>\nconst facetData = {\n    ratio: 0.5,\n    label: 'a facet!',\n    annotation: 'annotation',\n    value: 123,\n    metadata: {\n        title: 'The Title',\n        footer: 'footsies',\n        left: 'sinister',\n        right: 'dexter',\n    },\n};\n</pre></div>\n<br />\n\nThe data could be accessed as follows in the <code>facet-template</code> instance:\n<br />\n\n<br />\n<div class=\"code-block\"><pre>\n&lt;facet-template target=\"facet-term\"&gt;\n\t&lt;div slot=\"header\"&gt;${metadata.title} for ${label}&lt;/div&gt;\n    &lt;div slot=\"footer\"&gt;${metadata.footer} of value: ${value}&lt;/div&gt;\n    &lt;div slot=\"left\"&gt;${metadata.left}&lt;/div&gt;\n    &lt;div slot=\"right\"&gt;${metadata.right}&lt;/div&gt;\n&lt;/facet-template&gt;\n</pre></div>\n<br />\n\nWhich would render as follows:<br />\n\n<br />\n<div class=\"facet-container\">\n    <facet-list data='[\n\t\t{\n\t    \t\"type\": \"facet-term\",\n\t\t\t\"data\": {\n              \"ratio\": 0.5,\n              \"label\": \"a facet!\",\n              \"annotation\": \"annotation\",\n              \"value\": 123,\n              \"metadata\": {\n                  \"title\": \"The Title\",\n                  \"footer\": \"footsies\",\n                  \"left\": \"sinister\",\n                  \"right\": \"dexter\"\n              }\n          }\n\t\t}\n    ]'>\n        <facet-template target=\"facet-term\">\n            <div slot=\"header\">${metadata.title} for ${label}</div>\n            <div slot=\"footer\">${metadata.footer} of value: ${value}</div>\n            <div slot=\"left\">${metadata.left}</div>\n            <div slot=\"right\">${metadata.right}</div>\n        </facet-template>\n    </facet-list>\n</div>\n\n<h3>Tagging</h3>\n\nSome times, several different templates are needed for the same facet type,\ntagging solves that problem by allowing developers to append an arbitrary tag to\nthe facet type. To do so, simply append a <code>#</code> symbol followed by a tag\nto identify the template:<br />\n\n<br />\n<div class=\"code-block\"><pre>\n&lt;facet-template target=\"facet-term#01\"&gt;\n\t&lt;div slot=\"header\"&gt;${metadata.title}&lt;/div&gt;\n&lt;/facet-template&gt;\n</pre></div>\n\n<br />\nThen add the same tag to the <code>type</code>:<br />\n\n<br />\n<div class=\"code-block\"><pre>\nconst facetListData = [\n    {\n        type: 'facet-term#01',\n        data: {\n            ratio: 0.5,\n            label: 'a facet!',\n            annotation: 'annotation',\n            value: 123,\n            metadata: {\n                title: 'The Title',\n                footer: 'footsies',\n                left: 'sinister',\n                right: 'dexter',\n            },\n        },\n    },\n];\n</pre></div>\n<br />\n\n<h3>Attributes</h3>\n\n<code>facet-template</code> instances also allow developers to customize the\nattributes of their target facet type. To do so, simply add the attributes that\nneed to be assigned to the <code>facet-template</code> instance itself:<br />\n\n<br />\n<div class=\"code-block\"><pre>\n&lt;facet-template target=\"facet-term#01\" actionbuttons=\"${metadata.actionButtons}\"&gt;\n\t&lt;div slot=\"header\"&gt;${metadata.title}&lt;/div&gt;\n&lt;/facet-template&gt;\n</pre></div>\n<br />\n\nsome attriutes can conflict with the <code>facet-template</code> attributes or,\ndepending on the engine used, be sanitized at compile time by templating engines.\nTo solve this issue, it is a good practice to prepend <code>template-</code> to\nany attribute that needs to be passed down to the facet type itself:<br />\n\n<br />\n<div class=\"code-block\"><pre>\n&lt;facet-template target=\"facet-term#01\" template-style:\"background-color:${metadata.bg}\"&gt;\n\t&lt;div slot=\"header\"&gt;${metadata.title}&lt;/div&gt;\n&lt;/facet-template&gt;\n</pre></div>\n<br />\n\n<!-- <h3>Styling</h3> -->\n\n<term-facet></term-facet>\n<facet-histogram></facet-histogram>\n<image-facet></image-facet>\n\n<br />\n<br />\n<br />\n";

	var templateCSS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-container {\n    width: 300px;\n}\n\n.example-header {\n    background-color: #e5e5e5;\n    border: 5px solid white;\n    padding: 3px;\n    font-family: monospace;\n    font-size: 14px;\n    color: #454545;\n}\n\n.histogram-header {\n    font-family: \"IBM Plex Sans\", sans-serif;\n    font-size: 14px;\n    line-height: 16px;\n    border-top: 5px solid white;\n    border-left: 5px solid white;\n    border-right: 5px solid white;\n    padding: 5px;\n    color: #efefef;\n    background-color: #255DCC;\n}\n\n.color-right {\n    width: 5px;\n    height: 100%;\n    margin-right: 5px;\n}\n\n.geotime-header {\n    height: 100px;\n    background-image: url(\"img/geotime.png\");\n    background-size: contain;\n    margin: 5px;\n}\n\n.media-content {\n    background-color: white;\n    padding: 0 5px 5px;\n}\n\n.video-content {\n    padding: 0 5px 5px;\n}\n\n.slot-header {\n    background-color: #ff0000;\n    padding: 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n}\n\n.slot-footer {\n    background-color: #00ff00;\n    padding: 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: gray;\n    text-align: center;\n    border: 1px solid black;\n}\n\n.slot-left {\n    background-color: #0000ff;\n    padding: 0 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: white;\n    text-align: center;\n    border: 1px solid black;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    max-width: 44px;\n}\n\n.slot-right {\n    background-color: #ffff00;\n    padding: 0 5px;\n    font-family: monospace;\n    font-size: 13px;\n    color: gray;\n    text-align: center;\n    border: 1px solid black;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    max-width: 44px;\n}\n\n.big-value {\n    font-size: 16px;\n    line-height: 24px;\n    white-space: nowrap;\n}\n\n/* text styles */\ncode {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n\n.annotation {\n    color: #767676;\n    font-family: monospace;\n    font-size: 13px;\n    margin: 6px 0;\n}\n\n.code-block {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n";

	var templateJS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n/* */\n";

	var pluginHTML = "<!--\n  ~  Copyright (c) 2020 Uncharted Software Inc.\n  ~  http://www.uncharted.software/\n  ~\n  ~   Permission is hereby granted, free of charge, to any person obtaining a copy of\n  ~  this software and associated documentation files (the \"Software\"), to deal in\n  ~  the Software without restriction, including without limitation the rights to\n  ~  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  ~  of the Software, and to permit persons to whom the Software is furnished to do\n  ~  so, subject to the following conditions:\n  ~\n  ~  The above copyright notice and this permission notice shall be included in all\n  ~  copies or substantial portions of the Software.\n  ~\n  ~  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n  ~  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  ~  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  ~  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  ~  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  ~  SOFTWARE.\n  ~\n  -->\n\n<div class=\"facet-container\">\n</div>\n";

	var pluginCSS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.facet-container {\n    width: 300px;\n}\n\n/* text styles */\ncode {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n\n.annotation {\n    color: #767676;\n    font-family: monospace;\n    font-size: 13px;\n    margin: 6px 0;\n}\n\n.code-block {\n    padding: 1px;\n    background-color: #d5d5d5;\n    border: 1px solid #767676;\n    font-family: monospace;\n    font-size: 13px;\n}\n";

	var pluginJS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n/* */\n";

	var buildHTML = "<!--\n  ~  Copyright (c) 2020 Uncharted Software Inc.\n  ~  http://www.uncharted.software/\n  ~\n  ~   Permission is hereby granted, free of charge, to any person obtaining a copy of\n  ~  this software and associated documentation files (the \"Software\"), to deal in\n  ~  the Software without restriction, including without limitation the rights to\n  ~  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  ~  of the Software, and to permit persons to whom the Software is furnished to do\n  ~  so, subject to the following conditions:\n  ~\n  ~  The above copyright notice and this permission notice shall be included in all\n  ~  copies or substantial portions of the Software.\n  ~\n  ~  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n  ~  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  ~  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  ~  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  ~  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  ~  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  ~  SOFTWARE.\n  ~\n  -->\n\n<!-- 290 x 163 -->\n\n<div class=\"list-container\">\n    <facet-list id=\"example\">\n\n    </facet-list>\n</div>\n";

	var buildCSS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\n.list-container {\n    width: 300px;\n}\n";

	var buildJS = "/*\n *  Copyright (c) 2020 Uncharted Software Inc.\n *  http://www.uncharted.software/\n *\n *   Permission is hereby granted, free of charge, to any person obtaining a copy of\n *  this software and associated documentation files (the \"Software\"), to deal in\n *  the Software without restriction, including without limitation the rights to\n *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n *  of the Software, and to permit persons to whom the Software is furnished to do\n *  so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n */\n\nwindow.addEventListener('load', function () {\n    const facetList = document.querySelector('#example');\n    facetList.data = [\n        {\n            type: 'facet-term',\n            data: {\n                ratio: 0.456,\n                label: 'Example Facet',\n                value: 456,\n            },\n        },\n        {\n            type: 'facet-term',\n            data: {\n                ratio: 0.456,\n                label: 'Example Facet',\n                value: 456,\n            },\n        },\n        {\n            type: 'facet-term',\n            data: {\n                ratio: 0.456,\n                label: 'Example Facet',\n                value: 456,\n            },\n        },\n        {\n            type: 'facet-histogram',\n            data: {\n                values: [\n                    {ratio: 0.1, labels: {left: 0, right: 1}},\n                    {ratio: 0.2, labels: {left: 1, right: 2}},\n                    {ratio: 0.3, labels: {left: 2, right: 3}},\n                    {ratio: 0.4, labels: {left: 3, right: 4}},\n                    {ratio: 0.5, labels: {left: 4, right: 5}},\n                    {ratio: 0.6, labels: {left: 5, right: 6}},\n                    {ratio: 0.7, labels: {left: 6, right: 7}},\n                    {ratio: 0.8, labels: {left: 7, right: 8}},\n                    {ratio: 0.9, labels: {left: 8, right: 9}},\n                    {ratio: 1.0, labels: {left: 9, right: 10}},\n                ],\n            },\n        },\n    ];\n\n    setTimeout(function () {\n        facetList.data = [\n            {\n                type: 'facet-term',\n                data: {\n                    ratio: 0.123,\n                    label: 'Example Facet',\n                    value: 123,\n                },\n            },\n            {\n                type: 'facet-term',\n                data: {\n                    ratio: 0.789,\n                    label: 'Example Facet',\n                    value: 789,\n                },\n            },\n            {\n                type: 'facet-term',\n                data: {\n                    ratio: 0.345,\n                    label: 'Example Facet',\n                    value: 345,\n                },\n            },\n            {\n                type: 'facet-histogram',\n                data: {\n                    values: [\n                        {ratio: 1.0, labels: {left: 9, right: 10}},\n                        {ratio: 0.9, labels: {left: 8, right: 9}},\n                        {ratio: 0.8, labels: {left: 7, right: 8}},\n                        {ratio: 0.7, labels: {left: 6, right: 7}},\n                        {ratio: 0.6, labels: {left: 5, right: 6}},\n                        {ratio: 0.5, labels: {left: 4, right: 5}},\n                        {ratio: 0.4, labels: {left: 3, right: 4}},\n                        {ratio: 0.3, labels: {left: 2, right: 3}},\n                        {ratio: 0.2, labels: {left: 1, right: 2}},\n                        {ratio: 0.1, labels: {left: 0, right: 1}},\n                    ],\n                },\n            },\n        ];\n    }, 1000);\n});\n";

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */
	var examples = {
	  'facet-blueprint': {
	    html: blueprintHTML,
	    css: blueprintCSS,
	    js: blueprintJS
	  },
	  'facet-terms': {
	    html: termHTML,
	    css: termCSS,
	    js: termJS
	  },
	  'facet-bars': {
	    html: barsHTML,
	    css: barsCSS,
	    js: barsJS
	  },
	  'facet-timeline': {
	    html: timelineHTML,
	    css: timelineCSS,
	    js: timelineJS
	  },
	  'facet-list': {
	    html: listHTML,
	    css: listCSS,
	    js: listJS
	  },
	  'facet-template': {
	    html: templateHTML,
	    css: templateCSS,
	    js: templateJS
	  },
	  'facet-plugin': {
	    html: pluginHTML,
	    css: pluginCSS,
	    js: pluginJS
	  },
	  'build-a-facet': {
	    html: buildHTML,
	    css: buildCSS,
	    js: buildJS
	  }
	};

	var _dec, _dec2, _class, _class2, _descriptor, _temp;

	function _templateObject3$d() {
	  var data = _taggedTemplateLiteral(["<option>", "</option>"]);

	  _templateObject3$d = function _templateObject3() {
	    return data;
	  };

	  return data;
	}

	function _templateObject2$g() {
	  var data = _taggedTemplateLiteral(["\n        <div class=\"facet-example-container\">\n            <div class=\"facet-example-editor-container\">\n                <div class=\"facet-example-editor-header\">\n                    <div id=\"buttonHTML\" class=\"facet-example-editor-button facet-example-editor-button-selected\" @click=\"", "\">HTML</div>\n                    <div id=\"buttonCSS\" class=\"facet-example-editor-button\" @click=\"", "\">CSS</div>\n                    <div id=\"buttonJS\" class=\"facet-example-editor-button\" @click=\"", "\">JS</div>\n                    <div class=\"facet-example-editor-button-run\" @click=\"", "\">RUN</div>\n                </div>\n                <div class=\"facet-example-editor-body\">\n                    <div id=\"editorHTML\" class=\"facet-example-editor\" style=\"visibility:visible\"></div>\n                    <div id=\"editorCSS\" class=\"facet-example-editor\" style=\"visibility:hidden\"></div>\n                    <div id=\"editorJS\" class=\"facet-example-editor\" style=\"visibility:hidden\"></div>\n                </div>\n            </div>\n            <div id=\"preview\" class=\"facet-example-preview\">\n                <div class=\"facet-example-preview-header\">\n                    <select id=\"facet-example-select\" class=\"facet-example-select\" @change=\"", "\">\n                        <option disabled value> -- example -- </option>\n                        ", "\n                        <option>empty</option>\n                    </select>\n                </div>\n                <iframe id=\"preview-iframe\" class=\"facet-example-preview-iframe\"></iframe>\n            </div>\n        </div>\n        "]);

	  _templateObject2$g = function _templateObject2() {
	    return data;
	  };

	  return data;
	}

	function _templateObject$j() {
	  var data = _taggedTemplateLiteral(["\n        ", "\n        ", "\n        ", "\n        "]);

	  _templateObject$j = function _templateObject() {
	    return data;
	  };

	  return data;
	}

	var FacetExample = (_dec = customElement('facet-example'), _dec2 = property({
	  type: Object
	}), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_LitElement) {
	  _inherits(FacetExample, _LitElement);

	  var _super = _createSuper(FacetExample);

	  _createClass(FacetExample, null, [{
	    key: "styles",
	    get: function get() {
	      return css(_templateObject$j(), unsafeCSS(codeMirrorStyle), unsafeCSS(darculaStyle), unsafeCSS(examplesStyle));
	    }
	  }]);

	  function FacetExample(example) {
	    var _this;

	    _classCallCheck(this, FacetExample);

	    _this = _super.call(this);

	    _initializerDefineProperty(_this, "example", _descriptor, _assertThisInitialized(_this));

	    _this.editorHTML = null;
	    _this.editorCSS = null;
	    _this.editorJS = null;
	    _this.preview = null;
	    _this.iframeInitialized = false;
	    _this.example = example;
	    return _this;
	  }

	  _createClass(FacetExample, [{
	    key: "render",
	    value: function render() {
	      return html$1(_templateObject2$g(), this._handleEditorButton.bind(this, 'HTML'), this._handleEditorButton.bind(this, 'CSS'), this._handleEditorButton.bind(this, 'JS'), this._renderHTML, this._handleSelectChange, Object.keys(examples).map(function (example) {
	        return html$1(_templateObject3$d(), example);
	      }));
	    }
	  }, {
	    key: "firstUpdated",
	    value: function firstUpdated(_changedProperties) {
	      var _this2 = this;

	      _get(_getPrototypeOf(FacetExample.prototype), "firstUpdated", this).call(this, _changedProperties);

	      window.addEventListener('keydown', function (event) {
	        if ((event.ctrlKey || event.metaKey) && event.key === 's') {
	          event.preventDefault();

	          _this2._renderHTML();
	        }
	      });
	    }
	  }, {
	    key: "updated",
	    value: function updated(_changedProperties) {
	      _get(_getPrototypeOf(FacetExample.prototype), "update", this).call(this, _changedProperties);

	      var example = examples[this.example];

	      if (!this.editorHTML) {
	        var editorElement = this.renderRoot.querySelector('#editorHTML');
	        this.editorHTML = new codemirror(editorElement, {
	          mode: 'htmlmixed',
	          theme: 'darcula',
	          value: example ? example.html : '',
	          lineNumbers: true
	        });
	        this.editorHTML.setSize('100%', '100%');
	      }

	      if (!this.editorCSS) {
	        var _editorElement = this.renderRoot.querySelector('#editorCSS');

	        this.editorCSS = new codemirror(_editorElement, {
	          mode: 'css',
	          theme: 'darcula',
	          value: example ? example.css : '',
	          lineNumbers: true
	        });
	        this.editorCSS.setSize('100%', '100%');
	      }

	      if (!this.editorJS) {
	        var _editorElement2 = this.renderRoot.querySelector('#editorJS');

	        this.editorJS = new codemirror(_editorElement2, {
	          mode: 'javascript',
	          theme: 'darcula',
	          value: example ? example.js : '',
	          lineNumbers: true
	        });
	        this.editorJS.setSize('100%', '100%');
	      }

	      if (!this.preview) {
	        this.preview = this.renderRoot.querySelector('#preview-iframe');
	      }

	      var select = this.renderRoot.querySelector('#facet-example-select');

	      if (select) {
	        var selectedExample = examples.hasOwnProperty(this.example) ? this.example : null;
	        var exampleNames = Object.keys(examples);
	        var selectedIndex = selectedExample ? exampleNames.indexOf(selectedExample) + 1 : 0;
	        select.selectedIndex = selectedIndex;
	      }

	      this._renderHTML();
	    }
	  }, {
	    key: "_getTemplateResult",
	    value: function _getTemplateResult() {
	      var template = "\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<base target=\"_parent\" />\n<link href=\"https://fonts.googleapis.com/css?family=IBM+Plex+Sans&display=swap\" rel=\"stylesheet\">\n<style>\n".concat(this.editorCSS.getValue(), "\n</style>\n</head>\n<body>\n<script>\nif (!window.facetsdocs) {\n    const script = document.createElement('script');\n    script.setAttribute('type', 'text/javascript');\n    script.setAttribute('src', 'dist/iife/index.js');\n\n    document.body.style.visibility = 'hidden';\n    script.addEventListener('load', function() {\n        setTimeout(function() {\n            document.body.style.visibility = 'visible';\n        }, 50);\n    });\n\n    document.head.appendChild(script);\n}\n</script>\n").concat(this.editorHTML.getValue(), "\n<script>\n(function() {\n    ").concat(this.editorJS.getValue(), "\n})();\n</script>\n</body>\n</html>\n        ");
	      this.iframeInitialized = true;
	      return template;
	    }
	  }, {
	    key: "_renderHTML",
	    value: function _renderHTML() {
	      if (this.preview && this.preview.contentDocument) {
	        var templateResult = this._getTemplateResult();

	        this.preview.contentDocument.open();
	        this.preview.contentDocument.write(templateResult);
	        this.preview.contentDocument.close();
	      }
	    }
	  }, {
	    key: "_handleEditorButton",
	    value: function _handleEditorButton(target) {
	      var options = ['HTML', 'CSS', 'JS'];

	      for (var i = 0, n = options.length; i < n; ++i) {
	        var button = this.renderRoot.querySelector("#button".concat(options[i]));
	        var editor = this.renderRoot.querySelector("#editor".concat(options[i]));

	        if (options[i] === target) {
	          button.setAttribute('class', 'facet-example-editor-button facet-example-editor-button-selected');
	          editor.setAttribute('style', 'visibility:visible');
	        } else {
	          button.setAttribute('class', 'facet-example-editor-button');
	          editor.setAttribute('style', 'visibility:hidden');
	        }
	      }
	    }
	  }, {
	    key: "_handleSelectChange",
	    value: function _handleSelectChange(e) {
	      var select = e.target;
	      window.location.href = "".concat(window.location.pathname, "?ex=").concat(select.options[select.selectedIndex].value);
	    }
	  }]);

	  return FacetExample;
	}(LitElement), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "example", [_dec2], {
	  configurable: true,
	  enumerable: true,
	  writable: true,
	  initializer: function initializer() {
	    return '';
	  }
	})), _class2)) || _class);

	/*
	 *  Copyright (c) 2020 Uncharted Software Inc.
	 *  http://www.uncharted.software/
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy of
	 *  this software and associated documentation files (the "Software"), to deal in
	 *  the Software without restriction, including without limitation the rights to
	 *  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	 *  of the Software, and to permit persons to whom the Software is furnished to do
	 *  so, subject to the following conditions:
	 *
	 *  The above copyright notice and this permission notice shall be included in all
	 *  copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
	 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 *  SOFTWARE.
	 *
	 */
	function bootstrap() {
	  var params = new URLSearchParams(window.location.search);
	  var example = params.get('ex');
	  var element = new FacetExample(example);
	  document.body.appendChild(element);
	}

	var Examples = {
	  basic: bootstrap
	};

	exports.Examples = Examples;
	exports.Facets = index$1;
	exports.Plugins = index$2;

	return exports;

}({}));
//# sourceMappingURL=index.js.map
